<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>開發紀錄：商品分類實作</title>
    <url>/%E9%96%8B%E7%99%BC%E7%B4%80%E9%8C%84/20200518/2522345259/</url>
    <content><![CDATA[<p>最近陸陸續續經手了幾個公司專案的新功能，其中一個功能是要幫所有商品加上分類，<br>然而在實作過程中卡關了一陣子，因此特別撰寫本文來記錄這次任務的幾種解法。</p>
<a id="more"></a>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我目前負責公司電商網站的維護，公司專案有個需求是要做出商品分類，在開發時我遇到一個 bug 解不出來，因此在六角學院社團附上 Demo 跟大家請教。</p>
<p>Demo：</p>
<iframe src="https://codepen.io/gretema/embed/NWGzMJW?height=265&theme-id=dark&default-tab=js,result" width="100%" height="300" frameborder="0" loading="lazy" allowfullscreen></iframe>

<h2 id="卡關背景"><a href="#卡關背景" class="headerlink" title="卡關背景"></a>卡關背景</h2><h3 id="邏輯"><a href="#邏輯" class="headerlink" title="邏輯"></a>邏輯</h3><p>由於所有商品本身所建的分類較瑣細，而專案所需要呈現的分類涵蓋範圍較廣，因此資料需要經過額外的處理、比對，將所有商品歸納到各大分類之中，如果不屬於所列舉的分類，就把商品放到「其他」類。最後將所有分類與所屬的商品呈現在畫面上。</p>
<h3 id="資料命名"><a href="#資料命名" class="headerlink" title="資料命名"></a>資料命名</h3><p>在我附上的 Demo 中，<code>allVariant</code> 陣列是代表所有商品（裡面放的每個物件都是一個商品，<code>type</code> 屬性代表商品本身建的小分類），<code>classifiedProducts</code> 物件則是我想呈現的分類（<code>types</code> 屬性是陣列，放了多個商品本身所建的小分類；<code>arr</code> 屬性也是陣列，用來放過濾後的商品）。</p>
<h3 id="目前作法"><a href="#目前作法" class="headerlink" title="目前作法"></a>目前作法</h3><p>用類似雙迴圈的方法，同時迭代 <code>allVariant</code> 陣列與 <code>classifiedProducts</code> 物件，並用 <code>if</code> 判斷如果商品物件的 <code>type</code> 存在於分類物件的 <code>types</code> 陣列中，就把當前的商品物件 push 到當前分類的 <code>arr</code>；否則就 push 到「其他」類的 <code>arr</code>。</p>
<h3 id="目前問題"><a href="#目前問題" class="headerlink" title="目前問題"></a>目前問題</h3><p>「其他」類中，有許多筆重複的商品資料，且這些資料應該被放到別的分類中，卻都被放到「其他」類。</p>
<h2 id="各種解法"><a href="#各種解法" class="headerlink" title="各種解法"></a>各種解法</h2><p>卡在這個問題上已經超過一個早上了，最後真的走投無路於是還是來到六角學院的臉書社團發問，萬幸有不少同學（甚至還有助教）提供解法攻我參考，以下就將他們的解法列出來。</p>
<h3 id="解法一：while-迴圈法"><a href="#解法一：while-迴圈法" class="headerlink" title="解法一：while 迴圈法"></a>解法一：<code>while</code> 迴圈法</h3><p>提供這個方法的是玟憲同學，他同時還解說為何我的寫法會出錯：</p>
<blockquote>
<p><code>this.allVariants</code> 用 <code>forEach</code> 後裡面那個 <code>for</code> 迴圈，第一個 <code>variant</code> 的 <code>type</code> 為 <code>&#39;3d-screen-protector&#39;</code>，就會跟 <code>this.classifiedProducts</code> 裡的每個 <code>key</code> 裡的 <code>types</code> 做比對，所以會跑 4 次。在「其他」的那個類別，<code>塑料保護貼1</code> 出現 3 次的原因是：有一個 <code>types</code> 裡有 <code>[&#39;3d-screen-protector&#39;]</code> 所以被 push 進正確的 <code>arr</code>，其餘 3 次都被 push 進 <code>otherProducts.arr</code>。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">filter() &#123;</span><br><span class="line">  <span class="keyword">this</span>.allVariants.forEach(<span class="function">(<span class="params">variant</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; type &#125; = variant;</span><br><span class="line">    <span class="keyword">const</span> classifiedKey = <span class="built_in">Object</span>.keys(<span class="keyword">this</span>.classifiedProducts);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> isMapping = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">let</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(isMapping) &#123;</span><br><span class="line">      <span class="keyword">if</span>(classifiedKey[idx] === <span class="string">'otherProducts'</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.classifiedProducts[classifiedKey[idx]].arr.push(variant);</span><br><span class="line">        isMapping = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(<span class="keyword">this</span>.classifiedProducts[classifiedKey[idx]].types.includes(type)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.classifiedProducts[classifiedKey[idx]].arr.push(variant);</span><br><span class="line">        isMapping = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      idx += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解法說明：</p>
<blockquote>
<p>叫 <code>variant</code> 一個一個去裡面 <code>this.classifiedProducts</code> 找，如果找到，就不要再找。<br><code>this.classifiedProducts</code> 有 4 個物件，先把對應的 key 記下來（<code>classifiedKey</code>），跑 <code>while</code> 時，我需要記得我找到哪裡，idx 可以幫我。<br>所以就先找 <code>classifiedKey[0]</code>，如果有的話，要跳出迴圈（<code>isMapping = false</code>）；<br>沒有的話繼續找 <code>classifiedKey[1]</code>。<br>最後找到 <code>classifiedKey[idx] = &#39;otherProducts&#39;</code>，就代表找完了，所以直接加進 <code>arr</code>。</p>
</blockquote>
<h3 id="解法二：some-法"><a href="#解法二：some-法" class="headerlink" title="解法二：some() 法"></a>解法二：<code>some()</code> 法</h3><p>此解法由葉子助教提供～～</p>
<blockquote>
<p>我是用全部的資料去跑，用 <code>some()</code> 的方式確認資料的 <code>type</code> 有沒有在分類中，有的話就推到對應的 <code>arr</code>，沒有則推到其他。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">filter() &#123;</span><br><span class="line">  <span class="keyword">const</span> vm = <span class="keyword">this</span>;</span><br><span class="line">  vm.allVariants.forEach(<span class="function"><span class="params">ele</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> nowKey = <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">const</span> has = <span class="built_in">Object</span>.keys(vm.classifiedProducts).some(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">      nowKey = key;</span><br><span class="line">      <span class="keyword">return</span> vm.classifiedProducts[key].types.includes(ele.type);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">if</span> (has) &#123;</span><br><span class="line">      vm.classifiedProducts[nowKey].arr.push(ele);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      vm.classifiedProducts[<span class="string">'otherProducts'</span>].arr.push(ele);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>我發現這個解法與上一個解法有一些共通點：</p>
<ul>
<li>都需要用一個變數來記錄「現在找到哪一個 <code>this.classifiedProducts</code> 的 key」</li>
<li>都用額外用一個變數來記錄 type 是否存在於 <code>this.classifiedProducts</code>（布林值）</li>
</ul>
<h3 id="解法三：for-in-法"><a href="#解法三：for-in-法" class="headerlink" title="解法三：for..in 法"></a>解法三：<code>for..in</code> 法</h3><p>此解法由奕鋒同學提供：</p>
<blockquote>
<p>這麼做也可以，只是要確保 <code>otherProducts</code> 是最後一個迭代。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">filter() &#123;</span><br><span class="line">  <span class="keyword">this</span>.allVariants.forEach(<span class="function">(<span class="params">variant</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; type &#125; = variant;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> hasPushItem = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> <span class="keyword">this</span>.classifiedProducts) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.classifiedProducts[key].types.includes(type)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.classifiedProducts[key].arr.push(variant);</span><br><span class="line">        hasPushItem = <span class="literal">true</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key === <span class="string">'otherProducts'</span> &amp;&amp; !hasPushItem) &#123;</span><br><span class="line">        <span class="keyword">this</span>.classifiedProducts.otherProducts.arr.push(variant);</span><br><span class="line">        hasPushItem = <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法四：find-includes-法"><a href="#解法四：find-includes-法" class="headerlink" title="解法四：find() + includes() 法"></a>解法四：<code>find()</code> + <code>includes()</code> 法</h3><p>此解法由強者我同事在 Code Review 時提出，我看了差點膝蓋一軟給他跪下去 😂</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">filter() &#123;</span><br><span class="line">  <span class="keyword">this</span>.allVariants.forEach(<span class="function">(<span class="params">variant</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; type &#125; = variant;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> matchedProdKey = <span class="built_in">Object</span>.keys(<span class="keyword">this</span>.classifiedProducts)</span><br><span class="line">      .find(<span class="function"><span class="params">key</span> =&gt;</span> <span class="keyword">this</span>.classifiedProducts[key].types.includes(type))</span><br><span class="line">    <span class="comment">// find() 會回傳第一個符合條件的元素值，否則回傳 undefined。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> prodKey = matchedProdKey || <span class="string">'otherProducts'</span>;</span><br><span class="line">    <span class="comment">// 如果 matchedProdKey 是 undefined，prodKey 就會被賦予 'otherProducts' 的值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.classifiedProducts[prodKey].arr.push(variant);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<hr>
<p>雖然最後是採用同事的解法，但其實其他同學提供的解法我也覺得很棒，其中使用了很多 ES6 的用法，我想我之後應該會時不時拿出來複習，因此特別寫這篇文以資紀錄。</p>
]]></content>
      <categories>
        <category>開發紀錄</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>w3HexSchool</tag>
        <tag>ES6</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>[JS] JavaScript ES6 常用語法筆記</title>
    <url>/javascript/20200504/221423942/</url>
    <content><![CDATA[<p>一直以為有發過這篇，結果竟然沒有！<br>學習 JavaScript 這麼久了，筆記中當然不能少了 ES6 常用語法囉～</p>
<a id="more"></a>

<h2 id="變數宣告"><a href="#變數宣告" class="headerlink" title="變數宣告"></a>變數宣告</h2><h3 id="var-與-let-的區別"><a href="#var-與-let-的區別" class="headerlink" title="var 與 let 的區別"></a><code>var</code> 與 <code>let</code> 的區別</h3><ol>
<li>是否會提升<br>當我們分別用 <code>var</code> 跟 <code>let</code> 並在宣告變數之前調用變數時，<code>var</code> 會顯示 <code>undefined</code>，代表記憶體有預先準備空間；<code>let</code> 則會顯示 <code>not defined</code>，代表記憶體沒有預先準備空間。</li>
<li>作用域不同<br><code>var</code> 是以 function 做分隔，<code>let</code> 是以 block ( <code>{}</code> ) 做分隔。</li>
</ol>
<h3 id="const"><a href="#const" class="headerlink" title="const"></a><code>const</code></h3><p>代表常數，唯讀，不可再次賦值。但是如果用 <code>const</code> 宣告一個物件，可以在之後修改或新增該物件內部的<strong>特性</strong>，因為物件是傳址（參考）而不是傳值，所以可以這樣做。其他特色與 <code>let</code> 一樣。</p>
<h3 id="迴圈內的-setTimeout"><a href="#迴圈內的-setTimeout" class="headerlink" title="迴圈內的 setTimeout()"></a>迴圈內的 <code>setTimeout()</code></h3><p>假如我們希望用 <code>setTimeout</code> 配合迴圈輸出 1~10，而且每次輸出都延遲 10 毫秒：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>( <span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    comsole.log(i);</span><br><span class="line">  &#125;,<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此時迴圈的計數器 <code>i</code> 是用 <code>var</code> 來宣告，則 <code>setTimeout</code> 得到的數字不會是 1~10，而是得到最後的數字 10，為什麼會這樣呢？</p>
<p>因為 JS 非同步的特點，所以 <code>for</code> 迴圈並不會等到 <code>setTimeout()</code> 結束後才繼續，而是一口氣跑完 1~10；又因為 <code>var</code> 的作用域是以 function 做切分，<code>setTimeout()</code> 的 <code>i</code> 會從外層去取值，此時的 <code>i</code> 已經是跑完 <code>for</code> 迴圈的 10 了。</p>
<p>解決方法是改用 <code>let</code> 宣告計數器，這樣 <code>setTimeout</code> 得到的就會是當下迴圈跑的數字。</p>
<h4 id="另一種解法：立即函式-IIFE"><a href="#另一種解法：立即函式-IIFE" class="headerlink" title="另一種解法：立即函式 (IIFE)"></a>另一種解法：立即函式 (IIFE)</h4><p>除了改用 <code>let</code> 宣告以外，也可以用<strong>立即函式</strong>包住 <code>setTimeout</code>，並將迴圈的 <code>i</code> 作為參數傳入立即函式中，保留當下的 <code>i</code> 一筆筆輸出數字。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 立即函式語法</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 做某事</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用立即函式包住 setTimeout()</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;  </span><br><span class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'這執行第'</span>+ x +<span class="string">'次'</span>);</span><br><span class="line">    &#125;,<span class="number">10</span>);</span><br><span class="line">  &#125;)(i);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="展開符號-…"><a href="#展開符號-…" class="headerlink" title="展開符號 …"></a>展開符號 <code>…</code></h2><p>展開符號能夠把陣列與類陣列裡的內容給取出來。以下說明展開符號的幾個用途。</p>
<h3 id="合併數個陣列"><a href="#合併數個陣列" class="headerlink" title="合併數個陣列"></a>合併數個陣列</h3><p>在一個新宣告的陣列中，把展開符號 <code>...</code> 加在要合併的陣列前方，這種合併的方式與使用 <code>concat()</code> 的效果是一樣的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> groupA = [<span class="string">'小明'</span>, <span class="string">'杰倫'</span>, <span class="string">'阿姨'</span>];</span><br><span class="line"><span class="keyword">let</span> groupB = [<span class="string">'老媽'</span>, <span class="string">'老爸'</span>];</span><br><span class="line"><span class="keyword">let</span> groupAll = [...groupA, ...groupB];</span><br><span class="line"><span class="built_in">console</span>.log(groupAll);</span><br><span class="line"><span class="comment">// ['小明', '杰倫', '阿姨','老媽', '老爸']</span></span><br></pre></td></tr></table></figure>

<h3 id="複製陣列（淺複製）"><a href="#複製陣列（淺複製）" class="headerlink" title="複製陣列（淺複製）"></a>複製陣列（淺複製）</h3><p>陣列與物件一樣，都是傳址（傳參考），所以如果將 B 陣列指向 A陣列，A、B 陣列會被視為同一個實體。如此一來，當我們想要修改 B 陣列時，就會連 A 陣列的內容也修改到。這叫做深複製。</p>
<p>如果只想修改 B 陣列的話，就可以用展開符號來複製 A 陣列，再進行操作。只傳值的複製方式，就是淺複製。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> groupA = [<span class="string">'小明'</span>, <span class="string">'杰倫'</span>, <span class="string">'阿姨'</span>];</span><br><span class="line"><span class="keyword">let</span> groupB = [...groupA] <span class="comment">// 新陣列</span></span><br><span class="line">groupB.push(<span class="string">'阿明'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(groupA); <span class="comment">// 不會有阿明</span></span><br></pre></td></tr></table></figure>

<h3 id="類陣列"><a href="#類陣列" class="headerlink" title="類陣列"></a>類陣列</h3><p>有些東西外觀很像陣列，也具有一些陣列的特性，但卻不是真正的陣列，稱為類陣列，例如用 <code>querySelectorAll()</code> 取出來的 <code>NodeList</code> 會以類陣列的形式呈現所有被選取的節點，但它卻不是真正的陣列。</p>
<p>在新的空陣列中，透過展開符號可以複製類陣列中的內容，藉此將類陣列<strong>轉為真正的陣列</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> doms = <span class="built_in">document</span>.querySelectorAll(<span class="string">'li'</span>); <span class="comment">// doms 為類陣列</span></span><br><span class="line"><span class="keyword">let</span> newDoms = [...doms]; <span class="comment">// newDoms 為陣列</span></span><br></pre></td></tr></table></figure>

<p>另一個類陣列的例子是函式內建的 <code>arguments</code> 物件，<code>arguments</code> 會包含所有傳入函式的參數。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> originCash = <span class="number">1000</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateEasyCard</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// let arg = arguments;</span></span><br><span class="line">  <span class="keyword">let</span> arg = [...arguments]; <span class="comment">// 轉成真正的陣列</span></span><br><span class="line">  <span class="keyword">let</span> sum = arg.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">accumulator, currentValue</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> accumulator + currentValue;</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'我有 '</span> + sum + <span class="string">' 元'</span>);</span><br><span class="line"> &#125;</span><br><span class="line">updateEasyCard(<span class="number">0</span>); <span class="comment">// 我有 1000 元</span></span><br><span class="line">updateEasyCard(<span class="number">10</span>, <span class="number">50</span>, <span class="number">100</span>, <span class="number">50</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">500</span>); <span class="comment">// 我有 718 元</span></span><br></pre></td></tr></table></figure>

<h3 id="其餘參數"><a href="#其餘參數" class="headerlink" title="其餘參數"></a>其餘參數</h3><p>如果不確定之後要傳入函式的參數數量，可以在函式的<strong>唯一一個</strong>或<strong>最後一個</strong>參數前面加上展開符號（該參數就會變成其餘參數），就能把多傳入的參數值以<strong>陣列</strong>的形式，容納在其餘參數中。</p>
<p>注意，函式裡只能有一個其餘參數，而且一定要放在最右邊。</p>
<p>參照：<a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Functions/rest_parameters" target="_blank" rel="external nofollow noopener noreferrer">其餘參數 - JavaScript | MDN</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">moreMoney</span>(<span class="params">...money</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(money);</span><br><span class="line">  <span class="comment">// [100, 200, 300]</span></span><br><span class="line">&#125;</span><br><span class="line"> moreMoney(<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">moreMoney</span>(<span class="params">name, ...money</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(name, money);</span><br><span class="line">  <span class="comment">// "Grete" [100, 200, 300, 400, 500]</span></span><br><span class="line">&#125;</span><br><span class="line"> moreMoney(‘Grete’, <span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>, <span class="number">400</span>, <span class="number">500</span>);</span><br></pre></td></tr></table></figure>

<h2 id="解構賦值"><a href="#解構賦值" class="headerlink" title="解構賦值"></a>解構賦值</h2><p>解構賦值語法可以將陣列或物件中的資料取出成獨立變數。<br>基本上就是把等號右邊的值，套用到等號左邊。</p>
<h3 id="陣列解構賦值"><a href="#陣列解構賦值" class="headerlink" title="陣列解構賦值"></a>陣列解構賦值</h3><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><p>在之前，我們如果要修改陣列內的元素，都只能用 <code>=</code> 一個一個直接賦值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> family = [<span class="string">'小明'</span>, <span class="string">'杰倫'</span>, <span class="string">'阿姨'</span>, <span class="string">'老媽'</span>, <span class="string">'老爸'</span>];</span><br><span class="line"><span class="keyword">let</span> ming = family[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">let</span> jay = family[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">let</span> auntie = family[<span class="number">2</span>];</span><br></pre></td></tr></table></figure>

<p>而現在可以用解構的方式，一次對陣列內所有元素賦值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> family = [<span class="string">'小明'</span>, <span class="string">'杰倫'</span>, <span class="string">'阿姨'</span>, <span class="string">'老媽'</span>, <span class="string">'老爸'</span>];</span><br><span class="line"><span class="keyword">let</span> [ming, jay, aunt, mom, dad] = family;</span><br><span class="line"><span class="comment">// 左邊是新變數，右邊是要賦予的值</span></span><br><span class="line"><span class="built_in">console</span>.log(ming, jay, aunt, mom, dad);</span><br><span class="line"><span class="comment">// "小明" "杰倫" "阿姨" "老媽" "老爸"</span></span><br></pre></td></tr></table></figure>

<h4 id="當輸入的變數少於所給的值"><a href="#當輸入的變數少於所給的值" class="headerlink" title="當輸入的變數少於所給的值"></a>當輸入的變數少於所給的值</h4><p>如果缺少的變數是陣列最後的值，那就會因為沒有被賦予變數而查不出來。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> family = [<span class="string">'小明'</span>, <span class="string">'杰倫'</span>, <span class="string">'阿姨'</span>, <span class="string">'老媽'</span>, <span class="string">'老爸'</span>];</span><br><span class="line"><span class="keyword">let</span> [ming, jay, aunt] = family;</span><br><span class="line"><span class="built_in">console</span>.log(ming, jay, aunt);</span><br><span class="line"><span class="comment">// "小明" "杰倫" "阿姨"</span></span><br></pre></td></tr></table></figure>

<p>如果缺少的變數是在陣列中間的話，缺少的變數要<strong>留空</strong>，此時其他變數依然可以按照對應的陣列元素賦值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> family = [<span class="string">'小明'</span>, <span class="string">'杰倫'</span>, <span class="string">'阿姨'</span>, <span class="string">'老媽'</span>, <span class="string">'老爸'</span>];</span><br><span class="line"><span class="keyword">let</span> [ming, jay, , mom, dad] = family;</span><br><span class="line"><span class="built_in">console</span>.log(ming, jay, mom, dad);</span><br><span class="line"><span class="comment">// "小明" "杰倫" "老媽" "老爸"</span></span><br></pre></td></tr></table></figure>

<h4 id="當輸入的變數多於所給的值"><a href="#當輸入的變數多於所給的值" class="headerlink" title="當輸入的變數多於所給的值"></a>當輸入的變數多於所給的值</h4><p>如果變數的數量多於賦予的值時，多出來的那個變數會被賦予 <code>undefined</code> 的值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> family = [<span class="string">'小明'</span>, <span class="string">'杰倫'</span>, <span class="string">'阿姨'</span>, <span class="string">'老媽'</span>, <span class="string">'老爸'</span>];</span><br><span class="line"><span class="keyword">let</span> [ming, jay, aunt, mom, dad, sis] = family;</span><br><span class="line"><span class="built_in">console</span>.log(ming, jay, aunt, mom, dad, sis);</span><br><span class="line"><span class="comment">// "小明" "杰倫" "阿姨" "老媽" "老爸" undefined</span></span><br></pre></td></tr></table></figure>

<h4 id="變數交換"><a href="#變數交換" class="headerlink" title="變數交換"></a>變數交換</h4><p>使用解構賦值可以即時交換兩個變數的值，不需要透過宣告第三個變數來達成。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fruit = <span class="string">'banana'</span>;</span><br><span class="line"><span class="keyword">let</span> veg = <span class="string">'tomato'</span>;</span><br><span class="line">[fruit, veg] = [veg, fruit]; <span class="comment">// 左邊是新的變數名，右邊是交換後的值</span></span><br><span class="line"><span class="built_in">console</span>.log(fruit, veg);</span><br><span class="line"><span class="comment">// "tomato" "banana"</span></span><br></pre></td></tr></table></figure>

<h4 id="把字串的字取出並個別宣告變數"><a href="#把字串的字取出並個別宣告變數" class="headerlink" title="把字串的字取出並個別宣告變數"></a>把字串的字取出並個別宣告變數</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">'吃飽沒'</span>;</span><br><span class="line"><span class="keyword">let</span> [a, b, c] = str;</span><br><span class="line"><span class="built_in">console</span>.log(a, b, c);</span><br><span class="line"><span class="comment">// "吃" "飽" "沒"</span></span><br></pre></td></tr></table></figure>

<h4 id="預設值"><a href="#預設值" class="headerlink" title="預設值"></a>預設值</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [g = <span class="string">'Grete'</span>, s = <span class="string">'Steffi'</span>] = [<span class="string">'葛蕾特'</span>];</span><br><span class="line"><span class="comment">// g 會被重新賦值，s 會用預設</span></span><br><span class="line"><span class="built_in">console</span>.log(g,s);</span><br><span class="line"><span class="comment">// "葛蕾特" "Steffi"</span></span><br></pre></td></tr></table></figure>

<h3 id="物件解構賦值"><a href="#物件解構賦值" class="headerlink" title="物件解構賦值"></a>物件解構賦值</h3><p>陣列的解構賦值強調的是<strong>順序</strong>，而物件的解構賦值強調的則是<strong>屬性名稱</strong>，屬性名稱必須相互對應才能夠取得到值。</p>
<p>在物件解構賦值中，冒號前是用來對應物件的屬性名稱，冒號後才是真正建立的變數名稱和被賦值的對象。</p>
<p>參照：<a href="https://pjchender.blogspot.com/2017/01/es6-object-destructuring.html" target="_blank" rel="external nofollow noopener noreferrer">[筆記] JavaScript ES6 中的物件解構賦值（object destructuring）</a></p>
<h4 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h4><p>從物件中取出一個特性的值，並賦予這個值一個新的變數名稱。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  name: <span class="string">'Grete'</span>,</span><br><span class="line">  age: <span class="number">25</span>,</span><br><span class="line">  city: <span class="string">'Taichung'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">city</span>: address&#125; = person;</span><br><span class="line"><span class="comment">// 冒號左邊是物件特性，冒號右邊是新賦予的變數名稱</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(address);</span><br><span class="line"><span class="comment">// "Taichung"</span></span><br></pre></td></tr></table></figure>

<p><code>person.city</code> 的值依然是 <code>&#39;Taichung&#39;</code>，而透過解構賦值另外宣告的變數 <code>address</code> 的值也是 <code>&#39;Taichung&#39;</code>。</p>
<h4 id="延伸問題"><a href="#延伸問題" class="headerlink" title="延伸問題"></a>延伸問題</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; <span class="attr">name</span>: germanName, <span class="attr">fruits</span>: [, apple] &#125; = &#123; <span class="attr">name</span>: <span class="string">'Grete'</span>, <span class="attr">fruits</span>: [<span class="string">'香蕉'</span>, <span class="string">'蘋果'</span>, <span class="string">'芭樂'</span>] &#125;</span><br><span class="line"><span class="comment">// 右邊的屬性對應左邊的屬性，右邊的值對應左邊的新變數名稱</span></span><br><span class="line"><span class="built_in">console</span>.log(germanName, apple);</span><br><span class="line"><span class="comment">// "Grete" "蘋果"</span></span><br></pre></td></tr></table></figure>

<p>左邊 <code>fruits</code> 特性要解構賦值的對象是右邊 <code>fruits</code> 的第二個值，所以在 <code>apple</code> 前面用逗點空了一個位置。</p>
<h4 id="預設值-1"><a href="#預設值-1" class="headerlink" title="預設值"></a>預設值</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; <span class="attr">fruits</span>: apple = <span class="string">'蘋果'</span> &#125; = &#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(apple); <span class="comment">// "蘋果"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">fruits</span>: apple = <span class="string">'蘋果'</span> &#125; = &#123;<span class="attr">fruits</span>: <span class="string">'鳳梨'</span>&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(apple); <span class="comment">// "鳳梨"</span></span><br></pre></td></tr></table></figure>

<p>第一個範例中，左邊預設 <code>apple</code> 等於 ‘蘋果’，因為右邊沒有傳新的值，所以會保持 <code>apple</code> 為蘋果。<br>第二個範例中，右邊傳了新的值，所以 <code>apple</code> 的值就變成鳳梨了。</p>
<h2 id="縮寫"><a href="#縮寫" class="headerlink" title="縮寫"></a>縮寫</h2><h3 id="物件縮寫"><a href="#物件縮寫" class="headerlink" title="物件縮寫"></a>物件縮寫</h3><p>將一個字串與一個物件，在另一個新物件裡合併。<br>新物件裡的特性名稱如果跟來源變數一致時，就可以使用縮寫。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Frieza = <span class="string">'弗利沙'</span></span><br><span class="line"><span class="keyword">const</span> GinyuTeam = &#123;</span><br><span class="line">  Ginyu: <span class="string">'基紐'</span>,</span><br><span class="line">  Jeice: <span class="string">'吉斯'</span>,</span><br><span class="line">  burter: <span class="string">'巴特'</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> newTeam = &#123;</span><br><span class="line">  GinyuTeam,  <span class="comment">// 原始寫法為 GinyuTeam: GinyuTeam</span></span><br><span class="line">  Frieza  <span class="comment">// 原始寫法為 Frieza: Frieza</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Vue CLI 裡也會時常應用縮寫，例如以下的情境：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App'</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">'./router'</span></span><br><span class="line"><span class="comment">// 將套件從 './App' 路徑載入，並使用 App 這個變數名</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  router, <span class="comment">// 原始寫法為 router: router</span></span><br><span class="line">  template: <span class="string">'&lt;App/&gt;'</span>,</span><br><span class="line">  components: &#123; App &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="物件方法縮寫"><a href="#物件方法縮寫" class="headerlink" title="物件方法縮寫"></a>物件方法縮寫</h3><h4 id="原始寫法："><a href="#原始寫法：" class="headerlink" title="原始寫法："></a>原始寫法：</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> newTeam = &#123;</span><br><span class="line">  showPosture: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'我們是 基紐特戰隊'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="縮寫："><a href="#縮寫：" class="headerlink" title="縮寫："></a>縮寫：</h4><p>把 <code>:</code> 跟 <code>function</code> 去掉。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> newTeam = &#123;</span><br><span class="line">  showPosture () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'我們是 基紐特戰隊'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：物件方法縮寫與箭頭函式的結果是不一致的。</p>
<h3 id="縮寫搭配展開與解構賦值"><a href="#縮寫搭配展開與解構賦值" class="headerlink" title="縮寫搭配展開與解構賦值"></a>縮寫搭配展開與解構賦值</h3><p>任務：將一個物件賦值到新的變數，並新增一個特性到新物件中，而且不能更改到原物件（=避免參考）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> GinyuTeam = &#123;</span><br><span class="line">   Ginyu: &#123;</span><br><span class="line">     name: <span class="string">'基紐'</span></span><br><span class="line">   &#125;,</span><br><span class="line">   Jeice: &#123;</span><br><span class="line">     name: <span class="string">'吉斯'</span></span><br><span class="line">   &#125;,</span><br><span class="line">   burter: &#123; </span><br><span class="line">     name: <span class="string">'巴特'</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> newTeam = &#123;...GinyuTeam&#125;;</span><br><span class="line"><span class="comment">// 將原物件的特性一個個取出（展開），並賦值到新的變數</span></span><br><span class="line"></span><br><span class="line">newTeam.ming = <span class="string">"小明"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(newTeam, GinyuTeam);</span><br><span class="line"><span class="comment">// newTeam 有小明，GinyuTeam 維持原樣</span></span><br></pre></td></tr></table></figure>

<h2 id="箭頭函式"><a href="#箭頭函式" class="headerlink" title="箭頭函式"></a>箭頭函式</h2><h3 id="基本寫法"><a href="#基本寫法" class="headerlink" title="基本寫法"></a>基本寫法</h3><p>傳統函式長這樣：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> callSomeone = <span class="function"><span class="keyword">function</span> (<span class="params">someone</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> someone + <span class="string">'吃飯了'</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(callSomeone(<span class="string">'小明'</span>));</span><br></pre></td></tr></table></figure>

<p>改寫成箭頭函式長這樣：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> callSomeone = <span class="function"><span class="params">someone</span> =&gt;</span> someone + <span class="string">'吃飯了'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(callSomeone(<span class="string">'小明'</span>));</span><br></pre></td></tr></table></figure>

<h3 id="如何改寫"><a href="#如何改寫" class="headerlink" title="如何改寫"></a>如何改寫</h3><p>把參數往前提，把關鍵字 <code>function</code> 刪掉，改成箭頭。<br>只有一個參數時可以不用小括號包起來，如果沒帶入參數就還是需要小括號。<br>如果只有單行程式碼而且只是要回傳一個值的情況下，可以省略大括號及 <code>return</code>。<br>箭頭函式沒有 <code>arguments</code> 物件，所以如果要傳入多個參數值時，可以在箭頭函式的小括號內使用其餘參數。</p>
<h3 id="與傳統函式最不同的地方：this-綁定差異"><a href="#與傳統函式最不同的地方：this-綁定差異" class="headerlink" title="與傳統函式最不同的地方：this 綁定差異"></a>與傳統函式最不同的地方：this 綁定差異</h3><ul>
<li>傳統函式：<code>this</code> 取決於函式呼叫的方式</li>
<li>箭頭函式：<code>this</code> 取決於被定義時所在的物件，「箭頭函式沒有自己的 <code>this</code>」，因此它都是採用其同層級的 <code>this</code> 來作用。</li>
</ul>
<p>寫 Vue <code>methods</code> 時最好使用<strong>傳統函式搭配縮寫</strong>，因為使用箭頭函式的話，<code>this</code> 指向的可能不是 Vue 實例。</p>
<p>參照：<a href="https://pjchender.blogspot.com/2017/01/es6-arrow-function.html" target="_blank" rel="external nofollow noopener noreferrer">[筆記] JavaScript ES6 中的箭頭函數（arrow function）及對 this 的影響</a></p>
<h3 id="善用方式"><a href="#善用方式" class="headerlink" title="善用方式"></a>善用方式</h3><p>在進入箭頭函式之前，先把要指向的物件（<code>this</code>）用變數儲存起來。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> antie = &#123;</span><br><span class="line">  name: <span class="string">'漂亮阿姨'</span>,</span><br><span class="line">  callname() &#123;</span><br><span class="line">    <span class="keyword">var</span> vm = <span class="keyword">this</span>;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(vm, vm.name);</span><br><span class="line">    &#125;, <span class="number">10</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="字串模板"><a href="#字串模板" class="headerlink" title="字串模板"></a>字串模板</h2><p>各位在用 <code>innerHTML</code> 組字串時會不會感到很痛苦呢？我承認我會，因為各種標籤名、文字、加號、單雙引號，全部亂糟糟地都寫在一起，真 D 會讓人眼花啊！</p>
<p>還好，在ES6有新的寫法，可以讓我們好過一點。</p>
<h3 id="基本用法-2"><a href="#基本用法-2" class="headerlink" title="基本用法"></a>基本用法</h3><p>假設我們要在一個 <code>&lt;ul&gt;&lt;li&gt;</code> 裡放入圖片：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HTML</span></span><br><span class="line">&lt;ul <span class="class"><span class="keyword">class</span></span>=<span class="string">"list"</span>&gt;</span><br><span class="line">  &lt;li&gt;</span><br><span class="line">    &lt;img src=<span class="string">"logo.png"</span>&gt;</span><br><span class="line">  &lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">&lt;/u</span>l&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// JS</span></span><br><span class="line"><span class="comment">// 用 const 選取 DOM</span></span><br><span class="line"><span class="keyword">const</span> list = <span class="built_in">document</span>.querySelector(<span class="string">'.list'</span>)</span><br><span class="line"><span class="comment">// 用 const 儲存要放入的圖片路徑</span></span><br><span class="line"><span class="keyword">const</span> imgURL = <span class="string">'logo.png'</span>;</span><br></pre></td></tr></table></figure>

<p>接下來要進行渲染至網頁，傳統寫法是這樣：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">list.innerHTML = <span class="string">'&lt;li&gt;&lt;img src='</span>+ imgURL +<span class="string">'&gt;&lt;/li&gt;'</span></span><br></pre></td></tr></table></figure>

<p>現在比較好的寫法是：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">list.innetHTML = <span class="string">`&lt;li&gt;&lt;img src=" <span class="subst">$&#123;imgURL&#125;</span> "&gt;&lt;/li&gt;`</span></span><br></pre></td></tr></table></figure>

<p>新寫法中這個長得像重音符號的東西叫做「反引號」，<code>${}</code> 裡面可放入 JS 程式碼跟變數，支援 ES6 寫法。</p>
<p>組字串不需要使用加號，而選取變數的方法則是把變數名稱包在大括號內，前面再加個 <code>$</code> 符號，這樣就可以了。</p>
<h3 id="搭配陣列方法使用"><a href="#搭配陣列方法使用" class="headerlink" title="搭配陣列方法使用"></a>搭配陣列方法使用</h3><p>假設我們要根據一個陣列裡的資料，一筆筆輸出為 <code>&lt;ul&gt; &lt;li&gt;</code> 列表：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 陣列</span></span><br><span class="line"><span class="keyword">const</span> people = [</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">'小明'</span>,</span><br><span class="line">    friends: <span class="number">2</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">'阿姨'</span>,</span><br><span class="line">    friends: <span class="number">999</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">'杰倫'</span>,</span><br><span class="line">    friends: <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> newUl = <span class="string">`</span></span><br><span class="line"><span class="string">  &lt;ul&gt; <span class="subst">$&#123;people.map(person =&gt;</span></span></span><br><span class="line"><span class="string"><span class="subst">    <span class="string">`&lt;li&gt;我叫做 <span class="subst">$&#123;person.name&#125;</span>&lt;/li&gt;`</span>)</span></span></span><br><span class="line"><span class="string"><span class="subst">    .join(<span class="string">''</span>)&#125;</span></span></span><br><span class="line"><span class="string">  &lt;/ul&gt;`</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>map()</code> 會把陣列裡所有元素傳進 callback 函式內運算，並且把運算後的元素以陣列的形式回傳。</li>
<li><code>join()</code> 會把陣列裡所有元素以指定的字符連接在一起，這個例子是讓元素間不要有任何字符、逗號。</li>
</ul>
<h2 id="常用陣列方法"><a href="#常用陣列方法" class="headerlink" title="常用陣列方法"></a>常用陣列方法</h2><h3 id="forEach-與-map"><a href="#forEach-與-map" class="headerlink" title="forEach() 與 map()"></a><code>forEach()</code> 與 <code>map()</code></h3><p>兩者很像，但 <code>forEach()</code> 不會回傳值，而 <code>map()</code> 會回傳一個新的陣列。<br><code>map()</code> 的 callback 函式裡需要使用 <code>return</code> 來回傳運算後的結果，且也需要一個變數來接收 <code>map()</code> 執行後的新陣列。</p>
<h3 id="filter"><a href="#filter" class="headerlink" title="filter()"></a><code>filter()</code></h3><p><code>filter()</code> 與 <code>find()</code>：<code>filter()</code> 回傳的是一個新陣列且裡面包含所有符合條件的元素，而 <code>find()</code> 只會回傳第一個符合條件的元素值。因此，<code>find()</code> 較適合用於搜尋一個特定的值。</p>
<h3 id="every"><a href="#every" class="headerlink" title="every()"></a><code>every()</code></h3><p><strong>所有</strong>元素都符合條件才會回傳 <code>true</code>。</p>
<h3 id="some"><a href="#some" class="headerlink" title="some()"></a><code>some()</code></h3><p><strong>部分</strong>元素有符合條件就會回傳 <code>true</code>。</p>
<h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce()"></a><code>reduce()</code></h3><p>用於累加或比較值的大小。</p>
<h4 id="累加"><a href="#累加" class="headerlink" title="累加"></a>累加</h4><p><code>reduce()</code> 第一個參數是一個 callback 函式，第二個參數是累加的起始值。</p>
<p>callback 函式的參數中，第一個參數為「前一個元素的值」，如果沒有前一個元素，就使用 <code>reduce()</code> 的第二個參數。</p>
<h4 id="比較值的大小"><a href="#比較值的大小" class="headerlink" title="比較值的大小"></a>比較值的大小</h4><p>配合使用 <code>Math.max()</code>。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>w3HexSchool</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>講座筆記：人生策略與學習方法論</title>
    <url>/%E8%81%B7%E6%B6%AF%E8%88%87%E5%AD%B8%E7%BF%92/20200427/1054851528/</url>
    <content><![CDATA[<p>這篇筆記來自於 2020.03.26 六角學院的線上研討會，講者為慕課前學習長——康晉暚（阿康）老師，講者在這一節講座中分享了他自己的職涯體悟，並分寫了一套學習新知識 / 新技能的方法論。</p>
<a id="more"></a>

<h2 id="關於人生策略"><a href="#關於人生策略" class="headerlink" title="關於人生策略"></a>關於人生策略</h2><h3 id="到目前為止的人生復盤"><a href="#到目前為止的人生復盤" class="headerlink" title="到目前為止的人生復盤"></a>到目前為止的人生復盤</h3><ul>
<li><p>熱情有可能是危險的。追求熱情也有可能失敗，因為那個熱情要實行可能會遇到困難。例如因為喜歡咖啡，結果花了六百萬開咖啡店最後倒閉，才發現自己是喜歡喝咖啡，而不是喜歡泡咖啡。</p>
</li>
<li><p>做某件事做著做著遇到困難時想辦法去解決，最後得到一個有形或無形的結果，對此感到開心、有成就感，這才叫做熱情。</p>
</li>
<li><p>人生方向是「發展」出來的，不是「發現」，所以要多嘗試，不過探索也是需要方法的，後面會提到。</p>
</li>
<li><p>斯多葛學派：不要試圖去煩惱你無法控制的人事物。<br>=&gt; 去做你自己能做的事，但不要去煩惱</p>
</li>
<li><p>《意義的呼喚：意義治療大師法蘭可自傳》：永遠都有選擇，它是沒有任何人可以剝奪的權力。<br>=&gt; 可以選擇「如何面對」所發生的事</p>
</li>
</ul>
<h3 id="名詞解釋"><a href="#名詞解釋" class="headerlink" title="名詞解釋"></a>名詞解釋</h3><ul>
<li>斜槓：先踩穩一隻腳，才能踩另一隻腳，而不是同時都做。</li>
<li>焦慮：對不確定性的反應。應該要去擁抱這種不確定性，因為這是你無法掌控的。</li>
<li>機運：有時候機運長得不像機運，很難說。</li>
<li>時間：有時候太快做決定也不是個好事。有時候好像別人都在前進只有自己停滯，這種感覺像是大家都上了車，只有你沒擠上去。不要擔心，你永遠都搭得上車。</li>
<li>風險：是否平時就有準備應急方案或備案？</li>
</ul>
<h3 id="人生設計的核心觀點"><a href="#人生設計的核心觀點" class="headerlink" title="人生設計的核心觀點"></a>人生設計的核心觀點</h3><h4 id="用原型-prototype-MVP-的方法，來探索方向"><a href="#用原型-prototype-MVP-的方法，來探索方向" class="headerlink" title="用原型 (prototype) / MVP 的方法，來探索方向"></a>用原型 (prototype) / MVP 的方法，來探索方向</h4><p>用最小可行性的方式，先做一些小賭注。例如，在自己開咖啡店前，先去咖啡店打工，並且去詢問店裡老闆如何開店。</p>
<p>也可以用訪談的方式，先去認識已經在業界裡的人，請教他業界的工作內容，並問他：「如果你是我，現在先做哪些事？」。</p>
<h4 id="霍夫曼-ABZ-方案"><a href="#霍夫曼-ABZ-方案" class="headerlink" title="霍夫曼 ABZ 方案"></a>霍夫曼 ABZ 方案</h4><p>A：本職學能<br>B：本職的替代方案<br>Z：假設忽略所有前提，你是否會想去做某職業？</p>
<h4 id="挑選創業夥伴"><a href="#挑選創業夥伴" class="headerlink" title="挑選創業夥伴"></a>挑選創業夥伴</h4><p>如果自己適合當輔佐的角色，挑比自己聰明的人當創業夥伴。</p>
<h4 id="寫「辦到了」日記"><a href="#寫「辦到了」日記" class="headerlink" title="寫「辦到了」日記"></a>寫「辦到了」日記</h4><ul>
<li>步驟一：每天記錄一到三件當天「完成的事」（提升自我肯定感）</li>
<li>步驟二：一週一次，花十分鐘撰寫「內省文」（發現不曾留意的事）</li>
<li>步驟三：將目前想到能做的改變付諸實行</li>
</ul>
<p>我們太少「成功」了，所以就自己肯定自己吧！尤其當我們處在困頓時，更應該多多肯定自己。</p>
<h4 id="做長期有價值的事"><a href="#做長期有價值的事" class="headerlink" title="做長期有價值的事"></a>做長期有價值的事</h4><p>用「長期 / 短期」、「價值高 / 價值低」這兩個向度來畫表格，把自己生活中的事情歸類進這個表格裡。</p>
<h2 id="找到人生目標的四種方法"><a href="#找到人生目標的四種方法" class="headerlink" title="找到人生目標的四種方法"></a>找到人生目標的四種方法</h2><h3 id="高效能塔"><a href="#高效能塔" class="headerlink" title="高效能塔"></a>高效能塔</h3><p>由「目標」、「方法論」、「投入」組成一個金字塔。設立目標是最重要、最上層的層次，需要第一優先確認好；底層投入的「態度/熱情」靠選擇和環境來解決；中間的「方法論」相對容易解決。</p>
<h3 id="人生目標不是「發現」，而是「發展」出來的"><a href="#人生目標不是「發現」，而是「發展」出來的" class="headerlink" title="人生目標不是「發現」，而是「發展」出來的"></a>人生目標不是「發現」，而是「發展」出來的</h3><ol>
<li>不斷問自己為什麼？找到最根本的動力：<strong>5Why分析法</strong></li>
<li>列清單，排序選擇：<strong>富蘭克林決策法</strong>（想清楚的過程比最後的結果重要）</li>
<li>假設無條件獲得的極端情況：<strong>「奧德賽計劃」</strong>，三種版本的人生。</li>
<li>不斷通過試錯，了解自已的選擇。</li>
</ol>
<h2 id="「人網事書」學習方法論"><a href="#「人網事書」學習方法論" class="headerlink" title="「人網事書」學習方法論"></a>「人網事書」學習方法論</h2><p>複雜問題無法「單一解」，而是要「多重解」，你要懂的不是一門某某專業，而是一套組合技，包含了「心・技・體」。</p>
<ul>
<li>人：跟高手（前輩）學、高手（前輩）有<strong>隱性知識</strong>、從高手（前輩）那邊獲取<strong>重要關鍵字</strong></li>
<li>網：關鍵字、搜尋技巧</li>
<li>事：「專案」學習法（實作）、運營思維</li>
<li>書：閱讀技巧、大量 / 多次 / 循環（雪球閱讀法）、背景知識</li>
</ul>
<h2 id="職場必修的四大技能"><a href="#職場必修的四大技能" class="headerlink" title="職場必修的四大技能"></a>職場必修的四大技能</h2><ul>
<li>時間：管理你的注意力、精力</li>
<li>人脈：讓自己先有價值（如專業）、打造社交貨幣（也就是自己的價值）、個人品牌</li>
<li>知識：專業技能、工具與底層知識 (學習方法論)</li>
<li>內容：持續輸出對人有價值的內容 (寫作、教學、演講…)</li>
</ul>
<h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q &amp; A"></a>Q &amp; A</h2><ul>
<li>追技術與懂產品：程式只是工具，是為了解決問題，所以最終還是要懂得客戶需求以及技術是為了解決什麼問題。</li>
<li>時間管理：不是在有限時間做更多事情，而是選擇什麼事情<strong>不要做</strong>，因為時間本來就是有限的。</li>
<li>轉職為工程師後悔了怎麼辦：走回頭路呢？或是思考「原來的經驗」+「成為工程師學到的經驗」可以成為什麼？或是也許可以當 PM 或 UI Engineer。</li>
<li>知識焦慮：這個感覺是來自「未知」，來自感覺自己「跟不上」。可以調整心態面對不確定性，然後做出實際的計畫來學習而不是只在那邊窮擔憂，行動才能化解焦慮。</li>
</ul>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><a href="https://docs.google.com/presentation/d/1AmLyPRUJJGegoFY_Ay3XrwZSZ7y15HL6WqmRZUOd504/edit#slide=id.p" target="_blank" rel="external nofollow noopener noreferrer">講座簡報</a></p>
<hr>
<p>今天是轉職後第一天上班，雖然沒什麼實質的產出，但還是莫名覺得累 XD<br>還差點忘記今天又到了要發文的日子了，還好還有存稿可以用，哇哈哈。</p>
]]></content>
      <categories>
        <category>職涯與學習</category>
      </categories>
      <tags>
        <tag>w3HexSchool</tag>
      </tags>
  </entry>
  <entry>
    <title>[Vue] Vuex 資料狀態管理學習筆記之模組化資料運用</title>
    <url>/Vuejs/20200420/127038282/</url>
    <content><![CDATA[<p>這系列到目前為止，其實已經把 Vuex 基本的使用方式介紹得差不多了。<br>而本篇則是會介紹一些比之前進階一點的寫法，也就是將 Vuex 中管理的資料模組化，並以與之前不同的形式在元件中讀取資料。</p>
<a id="more"></a>

<h2 id="Vuex-中的-getters-mapGetters-mapActions"><a href="#Vuex-中的-getters-mapGetters-mapActions" class="headerlink" title="Vuex 中的 getters, mapGetters, mapActions"></a>Vuex 中的 getters, mapGetters, mapActions</h2><p>這一段要介紹的是：在元件中提取 Vuex 函式的新方法。</p>
<ol>
<li>在 store 中加上 <code>getters</code> 物件，把在元件中要用 <code>computed</code> 呈現在畫面上的資料移進來。移進來的形式是 function 形式，且帶入跟 <code>mutations</code> 一樣的參數（<code>state</code>）。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">getters: &#123;</span><br><span class="line">  categories(state) &#123;</span><br><span class="line">    <span class="keyword">return</span> state.categories;</span><br><span class="line">  &#125;,</span><br><span class="line">  products(state) &#123;</span><br><span class="line">    <span class="keyword">return</span> state.products;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>到要呈現畫面的元件中（Home.app），引入 Vuex 中的 <code>mapGetters</code>，注意，要用物件包住要引入項目。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapGetters &#125; <span class="keyword">from</span> <span class="string">'vuex'</span>;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>移除原本 <code>computed</code> 中定義的資料函式，改用<strong>展開符號</strong>把 <code>mapGetters</code> 的內容取出來，並指定要取出裡面的哪些 gettets。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">  ...mapGetters([<span class="string">'categories'</span>, <span class="string">'products'</span>]),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>除了 <code>mutations</code> 可以改成 <code>getters</code>，<code>actions</code> 也能用這種方法，從 store 取出來用在元件上。首先在引入的地方，多增加 <code>mapActions</code> 的引入。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapGetters, mapActions &#125; <span class="keyword">from</span> <span class="string">'vuex'</span>;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><code>mapActions</code> 可以用來替換元件中<strong>不需要帶入參數</strong>的 <code>methods</code> 函式，例如以下這樣：</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原本是這樣</span></span><br><span class="line">getProducts() &#123;</span><br><span class="line">  <span class="keyword">this</span>.$store.dispatch(<span class="string">'getProducts'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用 mapActions 帶入</span></span><br><span class="line">...mapActions([<span class="string">'getProducts'</span>]),</span><br></pre></td></tr></table></figure>

<h3 id="補充說明：mapActions-的使用時機"><a href="#補充說明：mapActions-的使用時機" class="headerlink" title="補充說明：mapActions 的使用時機"></a>補充說明：mapActions 的使用時機</h3><p><code>mapActions</code> 的使用時機，最簡單的辨別方式就是「需不需要帶入參數」，若需要就不能使用 <code>mapActions</code>。</p>
<h2 id="模組化資料運用"><a href="#模組化資料運用" class="headerlink" title="模組化資料運用"></a>模組化資料運用</h2><p>場景從元件切回到 store。</p>
<p>接下來我們要把 store 中的程式碼再做拆分（模組化），例如，將行為及資料分為兩大類：「取得產品」類及「取得購物車、新增刪除品項」類。</p>
<p>以下以「取得產品」類為例，示範如何將資料模組化。</p>
<ol>
<li><p>在 store 資料夾新增 products.js</p>
</li>
<li><p>在裡面寫好 <code>export default {}</code> 後就可以複製 store 中的程式碼，移到這個物件裡。但因為這個檔案只放與產品相關的行為，所以跟購物車、讀取效果有關的程式碼就先移除。</p>
</li>
<li><p>把 axios import 進來</p>
</li>
<li><p>回到 store/index.js，把已經拆出去的程式碼刪掉，然後引入 products.js，並且幫 products.js 取一個模組名稱叫做 <code>productsModules</code>。</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> productsModules <span class="keyword">from</span> <span class="string">'./products'</span>;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>一樣是在 index.js 中，在 <code>getter</code> 物件下方新增 <code>modules</code> 物件，在裡面直接貼入 <code>modules</code> 名稱。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">modules: &#123;</span><br><span class="line">  productsModules,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="模組重要概念"><a href="#模組重要概念" class="headerlink" title="模組重要概念"></a>模組重要概念</h3><p>在 products.js 中，<code>state</code> 是模組內的<strong>區域變數</strong>，除此以外 <code>actions</code>、<code>mutations</code>、<code>getters</code> 等都是<strong>全域變數</strong>。</p>
<p>所以如果 store 中有其他模組使用與 products.js 相同名稱的 <code>actions</code>、<code>mutations</code>、<code>getters</code>，就會出現錯誤。</p>
<p>如果在元件中想要讀取模組的 <code>state</code> 變數，要這樣寫：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.$store.state.productsModules.products);</span><br><span class="line"><span class="comment">// state 後面還要多一層 productsModules 才讀得到模組內的資料</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果希望 <code>actions</code>、<code>mutations</code>、<code>getters</code> 都變成模組內的區域變數，該怎麼做？</p>
</blockquote>
<p>只要在 <code>state</code> 上一行加上 <code>namespaced: true</code>，它們就都會變成區域變數了，但此時元件就沒辦法直接讀到這些行為。</p>
<p>解決方法是，當使用 <code>mapGetters()</code> 時，也把模組名稱帶進來：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">...mapGetters(<span class="string">'productsModules'</span>, [<span class="string">'categories'</span>, <span class="string">'products'</span>]);</span><br></pre></td></tr></table></figure>

<p>不過，當元件內同時要讀取模組資料及全域資料時，就要標示出哪些是全域資料，標示的方法是在 <code>commit()</code> 中帶入 <code>{ root: true }</code> 當參數：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// LOADING 是定義在 index.js 中的全域變數</span></span><br><span class="line">context.commit(<span class="string">'LOADING'</span>, <span class="literal">true</span>, &#123; <span class="attr">root</span>: <span class="literal">true</span> &#125;);</span><br></pre></td></tr></table></figure>

<hr>
<p>Vuex 筆記到此差不多告一個段落了～</p>
<p>這些筆記都是我在上六角學院的 Vue.js 課程中寫下的筆記，不過我可能還是有寫得不夠仔細的地方，<br>所以附上兩個我覺得整理得很不錯的文章給各位一起參考：</p>
<ul>
<li><a href="https://blog.hinablue.me/2019-ithome-ironman-day-8/" target="_blank" rel="external nofollow noopener noreferrer">[IT 鐵人賽] Vuex 基本入門Day 8 - HINA::工程幼稚園</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/100941659" target="_blank" rel="external nofollow noopener noreferrer">vuex：弄懂mapState、mapGetters、mapMutations、mapActions</a></li>
</ul>
]]></content>
      <categories>
        <category>Vuejs</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>w3HexSchool</tag>
        <tag>Vuex</tag>
      </tags>
  </entry>
  <entry>
    <title>[Vue] Vuex 資料狀態管理學習筆記之功能實作篇</title>
    <url>/Vuejs/20200406/1863907667/</url>
    <content><![CDATA[<p>學習六角學院「Vue 出一個電商網站」課程時，課程後半段是跟著老師的示範，實作出電商網站的完整功能。</p>
<p>這篇筆記便是紀錄了當時實作的部分功能：Navbar 中的購物車列表、商品頁側欄的商品分類。</p>
<a id="more"></a>

<h2 id="製作-Navbar-上的購物車"><a href="#製作-Navbar-上的購物車" class="headerlink" title="製作 Navbar 上的購物車"></a>製作 Navbar 上的購物車</h2><ol>
<li><p>步驟類似<a href="https://gretema.github.io/Vuejs/20200330/3884529085/#more">上一篇最後一段「使用 Actions 取得遠端資料」</a>。首先將「取得購物車資料」(<code>getCart()</code>) 及「刪除購物車品項」(<code>removeCart()</code>) 的 AJAX 寫到 store 中的 <code>actions</code> 中，購物車資料結構也從元件 <code>data</code> 搬到 store 中的 <code>state</code>。</p>
</li>
<li><p>整理程式碼，例如把 AJAX 的 <code>http</code> 方法改成 <code>axios</code>，帶入 <code>context</code> 參數，以及刪除購物車品項後重新取得購物車清單的程式碼，要改成以下這段：</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">context.dispatch(<span class="string">'getCart'</span>);</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>回到 App.vue，原本的 <code>methods</code> 程式碼改成呼叫 store 中的 <code>actions</code>，且 <code>computed</code> 也要呼叫 <code>state</code> 中的資料。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">getCart() &#123;</span><br><span class="line">  <span class="keyword">this</span>.$store.dispatch(<span class="string">'getCart'</span>, );</span><br><span class="line">&#125;,</span><br><span class="line">removeCart(id) &#123;</span><br><span class="line">  <span class="keyword">this</span>.$store.dispatch(<span class="string">'removeCart'</span>, id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  ...</span><br><span class="line">  cart() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.$store.state.cart;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p>把「加入購物車」的功能加進來。到 Home.vue，複製 <code>addtoCart()</code> 的程式碼，貼到 <code>actions</code> 中。一樣要整理程式碼，用 <code>dispatch()</code> 呼叫 <code>getCart()</code>。</p>
</li>
<li><p><code>addtoCart()</code> 因為會從 Home.vue 傳遞兩個參數到 <code>actions</code> 的關係，所以就帶出一個問題：<code>actions</code> 中的函式一次只能從外部接收一個參數。解決方式就是在 Home.vue 的 <code>addtoCart()</code> 中用<strong>物件</strong>把兩個參數包起來，而 <code>actions</code> 中的 <code>addtoCart()</code> 傳入的參數也用<strong>物件</strong>包起來。</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Home.vue</span></span><br><span class="line">addtoCart(id, qty = <span class="number">1</span>) &#123;</span><br><span class="line">  <span class="keyword">this</span>.$store.dispatch(<span class="string">'addtoCart'</span>, &#123;id, qty&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// store 的 actions</span></span><br><span class="line">addtoCart(context, &#123;id, qty&#125;) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="製作側欄商品分類的功能"><a href="#製作側欄商品分類的功能" class="headerlink" title="製作側欄商品分類的功能"></a>製作側欄商品分類的功能</h2><h3 id="前置作業"><a href="#前置作業" class="headerlink" title="前置作業"></a>前置作業</h3><ol>
<li>已經在 store 處理好商品分類有哪些。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// mutations</span></span><br><span class="line">CATEGORIES(state, payload) &#123;</span><br><span class="line">  <span class="keyword">const</span> categories = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">  payload.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    categories.add(item.category);</span><br><span class="line">  &#125;);</span><br><span class="line">  state.categories = <span class="built_in">Array</span>.from(categories);</span><br><span class="line">  <span class="comment">// 寫入 state 裡</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>在元件中，已經用 <code>computed</code> 從 store 取回商品資料與分類資料。</p>
</li>
<li><p>元件模板中有搜尋欄，並綁定 <code>v-model</code> 以取得搜尋欄中的文字。</p>
</li>
</ol>
<h3 id="側欄分類連結"><a href="#側欄分類連結" class="headerlink" title="側欄分類連結"></a>側欄分類連結</h3><ol>
<li>商品分類用 <code>v-for</code> 從取回來的商品資料疊代。</li>
<li>點擊該分類時，搜尋欄文字要等於這個分類。</li>
<li>當搜尋欄文字等於這個分類時，class 為啟用狀態。</li>
<li>按下「全部顯示」這個分類時，搜尋文字清空，且當搜尋文字為空時，class 為啟用狀態。</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"list-group sticky-top"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"list-group-item list-group-item-action"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">href</span>=<span class="string">"#"</span></span></span><br><span class="line"><span class="tag">     @<span class="attr">click.prevent</span>=<span class="string">"searchText = item"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">:class</span>=<span class="string">"&#123; active: item === searchText &#125;"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">v-for</span>=<span class="string">"item in categories"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">:key</span>=<span class="string">"item"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-street-view"</span> <span class="attr">aria-hidden</span>=<span class="string">"true"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">      &#123;&#123; item &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span> <span class="attr">class</span>=<span class="string">"list-group-item list-group-item-action"</span></span></span><br><span class="line"><span class="tag">     @<span class="attr">click.prevent</span>=<span class="string">"searchText = ''"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">:class</span>=<span class="string">"&#123; active: searchText === '' &#125;"</span>&gt;</span></span><br><span class="line">    全部顯示</span><br><span class="line">  <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="商品過濾的邏輯"><a href="#商品過濾的邏輯" class="headerlink" title="商品過濾的邏輯"></a>商品過濾的邏輯</h3><p>在 computed 中新增 <code>filterData()</code>，在這裏比對商品資料的「分類」與 <code>data</code> 定義的「搜尋欄文字」是否符合，並 <code>return</code> 符合搜尋欄文字的商品。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">filterData() &#123;</span><br><span class="line">  <span class="keyword">const</span> vm = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">if</span> (vm.searchText) &#123;</span><br><span class="line">    <span class="comment">// vm.products 指元件中從 store 取得資料的 computed</span></span><br><span class="line">    <span class="keyword">return</span> vm.products.filter(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> data = item.category</span><br><span class="line">            .toLowerCase()</span><br><span class="line">            .includes(vm.searchText.toLowerCase());</span><br><span class="line">      <span class="keyword">return</span> data; <span class="comment">// data 為過濾條件</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.products;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h3 id="子畫面呈現過濾後的商品列表"><a href="#子畫面呈現過濾後的商品列表" class="headerlink" title="子畫面呈現過濾後的商品列表"></a>子畫面呈現過濾後的商品列表</h3><p>商品卡片最外層用 <code>.col-md-4</code> 包住，並且在這一層用 <code>v-for</code> 從 <code>computed</code> <code>filterData()</code> 中疊代出過濾後的每一項商品。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span></span></span><br><span class="line"><span class="tag">  <span class="attr">class</span>=<span class="string">"col-md-4 mb-4"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-for</span>=<span class="string">"item in filterData"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:key</span>=<span class="string">"item.id"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"card border-0 box-shadow text-center h-100"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">"card-img-top"</span> <span class="attr">:src</span>=<span class="string">"item.image"</span> <span class="attr">alt</span>=<span class="string">"Card image cap"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"card-body"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h4</span> <span class="attr">class</span>=<span class="string">"card-title"</span>&gt;</span>&#123;&#123; item.title &#125;&#125;<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"card-text text-left"</span>&gt;</span>&#123;&#123; item.content &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"card-footer border-top-0 bg-white"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"btn btn-outline-secondary btn-block btn-sm"</span></span></span><br><span class="line"><span class="tag">       @<span class="attr">click</span>=<span class="string">"addtoCart(item.id)"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-cart-plus"</span> <span class="attr">aria-hidden</span>=<span class="string">"true"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">        加到購物車</span><br><span class="line">      <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Vuejs</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>w3HexSchool</tag>
        <tag>Vuex</tag>
      </tags>
  </entry>
  <entry>
    <title>[Vue] Vuex 資料狀態管理學習筆記之實作起手式</title>
    <url>/Vuejs/20200330/3884529085/</url>
    <content><![CDATA[<p>上週的 Vuex 筆記中介紹完了基本概念，這週的筆記就著重在實作上囉！<br>不過由於實作的部分篇幅過長，所以會分成比較多篇來發布。</p>
<a id="more"></a>

<h3 id="新增一個-store-管理網站資料狀態"><a href="#新增一個-store-管理網站資料狀態" class="headerlink" title="新增一個 store 管理網站資料狀態"></a>新增一個 store 管理網站資料狀態</h3><ol>
<li>下載 Vuex，並到 main.js 啟用 Vuex</li>
<li>在 src 新增 store 資料夾，並在裡面新增 index.js</li>
<li>在 index.js 中也要引入 Vue 及 Vuex （參照：<a href="https://vuex.vuejs.org/zh/installation.html" target="_blank" rel="external nofollow noopener noreferrer">官網安裝說明</a>）</li>
<li>接著使用以下語法：</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;&#125;);</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>回到 main.js，把 store/index.js import 進來，下方的 new Vue 中也要引入 store (寫在 router 的下一行)</li>
</ol>
<h3 id="將-vue-loading-overlay-的讀取效果存入-store"><a href="#將-vue-loading-overlay-的讀取效果存入-store" class="headerlink" title="將 vue-loading-overlay 的讀取效果存入 store"></a>將 vue-loading-overlay 的讀取效果存入 store</h3><ol>
<li>在 store/index.js 的物件中，新增 state 物件，並在裡面加入 <code>isLoading</code> 特性，先預設值為 <code>false</code></li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    isLoading: <span class="literal">true</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>此時，其他元件中就不需要有 <code>isLoading</code> 這個資料，而有用到 <code>isLoading</code> 的程式碼也要先註解起來</p>
</li>
<li><p>如果外層元件跟內元件都要使用讀取效果時，應該要統一把效果加在外層。此時外層元件必須使用 computed 來操作 store 中的資料，而且 <code>isLoading</code> 這個變數要變成 function 的形式，之所以 function 要取名為 <code>isLoading</code> 是因為要對應 vue-loading-overlay 的模板 <code>&lt;loading :active.sync=&quot;isLoading&quot;&gt;&lt;/loading&gt;</code></p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 要使用讀取效果的外層元件</span></span><br><span class="line">computed: &#123;</span><br><span class="line">  isLoading() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.$store.state.isLoading</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>接著來到內元件，內元件就不需要 loading 模板了，但依然需要在 <code>methods</code> 中切換 store 的 <code>isLoading</code> 值。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">getProducts() &#123;</span><br><span class="line">  <span class="keyword">const</span> api = <span class="string">`<span class="subst">$&#123;process.env.APIPATH&#125;</span>/api/<span class="subst">$&#123;process.env.CUSTOMPATH&#125;</span>/admin/products`</span>;</span><br><span class="line">  <span class="keyword">const</span> vm = <span class="keyword">this</span>;</span><br><span class="line">  <span class="comment">// 開啟 loading</span></span><br><span class="line">  vm.$store.state.isLoading = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">this</span>.$http.get(api).then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response.data);</span><br><span class="line">    <span class="comment">// 關閉 loading</span></span><br><span class="line">    vm.$store.state.isLoading = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 存到陣列裡</span></span><br><span class="line">    vm.products = response.data.products;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用-Actions-及-Mutations-變更資料狀態"><a href="#使用-Actions-及-Mutations-變更資料狀態" class="headerlink" title="使用 Actions 及 Mutations 變更資料狀態"></a>使用 Actions 及 Mutations 變更資料狀態</h3><p>上一段改變資料狀態的方法其實並不正確，透過 Vue dev tool 可以發現資料狀態並沒有響應式，因此這一段就要來介紹如何正確地改變資料狀態。（參照：<a href="https://vuex.vuejs.org/zh/guide/actions.html" target="_blank" rel="external nofollow noopener noreferrer">官方文件 Action 介紹</a>）</p>
<ol>
<li><p>在 store 新增 actions 物件及 mutations 物件。</p>
</li>
<li><p>在 actions 中新增 <code>updateLoading()</code> 並傳入兩個參數，分別是 <code>context</code> 及 <code>status</code>。第一個參數是固定的，第二個參數則是開發者自訂的，由外部傳進來。（參照：<a href="https://vuex.vuejs.org/zh/api/#actions" target="_blank" rel="external nofollow noopener noreferrer">官網 API 參考</a>）</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">  <span class="comment">// status 原始的參數名稱為 payload</span></span><br><span class="line">  updateLoading(context, status)&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>Mutations 中的函式命名方式建議採用常數命名，也就是所有字母都用大寫。Mutations 要傳入的參數也有兩個，第一個固定都是 <code>state</code>（代表資料狀態），另一個是 <code>payload</code>（在此我們自定義名稱為 <code>status</code>）。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">mutations: &#123;</span><br><span class="line">  <span class="comment">// 第二個參數為 updateLoading 第二個參數所代表的值</span></span><br><span class="line">  LOADING(state, status) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>由於我們已經希望達成的任務就是修改 <code>state</code> 資料狀態，所以可以先在 mutations 裡寫好 <code>state</code> 變更後的結果。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">mutations: &#123;</span><br><span class="line">  <span class="comment">// 第二個參數為 updateLoading 第二個參數所代表的值</span></span><br><span class="line">  LOADING(state, status) &#123;</span><br><span class="line">    state.isLoading = status;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>接著再到 actions 來觸發 mutations 的變化。使用 <code>context</code> 的 <code>commit</code> 方法，並帶入對應的 <code>mutations</code> 名稱與要傳到該 <code>mutations</code> 的參數（<code>status</code>）。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">  updateLoading(context, status)&#123;</span><br><span class="line">    context.commit(<span class="string">'LOADING'</span>, status);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>回到內元件，原本在 <code>methods</code> 直接操作 store 資料的程式碼要刪掉，改成使用 <code>dispatch()</code> 來觸發 <code>actions</code> 中的函式。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 開啟讀取效果</span></span><br><span class="line"><span class="comment">// 第二個參數帶入新的值</span></span><br><span class="line">vm.$store.dispatch(<span class="string">'updateLoading'</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 關閉讀取效果</span></span><br><span class="line">vm.$store.dispatch(<span class="string">'updateLoading'</span>, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>在 Vue 的開發者工具中，可以看到 Vuex 管理的資料，以及不同時間點資料個別的狀態。</li>
</ol>
<h4 id="store-中-commit-與-dispatch-的區別"><a href="#store-中-commit-與-dispatch-的區別" class="headerlink" title="store 中 commit() 與 dispatch() 的區別"></a>store 中 <code>commit()</code> 與 <code>dispatch()</code> 的區別</h4><p>這兩種方法都用在 <code>actions</code> 的函式中，然而，<code>commit()</code> 用來觸發 <code>mutations</code> 中的資料函式；<code>dispatch()</code> 則是用來觸發其他 <code>actions</code> 中的函式，而且可以帶入載荷（payload，也就是參數值）。</p>
<h3 id="使用嚴謹模式可以更正確使用-Vuex"><a href="#使用嚴謹模式可以更正確使用-Vuex" class="headerlink" title="使用嚴謹模式可以更正確使用 Vuex"></a>使用嚴謹模式可以更正確使用 Vuex</h3><p>在 <code>state</code> 物件上面新增 <code>strict: true,</code> 這行程式碼，當我們寫出不合乎 Vuex 規範的程式碼時，console 就會跳錯，例如不應該在 actions 操作資料狀態等等。</p>
<p>但是，使用嚴謹模式將會有一個很不便利的地方，那就是在採用雙向綁定時不能直接用 <code>v-model</code>，而是必須多繞點彎，在 <code>computed</code> 設定 getter 跟 setter，詳細做法可參考官方文件：<a href="https://vuex.vuejs.org/zh/guide/forms.html" target="_blank" rel="external nofollow noopener noreferrer">表单处理</a>。</p>
<h3 id="使用-Actions-取得遠端資料"><a href="#使用-Actions-取得遠端資料" class="headerlink" title="使用 Actions 取得遠端資料"></a>使用 Actions 取得遠端資料</h3><ol>
<li>起手式是在 store 中 import axios：<code>import axios from &#39;axios&#39;</code>。</li>
<li>先在 <code>state</code> 中定義資料結構，用來儲存遠端取回來的資料。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">state: &#123;</span><br><span class="line">  ...</span><br><span class="line">  products: [],</span><br><span class="line">  categories: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>把原本元件中負責 AJAX 的函式貼到 <code>actions</code> 裡面，記得帶入 <code>context</code> 參數，並對程式碼做修正。例如，把寫在 <code>updateLodaing()</code> 中的 <code>commit()</code> 移到這裡面（<code>status</code> 改成 <code>true</code> 或 <code>false</code>），代替原本的 <code>dispatch()</code>；AJAX 的方法要從 <code>this.$http</code> 改為 <code>axios</code>；還要記得把儲存遠端資料的程式碼移到 mutations 裡面。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">getProducts(context) &#123;</span><br><span class="line">  <span class="keyword">const</span> url = <span class="string">`<span class="subst">$&#123;process.env.VUE_APP_APIPATH&#125;</span>/api/<span class="subst">$&#123;process.env.VUE_APP_CUSTOMPATH&#125;</span>/products/all`</span>;</span><br><span class="line">  context.commit(<span class="string">'LOADING'</span>, <span class="literal">true</span>);</span><br><span class="line">  axios.get(url).then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">    context.commit(<span class="string">'PRODUCTS'</span>, response.data.products);</span><br><span class="line">    context.commit(<span class="string">'CATEGORIES'</span>, response.data.products);</span><br><span class="line">    context.commit(<span class="string">'LOADING'</span>, <span class="literal">false</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>在 mutations 新增函式來儲存遠端取回來的資料。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">PRODUCTS(state, payload) &#123;</span><br><span class="line">  state.products = payload;</span><br><span class="line">&#125;,</span><br><span class="line">CATEGORIES(state, payload) &#123;</span><br><span class="line">  <span class="keyword">const</span> categories = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">  payload.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    categories.add(item.category);</span><br><span class="line">  &#125;);</span><br><span class="line">  state.categories = <span class="built_in">Array</span>.from(categories);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>接著要把 actions 中的函式掛載到元件中。到 <code>methods</code> 中，在 actions 對應的函式中呼叫 actions。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">getProducts() &#123;</span><br><span class="line">  <span class="keyword">this</span>.$store.dispatch(<span class="string">'getProducts'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>最後則是要把資料渲染到畫面上。在 <code>computed</code> 中新增函式來達成，函式的名稱依照資料特性名稱來取。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">categories() &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.$store.state.categories;</span><br><span class="line">&#125;,</span><br><span class="line">products() &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.$store.state.products;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Vuejs</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>w3HexSchool</tag>
        <tag>Vuex</tag>
      </tags>
  </entry>
  <entry>
    <title>[Vue] Vuex 資料狀態管理學習筆記之基本概念篇</title>
    <url>/Vuejs/20200323/1597330136/</url>
    <content><![CDATA[<p>最近為了鼠年全馬寫文活動，開始清點所有還沒公開發表的學習筆記，這就是其中一篇。<br>今天這篇會先簡介一下 Vuex 是什麼，篇幅會稍短，<br>然後下一篇就會寫到一些 Vuex 實際演練。</p>
<a id="more"></a>

<h2 id="Vuex-是什麼"><a href="#Vuex-是什麼" class="headerlink" title="Vuex 是什麼"></a>Vuex 是什麼</h2><p>根據<a href="https://vuex.vuejs.org/zh/" target="_blank" rel="external nofollow noopener noreferrer">官方文件</a>的說明，Vuex 是 Vue.js 專用的資料狀態管理模式，可以集中式地管理各元件的資料，通常用於大規模的專案。</p>
<h2 id="為何需要使用-Vuex"><a href="#為何需要使用-Vuex" class="headerlink" title="為何需要使用 Vuex"></a>為何需要使用 Vuex</h2><p><img src="https://i.imgur.com/4mkJRn0.png" alt="圖片來源：卡斯伯老師"></p>
<p>父元件跟子元件之間互相傳遞資料可以使用 <code>props</code> 及 <code>emit</code>，而兄弟元件之間可以用 <code>$eventbus</code> 做資料傳遞。然而，<code>$eventbus</code> 只適合用於簡單的情境，如果資料量大的話就不適用。</p>
<p>因此，我們就可以使用 Vuex 這個工具，它把所有資料與方法存放在 store (倉庫) 中集中管理，如此一來不管是哪一個元件都可以呼叫 store 裡面的資料與方法，並且維持雙向綁定。</p>
<h2 id="Vuex-的核心概念"><a href="#Vuex-的核心概念" class="headerlink" title="Vuex 的核心概念"></a>Vuex 的核心概念</h2><p>Vuex 中使用的方法與 Vue 元件的方法可以做以下的對應：</p>
<p><img src="https://i.imgur.com/EjqiLt4.png" alt="圖片來源：卡斯伯老師"></p>
<ul>
<li><code>state</code> 就如同 <code>data</code>，是存放資料的地方。</li>
<li><code>action</code> 如同 <code>methods</code>，用來處理非同步事件及取得遠端資料，但不負責處理資料內容的改變。</li>
<li><code>getter</code> 如同 <code>computed</code>，在畫面渲染前先對資料進行運算及過濾等。</li>
<li><code>mutation</code> 是 Vuex 比較特別的方法，它用於改變資料的內容。在 Vue 元件中我們習慣在 <code>methods</code> 中去改變資料，現在用了 Vuex 則是在 <code>mutation</code> 進行處理。</li>
</ul>
<h2 id="Vuex-的運作流程"><a href="#Vuex-的運作流程" class="headerlink" title="Vuex 的運作流程"></a>Vuex 的運作流程</h2><ol>
<li>元件透過 <code>Dispatch</code> 方法來觸發 <code>Actions</code> 事件</li>
<li><code>Actions</code> 會去執行 AJAX，取得遠端的資料</li>
<li>接著 <code>Actions</code> 使用 <code>Commit</code> 方式去呼叫 <code>Mutations</code></li>
<li>透過 <code>Mutations</code> 去改變資料狀態（<code>State</code>）</li>
<li>最後把資料狀態回應給元件去渲染畫面</li>
</ol>
<p><img src="https://i.imgur.com/8VwkWrN.png" alt="圖片來源：卡斯伯老師"></p>
<hr>
<p>這週就先介紹到這邊，下週的 Vuex 筆記就會用比較長的篇幅來記錄一些實際演練過程囉！</p>
]]></content>
      <categories>
        <category>Vuejs</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>w3HexSchool</tag>
        <tag>Vuex</tag>
      </tags>
  </entry>
  <entry>
    <title>開發紀錄：幫媽媽寫一個 SPA 形象網站</title>
    <url>/%E9%96%8B%E7%99%BC%E7%B4%80%E9%8C%84/20200316/2576586368/</url>
    <content><![CDATA[<p>不知道各位是否曾經經歷過，當身邊的親朋好友知道你會寫網頁後，就開始拜託你幫他免費寫網頁呢？<br>一般來說我們一定會跟對方<del>說誰理你啊</del>婉拒，但如果說拜託你的人是你媽呢？<br>以下就是我被我媽軟磨硬泡一年多後，認命幫她寫網頁的開發紀錄。</p>
<a id="more"></a>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我媽是一個年資 20 幾年的保母，她希望能透過架設個人網站，來吸引更多的客源。<br>於是，就如同我上面提到的，由於我被她盧到受不了，就幫媽媽做了一個 Vue SPA 個人形象網站，網址在此：<a href="https://nanny-yingju.com/" target="_blank" rel="external nofollow noopener noreferrer">https://nanny-yingju.com/</a>。</p>
<h2 id="使用技術"><a href="#使用技術" class="headerlink" title="使用技術"></a>使用技術</h2><ul>
<li>Vue Cli 3</li>
<li>Vue Router</li>
<li>Vue Components</li>
<li>RWD</li>
<li>Bootstrap 4</li>
<li>JavaScript（ES6）</li>
<li>SCSS</li>
<li>ESlint Airbnb</li>
</ul>
<h2 id="使用-Vue-Plugin"><a href="#使用-Vue-Plugin" class="headerlink" title="使用 Vue-Plugin"></a>使用 Vue-Plugin</h2><ul>
<li><a href="https://github.com/nuxt/vue-meta" target="_blank" rel="external nofollow noopener noreferrer">Vue Meta</a></li>
<li><a href="https://github.com/chrisvfritz/prerender-spa-plugin" target="_blank" rel="external nofollow noopener noreferrer">Prerender SPA Plugin</a></li>
</ul>
<p>這兩個插件很特別，都是用來優化網站的 SEO 的。就如同大家所熟知的，SPA 網頁在 SEO 方面比較不利，因此往往需要透過 SSR 來改善這件事。</p>
<p>但是我畢竟只會寫前端，突然要我學 SSR 有點困難，於是我查到了這兩個套件可以協助 SEO。首先，Vue Meta 可以讓我們在 Vue 元件的 <code>script</code> 中塞入原本要寫在網頁 <code>&lt;head&gt;</code> 中的 <code>&lt;meta&gt;</code> 資訊；而 Prerender SPA Plugin 則是幫助 SPA 網頁預先渲染出具有語意的 HTML 標籤。</p>
<h2 id="網站介紹"><a href="#網站介紹" class="headerlink" title="網站介紹"></a>網站介紹</h2><h3 id="Home-Page"><a href="#Home-Page" class="headerlink" title="Home Page"></a>Home Page</h3><p><img src="https://i.imgur.com/qyObIrW.jpg" alt="Home Header"></p>
<p>Home Page 的 Header 是三張輪播圖片，圖片來源為 <a href="https://unsplash.com/" target="_blank" rel="external nofollow noopener noreferrer">Unsplash</a>，並不是我家寶寶，沒有肖像權或是隱私權問題。</p>
<p><img src="https://i.imgur.com/YuwwwNl.jpg" alt="Home Worries Section"></p>
<p>往下滑動至一定高度時，畫面右下角會出現「回到最上方」按鈕。</p>
<p><img src="https://i.imgur.com/3j2XDrB.png" alt="Home ThreePoints Section"></p>
<p>在「聽聽家長怎麼說」的區塊，家長們的評價也是採用輪播的方式。</p>
<p><img src="https://i.imgur.com/oDwt3iz.png" alt="Footer"></p>
<p>在 Footer 嵌入我媽經營的 Facebook 粉絲專頁，增加 SEO 與能見度（雖然她粉專根本沒什麼粉絲 QQ）。</p>
<h3 id="About-Page"><a href="#About-Page" class="headerlink" title="About Page"></a>About Page</h3><p><img src="https://i.imgur.com/srUaiZz.jpg" alt="About Header"></p>
<p><img src="https://i.imgur.com/7z773xy.jpg" alt="EnvImg"></p>
<p><img src="https://i.imgur.com/iGNUccl.png" alt="Exp"></p>
<p>「托育環境」中的圖片，hover 時會動態 zoom in（精確地說是 CSS3 <code>transform: scale()</code>）；「特殊經歷」以時間軸呈現各個時間點的經歷。</p>
<h3 id="Feature-Page"><a href="#Feature-Page" class="headerlink" title="Feature Page"></a>Feature Page</h3><p><img src="https://i.imgur.com/vTRhE4w.jpg" alt="Feature Header"></p>
<p><img src="https://i.imgur.com/rZ7rRFg.jpg" alt="Feature Main"></p>
<p>各項托育特色的標題，以偽元素製造出 highlight 的效果；所搭配的圖片，hover 時會動態 zoom in（一樣，其實是 CSS3 <code>transform: scale()</code>）。</p>
<h3 id="FAQ-Page"><a href="#FAQ-Page" class="headerlink" title="FAQ Page"></a>FAQ Page</h3><p><img src="https://i.imgur.com/u7bQhGH.png" alt="FAQ main"></p>
<p>常見問答中，對該問題的回覆是以手風琴式折疊呈現；當 hover 至問題文字時，會動態 highlight。</p>
<h2 id="部署、買域名"><a href="#部署、買域名" class="headerlink" title="部署、買域名"></a>部署、買域名</h2><p>由於之前寫作品時都是直接使用 GitHub Pages，所以都沒有研究過如何買域名，也不知道如何把做好的網站跟域名綁在一起。剛好藉這個機會，參照了以下的網站，學習如何把網站弄上線（雖然遠端伺服器還是使用 GitHub 啦）。</p>
<ul>
<li><a href="https://hsiangfeng.github.io/vue/20200214/1055437216/" target="_blank" rel="external nofollow noopener noreferrer">一個指令快速部署 Vue Cli 到 GitHub Pages</a></li>
<li><a href="https://medium.com/@moojing/%E5%80%8B%E4%BA%BA%E6%8A%80%E8%A1%93%E7%AB%99%E4%B8%80%E6%8A%8A%E7%BD%A9-%E9%83%A8%E8%90%BD%E6%A0%BC%E5%BB%BA%E7%BD%AE%E5%A4%A7%E5%85%A8-%E4%BA%8C-%E5%B0%87-github-page-%E4%B8%B2%E4%B8%8A%E8%87%AA%E5%B7%B1%E7%9A%84%E5%9F%9F%E5%90%8D-8f7e11cf2687" target="_blank" rel="external nofollow noopener noreferrer">個人技術站一把罩！部落格建置大全（二）- 將 Github Page 串上自己的域名</a></li>
</ul>
<p>不過這中間也是踩到蠻多雷的，大家可以看我自己寫的<a href="https://github.com/gretema/nanny-yingju-personal-page/issues/1" target="_blank" rel="external nofollow noopener noreferrer">每日進度 issue</a> 最後一則 comment。</p>
<h2 id="Bug"><a href="#Bug" class="headerlink" title="Bug"></a>Bug</h2><p>寫這個網站雖然沒有串到後端，照理來說應該不太會有什麼問題。不過也是有產生一個 Bug 是在我今天上線後才發現的，那就是我明明有使用 animate.css + wow.js，在本機的 Web Server 也都看得到效果，結果推上線後效果就不見了，我回到開發環境檢查也是一切正常，不知道是發生什麼事。</p>
<h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>老實說我現在正開始如火如荼地尋求第一份前端工程師正職，結果我媽硬是要我在這段緊張忙碌的期間做她的個人網站，真的是蠻負擔的，尤其這位不給 Pay 的業主在我寫扣的時候總是站在我旁邊看……，如果發現我在寫履歷或投履歷或忙自己的事時，還會幽幽地說：「蛤……不是在弄我的喔……」，言盡於此，大家應該可以想像得到那個畫面吧^^</p>
<p>至於這種不用串後端的形象網站為何要用到 Vue？除了我想練一下對 Vue 專案結構的熟悉度以外，也是希望未來有一天能自己開 API 增加功能，所以就預先把架構架好這樣。</p>
<p>好啦，我媽可以容忍女兒好好的公務員不幹，從台北跑回家當尼特好幾個月，作為對她的回饋，我運用這一年多的學習成果幫她寫個網頁、讓她開心、同時又讓她可以跟親友炫耀，這樣應該算是孝順吧！XD</p>
]]></content>
      <categories>
        <category>開發紀錄</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>w3HexSchool</tag>
        <tag>VueCLI3</tag>
        <tag>形象網站</tag>
      </tags>
  </entry>
  <entry>
    <title>[Gulp] 安裝 PostCSS 的地雷</title>
    <url>/Gulp/20200310/2050018576/</url>
    <content><![CDATA[<p>最近在學怎麼使用 Gulp 來管理專案，於是按照 Ray 的教學文慢慢跟著寫 gulpfile，不過在安裝 PostCSS 時有踩到一個文章中沒提到的地雷，解決的過程一波二折，於是讓我決定紀錄一下拆地雷的經過。</p>
<a id="more"></a>

<h2 id="問題描述"><a href="#問題描述" class="headerlink" title="問題描述"></a>問題描述</h2><p>在 Ray 的教學文：<a href="https://hsiangfeng.github.io/gulp/20190610/4048666562/" target="_blank" rel="external nofollow noopener noreferrer">這是在講 Gulp 不是飲料是任務自動化工具這件事：安裝 PostCSS 篇</a>中，有提到要安裝 <code>gulp-cssnano</code>，並且將它引入 gulpfile 中。</p>
<p>我照做之後，執行 <code>gulp scss</code>，此時出現一個錯誤訊息：</p>
<p><img src="https://i.imgur.com/94aMhVj.png" alt="錯誤訊息1"></p>
<blockquote>
<p>Error in plugin “gulp-postcss”<br>Message: [object Object] is not a PostCSS plugin</p>
</blockquote>
<h2 id="嘗試解決"><a href="#嘗試解決" class="headerlink" title="嘗試解決"></a>嘗試解決</h2><p>由於在 Ray 的教學文章中沒有提到會發生這個錯誤，所以我就自行估狗了一些 StackOverflow 的文章，試了好幾篇解答後，終於找到了一個能成功解決問題的回答！</p>
<p>就是這一篇：<a href="https://stackoverflow.com/questions/48506482/gulpfile-autoprefixer-must-change-to-postcss" target="_blank" rel="external nofollow noopener noreferrer">gulpfile autoprefixer must change to postcss</a></p>
<p>我研究了回答者提供的程式碼，發現他引入 <code>gulp-cssnano</code> 的方式有點不一樣。Ray 的文章以及 <code>gulp-cssnano</code> 本身的<a href="https://www.npmjs.com/package/gulp-cssnano" target="_blank" rel="external nofollow noopener noreferrer">文件</a>都說要這樣引入：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> cssnano = <span class="built_in">require</span>(<span class="string">'gulp-cssnano'</span>);</span><br></pre></td></tr></table></figure>

<p>但是不知道為何，在 <code>require()</code> 內寫 <code>gulp-cssnano</code> 似乎找不到檔案。而如果是改成在括號內寫 <code>cssnano</code>，重新運行 <code>gulp scss</code>，錯誤訊息就消失了！</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> cssnano = <span class="built_in">require</span>(<span class="string">'cssnano'</span>);</span><br></pre></td></tr></table></figure>

<h2 id="壓縮-CSS-時又報錯"><a href="#壓縮-CSS-時又報錯" class="headerlink" title="壓縮 CSS 時又報錯"></a>壓縮 CSS 時又報錯</h2><p>改了 require 之後，我接著處理 CSS 的壓縮以及判斷開發環境與正視環境，結果在輸入 <code>gulp scss --env prod</code> 時又跳出錯誤：</p>
<p><img src="https://i.imgur.com/oJEVrYs.png" alt="錯誤訊息2"></p>
<blockquote>
<p>TypeError: dest.on is not a function</p>
</blockquote>
<p>這一次我只好找上原作者 Ray，麻煩他幫我看看是怎麼回事。原來，require 內一定要寫 <code>gulp-cssnano</code>，因為原始 <code>cssnano</code> 並沒有 gulp 相關功能。如果 require 裡面寫 <code>gulp-cssnano</code> 卻沒有正確載入檔案，可以重新安裝一次 <code>gulp-cssnano</code>，可能是安裝時沒裝好。</p>
<p>於是我重新安裝 <code>gulp-cssnano</code> 並且又改回原本寫的 require：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> cssnano = <span class="built_in">require</span>(<span class="string">'gulp-cssnano'</span>);</span><br></pre></td></tr></table></figure>

<p>之後就順利運行了～</p>
<h2 id="Special-Thanks"><a href="#Special-Thanks" class="headerlink" title="Special Thanks"></a>Special Thanks</h2><p>感謝 Ray 撥空看我的原始碼，協助我抓蟲成功 🐛</p>
]]></content>
      <categories>
        <category>Gulp</category>
      </categories>
      <tags>
        <tag>w3HexSchool</tag>
        <tag>Gulp</tag>
        <tag>PostCSS</tag>
      </tags>
  </entry>
  <entry>
    <title>[JS] 講座筆記：JS Promise 實戰教學</title>
    <url>/javascript/20200302/2110342105/</url>
    <content><![CDATA[<p>本篇筆記來自 2020.2.26 六角學院線上研討會，講者為偷米騎巴哥的 Tommy。在這一次講座中，Tommy 老師為大家複習了非同步行為與 Queue 的概念，並接續介紹了使非同步行為依序進行的四種方法。</p>
<a id="more"></a>

<p>當我們有 3 個 <code>setTimeout()</code> 時，我們可以使它們按照順序執行；但是當我們有 3 個 AJAX 時，由於變因太多、無法確定各自回傳的時間，因此不一定能照順序執行。</p>
<p>要解決非同步無法依序執行的問題，第一個方法是使用 callback function。</p>
<h2 id="讓非同步依序執行-解法一：callback"><a href="#讓非同步依序執行-解法一：callback" class="headerlink" title="讓非同步依序執行 解法一：callback"></a>讓非同步依序執行 解法一：callback</h2><p>三個 <code>setTimeout()</code> 個別用 function 包起來，且各個 function 都帶入一個 callback 參數。</p>
<p><img src="https://i.imgur.com/flYXHnz.png" alt></p>
<p>呼叫 function A 時，同時定義 callback 的任務內容，如此一來就可以先印出 <code>&#39;A&#39;</code> 再印出 <code>&#39;OK&#39;</code>。</p>
<p><img src="https://i.imgur.com/a8Pnnxr.png" alt></p>
<p>運用這個原理，就可以把 function B 當作 function A 的 callback，把 function C 當作 function B 的 callback。</p>
<p><img src="https://i.imgur.com/rUBofui.png" alt></p>
<p>但是這種做法一旦遇到<strong>太多函式要依序執行時</strong>，就會變成 <em>callback hell</em>，將會很難去分辨程式碼。</p>
<h2 id="讓非同步依序執行-解法二：Generator"><a href="#讓非同步依序執行-解法二：Generator" class="headerlink" title="讓非同步依序執行 解法二：Generator"></a>讓非同步依序執行 解法二：Generator</h2><ul>
<li>在 function 後面加一個 <code>*</code>，執行時會得到一個 <code>generator</code> 物件。</li>
<li>在 for 迴圈中使用 <code>yield</code> 關鍵字：代表<strong>暫停</strong>，先跳出 function，等之後在 function 外面用 <code>函式名稱.next()</code> 呼叫時，才會再回到 function 內部繼續執行。</li>
<li><code>generator</code> 物件會帶出 <code>done</code> 特性</li>
<li><code>arguments</code> : 類陣列物件，可取得所有傳入 function 的參數</li>
<li>遞迴：在函式裡呼叫函式本身</li>
</ul>
<p><img src="https://i.imgur.com/tIwffhZ.png" alt></p>
<p><code>for</code> 迴圈跑到最後一次時，<code>done</code> 的值為 <code>true</code>：</p>
<p><img src="https://i.imgur.com/PPGVq6s.png" alt></p>
<p>在 <code>recursion()</code> 中使用 <code>.next()</code> 呼叫函式與遞迴，讓 function A, function B, function C 依序執行：</p>
<p><img src="https://i.imgur.com/AXlstmC.png" alt></p>
<p>小結：最後一行，在 <code>generator()</code> 帶入多個函式作為參數，就能依序執行並避免 callback hell。</p>
<h2 id="讓非同步依序執行-解法三：Promise"><a href="#讓非同步依序執行-解法三：Promise" class="headerlink" title="讓非同步依序執行 解法三：Promise"></a>讓非同步依序執行 解法三：Promise</h2><ul>
<li>一個封裝 <code>Promise</code> 的函式</li>
<li><code>Promise</code> 的 callback function 要帶入兩個參數：<code>resolve</code> (成功時呼叫)，以及 <code>reject</code> (失敗時呼叫)。</li>
</ul>
<p><img src="https://i.imgur.com/7m78XIL.png" alt></p>
<p>非同步成功時，就會執行 <code>resolve</code>；<code>resolve</code> 執行後，就會執行 <code>.then()</code> 的內容；反過來說，<code>.then()</code> 的執行仰賴 <code>resolve</code> 是否執行。</p>
<p><img src="https://i.imgur.com/guI0D2w.png" alt></p>
<p>非同步失敗時，<code>Promise</code> 會執行 <code>reject</code>，<code>reject</code> 必須準備對應的函式，這個函式是針對單一的 <code>Promise</code>，在失敗時執行的方案。</p>
<p>在非同步失敗時執行對應的行為也能用 <code>catch</code> 達成，<code>catch</code> 的意思是，只要其中一個 <code>Promise</code> 沒成功執行，就跳到 <code>catch</code>。</p>
<p><img src="https://i.imgur.com/tkBRQMP.png" alt></p>
<h2 id="讓非同步依序執行-解法四：async…await"><a href="#讓非同步依序執行-解法四：async…await" class="headerlink" title="讓非同步依序執行 解法四：async…await"></a>讓非同步依序執行 解法四：async…await</h2><ul>
<li>ES7 語法，要搭配 <code>Promise</code> 使用</li>
<li><code>async</code> + function：宣告這個函式是非同步</li>
<li><code>await</code> + <code>Promise</code>：依序執行函式</li>
<li>條件：<code>async</code> 跟 <code>await</code> 一定要搭配使用，不能只用 <code>await</code> 卻不用 <code>async</code>。</li>
</ul>
<p><img src="https://i.imgur.com/0nEubbT.png" alt></p>
<p><code>reject</code> 時與 <code>try...catch</code> 搭配使用，<code>reject()</code> 括號內的內容會傳到 <code>catch(e)</code> 的 <code>e</code> 參數，也可以直接在 <code>reject()</code> 括號內放入 <code>Error</code> 物件（JS 原生錯誤物件）。</p>
<p><img src="https://i.imgur.com/6yejkHH.png" alt></p>
<p>三個函式非同步失敗時想要不同的錯誤訊息：</p>
<p><img src="https://i.imgur.com/Yi3LpB1.png" alt></p>
<p>實務上使用 <code>XMLHttpRequest</code> 時的寫法：</p>
<p><img src="https://i.imgur.com/IBlkZKh.png" alt></p>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><a href="https://slides.com/yi-tailin/deck-e329c0#/" target="_blank" rel="external nofollow noopener noreferrer">slides 簡報</a><br><a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Statements/function*" target="_blank" rel="external nofollow noopener noreferrer">function*</a><br><a href="https://developers.google.com/web/fundamentals/primers/promises?hl=zh-tw#top_of_page" target="_blank" rel="external nofollow noopener noreferrer">JavaScript Promise：簡介</a><br><a href="https://wcc723.github.io/development/2020/02/16/all-new-promise/" target="_blank" rel="external nofollow noopener noreferrer">JavaScript Promise 全介紹</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>w3HexSchool</tag>
        <tag>Promise</tag>
        <tag>async...await</tag>
        <tag>callback</tag>
        <tag>Generator</tag>
      </tags>
  </entry>
  <entry>
    <title>[JS] 講座筆記：AJAX 非同步 / Event Queue 詳解</title>
    <url>/javascript/20200224/3747532111/</url>
    <content><![CDATA[<p>本篇筆記來自 2020.2.19 六角學院線上研討會，講者為偷米騎巴哥的 Tommy。在這一次講座中，Tommy 老師用許多 Demo 示範了非同步行為與 Queue 之間的關係。</p>
<a id="more"></a>
<h2 id="Event-Queue-事件佇列"><a href="#Event-Queue-事件佇列" class="headerlink" title="Event Queue 事件佇列"></a>Event Queue 事件佇列</h2><p>JavaScript 是 Single Thread（單執行緒）語言，只用一顆 CPU 運轉，一次只能做一件事。但是，計時器（setTimeout）、AJAX、Promise 是屬於 Web APIs，不受單執行緒限制，它們會被放到 Queue 中，等待 JavaScript 執行。</p>
<p>因此，整個流程（Event Loop）就像這樣：</p>
<p>所有要執行的任務會被放到 Call Stack 裡面，JavaScript 的執行緒會逐一執行 Stack 裡的任務，當碰上非同步事件時，為了不讓程式被這些<strong>需要等待的事件</strong>卡著，就會繼續執行後續的動作。</p>
<p>那這些非同步事件什麼時候才能被執行？答案是，它們會在 Queue 中排隊，等到 JavaScript 的執行緒把 Stack 的任務都消化完了，才輪到 Queue 中的非同步事件依序執行。</p>
<p><strong>觀念重點：非同步事件會被放進排隊序列，先進先出。</strong></p>
<p>單執行緒與 Event Queue 的概念可以參照<a href="https://wcc723.github.io/javascript/2017/12/07/javascript-event-queue/" target="_blank" rel="external nofollow noopener noreferrer">鐵人賽：一次只能做一件事情的 JavaScript</a>，有動圖更好理解。</p>
<h2 id="單執行緒與-Queue"><a href="#單執行緒與-Queue" class="headerlink" title="單執行緒與 Queue"></a>單執行緒與 Queue</h2><p>JavaScript 單執行緒會按照順序執行在 Stack 中的任務。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">console.<span class="built_in">log</span>(a);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">  console.<span class="built_in">log</span>(<span class="string">'b'</span>);</span><br><span class="line">&#125;</span><br><span class="line">console.<span class="built_in">log</span>(<span class="string">'c'</span>);</span><br><span class="line"></span><br><span class="line">// <span class="string">'a'</span> <span class="string">'b'</span> <span class="string">'c'</span></span><br></pre></td></tr></table></figure>
<p>如果在這個例子中，穿插一個非同步事件進去，那麼執行順序會是如何呢？</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">console.<span class="built_in">log</span>(<span class="string">'a'</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">  console.<span class="built_in">log</span>(<span class="string">'b'</span>);</span><br><span class="line">&#125;</span><br><span class="line">setTimeout(run, <span class="number">3000</span>)</span><br><span class="line">console.<span class="built_in">log</span>(<span class="string">'c'</span>);</span><br><span class="line">// <span class="string">'a'</span> <span class="string">'c'</span> <span class="string">'b'</span></span><br></pre></td></tr></table></figure>
<p>透過這個例子可以發現，非同步事件會被放到其他行為的後面執行。<br>我們可以把 <code>setTimeout()</code> 的秒數改成 0，來驗證這個結論是否為真。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">console.<span class="built_in">log</span>(<span class="string">'a'</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">  console.<span class="built_in">log</span>(<span class="string">'b'</span>);</span><br><span class="line">&#125;</span><br><span class="line">setTimeout(run, <span class="number">0</span>)</span><br><span class="line">console.<span class="built_in">log</span>(<span class="string">'c'</span>);</span><br><span class="line">// <span class="string">'a'</span> <span class="string">'c'</span> <span class="string">'b'</span></span><br></pre></td></tr></table></figure>
<p>秒數改成 0 以後，<code>&#39;c&#39;</code> 依然是最後才印出來，就是因為非同步事件都必須在 Queue 中等待 Stack 裡其他任務結束，才能被執行。</p>
<p>再來看另一個例子，也可以看出在 Queue 中的事件永遠會被放到最後才執行的特徵。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'a'</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'b'</span>);</span><br><span class="line">&#125;</span><br><span class="line">setTimeout(run, <span class="number">3000</span>)</span><br><span class="line"><span class="keyword">var</span> start = <span class="built_in">Date</span>.now();</span><br><span class="line"><span class="comment">// 讓迴圈重複一直跑，5 秒後跳出</span></span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">Date</span>.now() - start &lt;= <span class="number">5000</span>) &#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'c'</span>);</span><br><span class="line"><span class="comment">// 'a'</span></span><br><span class="line"><span class="comment">// 5 秒後</span></span><br><span class="line"><span class="comment">// 'c'</span></span><br><span class="line"><span class="comment">// 'b'</span></span><br></pre></td></tr></table></figure>
<p>這個例子中，<code>setTimeout()</code> 應該在 3 秒後印出 <code>&#39;b&#39;</code>，但結果卻是在 5 秒後，排在 <code>&#39;c&#39;</code> 的後面出現，為什麼呢？</p>
<p>這是因為，當 3 秒到時，<code>setTimeout()</code> 就已回來 JavaScript 的執行緒了，但在 Stack 中還有 5 秒 <code>while</code> 迴圈及 <code>console.log(&#39;c&#39;);</code> 還沒執行完畢。<br>因此，當迴圈終於跑完時，<code>&#39;c&#39;</code> 接著印出來，而時間早就到了的 <code>&#39;b&#39;</code> 也就緊跟著印出來了。</p>
<h3 id="for-迴圈-以-Vue-環境為例"><a href="#for-迴圈-以-Vue-環境為例" class="headerlink" title="for 迴圈 - 以 Vue 環境為例"></a>for 迴圈 - 以 Vue 環境為例</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HTML</span></span><br><span class="line">&lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">  &lt;ul&gt;</span><br><span class="line">    &lt;li v-<span class="keyword">for</span>=<span class="string">"i in list"</span>&gt; &#123;&#123; i &#125;&#125; &lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/u</span>l&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ JS</span></span><br><span class="line"><span class="regexp">new Vue(&#123;</span></span><br><span class="line"><span class="regexp">  el: '#app',</span></span><br><span class="line"><span class="regexp">  data() &#123;</span></span><br><span class="line"><span class="regexp">    return &#123;</span></span><br><span class="line"><span class="regexp">      list: [],</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;,</span></span><br><span class="line"><span class="regexp">  mounted() &#123;</span></span><br><span class="line"><span class="regexp">   for(let i = 0; i &lt; 5; i++)&#123;</span></span><br><span class="line"><span class="regexp">     debugger;</span></span><br><span class="line"><span class="regexp">     this.list.push(i+1);</span></span><br><span class="line"><span class="regexp">   &#125;;</span></span><br><span class="line"><span class="regexp">  &#125;,</span></span><br><span class="line"><span class="regexp">&#125;)</span></span><br></pre></td></tr></table></figure>
<p>透過 <code>debugger</code> 可以在開發人員工具中看到迴圈的分解動作，我們可以看到 <code>for</code> 迴圈是等所有次數都跑完，數字才渲染出來；而不是像我們所想像的，跑一次迴圈就渲染一個數字在畫面上。</p>
<p>那麼，要如何每跑一次迴圈就渲染一次數字？</p>
<p>答案是，可以用 <code>setTiomeiut()</code> 來達成。</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">for(<span class="name">let</span> i = <span class="number">0</span><span class="comment">;i &lt; 5; i++)&#123;</span></span><br><span class="line">  setTimout(<span class="name">function</span>()&#123;</span><br><span class="line">    this.list.push(<span class="name">i+1</span>)<span class="comment">;</span></span><br><span class="line">  &#125;.bind(<span class="name">this</span>, i)) // 指定 callback 的 this 指向外層的物件</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>為什麼用 <code>setTiomeiut()</code> 就能達成呢？</p>
<p>因為 <code>for</code> 迴圈一開始沒用 <code>setTimeout()</code> 時，只有 <code>for</code> 自己一個任務在 Stack 中；而使用 <code>setTimeout()</code> 後，就變成每跑一次迴圈就產生一個存放在 Queue 中的任務，每個 Queue 中的任務又會被依序插入 Stack 中，於是就能一個執行（渲染）完才換成下一個執行（渲染）。</p>
<h2 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h2><p>傳統網頁在跟後端撈資料時，流程是這樣的：請求 =&gt; 回應 =&gt; 請求 =&gt; 回應；而使用了 AJAX 技術的網頁撈取資料的方法，則是在背景送出請求取得回應。</p>
<h3 id="常見底層"><a href="#常見底層" class="headerlink" title="常見底層"></a>常見底層</h3><ul>
<li>XMLHttpRequest (可支援 IE 7 以上, jQuery, axios)</li>
<li>HTML5 Fetch API (IE 11 以下都不支援)</li>
</ul>
<h3 id="測試用-API"><a href="#測試用-API" class="headerlink" title="測試用 API"></a>測試用 API</h3><p>以下兩個網站都可以用來製作測試用的 API，也可以客製化 AJAX 成功後的回傳訊息。</p>
<ul>
<li><a href="http://www.mocky.io" target="_blank" rel="external nofollow noopener noreferrer">Mocky: Real HTTP mocking</a></li>
<li><a href="https://www.mockable.io/" target="_blank" rel="external nofollow noopener noreferrer">Mockable.io</a></li>
</ul>
<h3 id="XMLHttpRequest-DEMO"><a href="#XMLHttpRequest-DEMO" class="headerlink" title="XMLHttpRequest DEMO"></a>XMLHttpRequest DEMO</h3><ol>
<li><p>非同步 GET 請求</p>
<figure class="highlight qml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.addEventListener(<span class="string">'load'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.responseText);</span><br><span class="line">&#125;)</span><br><span class="line">xhr.open(<span class="string">'GET'</span>, <span class="built_in">url</span>);</span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure>
<p>AJAX 行為會被丟到 Queue，等取得回應後才回到 JS 執行緒。</p>
</li>
<li><p>同步 GET 請求</p>
<figure class="highlight qml"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'start'</span>);</span><br><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.open(<span class="string">'GET'</span>, <span class="built_in">url</span>, <span class="literal">false</span>);</span><br><span class="line">xhr.send();</span><br><span class="line"><span class="built_in">console</span>.log(xhr.responseText);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'end'</span>);</span><br><span class="line"><span class="comment">// 'start'</span></span><br><span class="line"><span class="comment">// responseText</span></span><br><span class="line"><span class="comment">// 'end'</span></span><br></pre></td></tr></table></figure>
<p>這邊只是示範同步的 AJAX 是長什麼樣，實務上盡量還是用非同步 AJAX 才能讓網頁效能較好。</p>
</li>
<li><p>非同步 POST 請求</p>
<figure class="highlight qml"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如何把參數發送到後端</span></span><br><span class="line"><span class="keyword">var</span> data = <span class="keyword">new</span> FormData(); <span class="comment">// 宣告 FormData 物件</span></span><br><span class="line">data.append(<span class="string">'id'</span>, <span class="string">'5'</span>);  <span class="comment">// 在 FormData 中塞入資料</span></span><br><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.addEventListener(<span class="string">'load'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.responseText);</span><br><span class="line">&#125;)</span><br><span class="line">xhr.open(<span class="string">'POST'</span>, <span class="built_in">url</span>);</span><br><span class="line">xhr.send(data); <span class="comment">// 把帶有資料的 FormData 傳送到後端</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="Fetch-DEMO"><a href="#Fetch-DEMO" class="headerlink" title="Fetch DEMO"></a>Fetch DEMO</h3><ol>
<li><p>Fetch 發送 GET 請求</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fetch(<span class="string">'url'</span>).then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> response.json(); <span class="comment">//解讀 JSON 格式</span></span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">data</span> =&gt;</span> </span><br><span class="line">  <span class="built_in">console</span>.log(data)) <span class="comment">// 取得資料</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Fetch 發送 POST 請求</p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 把資料參數傳到後端，一樣要先宣告 FormData</span></span><br><span class="line"><span class="built_in">var</span> <span class="built_in">data</span> = <span class="literal">new</span> FormData();</span><br><span class="line"><span class="built_in">data</span>.append(<span class="string">'id'</span>, <span class="string">'5'</span>);</span><br><span class="line"></span><br><span class="line">fetch(<span class="string">'url'</span>, &#123; method: <span class="string">'POST'</span>, body: <span class="built_in">data</span> &#125;) <span class="comment">// 帶入參數</span></span><br><span class="line">.then(response =&gt; response.json();) <span class="comment">// 解讀JSON格式</span></span><br><span class="line">.then(<span class="built_in">data</span> =&gt; </span><br><span class="line">  console.<span class="keyword">log</span>(<span class="built_in">data</span>)) <span class="comment">// 取得資料</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><a href="http://slides.com/yi-tailin/event-queue-ajax/#/" target="_blank" rel="external nofollow noopener noreferrer">slide 簡報</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>AJAX</tag>
        <tag>w3HexSchool</tag>
        <tag>EventQueue</tag>
        <tag>EventLoop</tag>
      </tags>
  </entry>
  <entry>
    <title>D3.js 超超超基礎入門</title>
    <url>/D3-js/20200217/1734732239/</url>
    <content><![CDATA[<p>之前接案時為了要實現一個動畫效果而學過一點 D3.js，雖然最後沒有派上用場，但當時我寫下一些入門筆記，如果你沒學過 D3.js 而想要嘗試的話，可以參考這篇筆記。</p>
<a id="more"></a>

<h2 id="什麼是-D3-js"><a href="#什麼是-D3-js" class="headerlink" title="什麼是 D3.js"></a>什麼是 D3.js</h2><blockquote>
<p>D3.js（Data-Driven Documents）是一個使用動態圖形進行資料視覺化的 JavaScript 程式庫。與 W3C 標準相容，並且利用廣泛實現的 SVG、JavaScript 和 CSS 標準⋯⋯最常被運用在線上新聞網站呈現互動式圖形、呈現資料資料的圖表和呈現含有地理資訊的資料。——維基百科</p>
</blockquote>
<p>簡單來說，D3.js 能以圖像的方式來呈現資料，並用資料來驅動 DOM。</p>
<h2 id="SVG-標籤"><a href="#SVG-標籤" class="headerlink" title="SVG 標籤"></a>SVG 標籤</h2><p>D3.js 是用 SVG 來繪製圖像的，所以需要具備一些 SVG 繪圖的背景知識。SVG 與 HTML 一樣是有標籤的，以下就是常見的 SVG 標籤：</p>
<ul>
<li><code>&lt;text&gt;</code> - 文字標籤</li>
<li><code>&lt;circle&gt;</code> - 圓形標籤</li>
<li><code>&lt;line&gt;</code> - 線段標籤</li>
<li><code>&lt;path&gt;</code> - 弧形標籤</li>
<li><code>&lt;g&gt;</code> - 整合以上的物件，在 <code>&lt;g&gt;</code> 裡面可以放各類型的標籤</li>
</ul>
<h2 id="創建-D3-js-畫布"><a href="#創建-D3-js-畫布" class="headerlink" title="創建 D3.js 畫布"></a>創建 D3.js 畫布</h2><p>首先先來了解如何用 D3.js 選取 DOM。</p>
<ul>
<li>選取單個 DOM：d3.select(‘.className’)</li>
<li>選取多個 DOM：d3.selectAll(‘.className’)</li>
</ul>
<p>了解如何選取 DOM 後，接著先選取一個空的 <code>&lt;div&gt;</code>，動態新增一個 SVG 畫布，再用 <code>attr()</code> 動態加上屬性來設定寬高，注意，<code>attr()</code> 內的格式是物件。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">d3.<span class="keyword">select</span>(<span class="string">'.chart-d3'</span>)</span><br><span class="line">  .<span class="built_in">append</span>(<span class="string">'svg'</span>)</span><br><span class="line">  .attr(&#123;</span><br><span class="line">    <span class="string">"width"</span>: <span class="string">"75px"</span>,</span><br><span class="line">    <span class="string">"height"</span>: <span class="string">"75px"</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<h2 id="將資料導入"><a href="#將資料導入" class="headerlink" title="將資料導入"></a>將資料導入</h2><p>已經準備好畫布之後，就可以開始用資料來繪製 DOM 了。</p>
<ol>
<li>準備一個陣列當作資料基礎。<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">var vote</span> = [<span class="string">'30'</span>,<span class="string">'50'</span>,<span class="string">'100'</span>,<span class="string">'20'</span>];</span><br></pre></td></tr></table></figure></li>
<li>HTML 中準備一個空的 <code>&lt;ul&gt;</code>，className 為 <code>.list</code>。</li>
<li>用 D3 選擇 <code>.list</code>。<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">d3</span><span class="selector-class">.select</span>(<span class="string">'.list'</span>)</span><br><span class="line"><span class="selector-class">.selectAll</span>(<span class="string">'li'</span>) <span class="comment">// 預先選取等一下會創建的與資料數相同的 li</span></span><br><span class="line"><span class="selector-class">.data</span>(vote)  <span class="comment">// 導入資料</span></span><br><span class="line"><span class="selector-class">.enter</span>()  <span class="comment">// 自動生成與資料對應數量的元素</span></span><br><span class="line"><span class="selector-class">.append</span>(<span class="string">'li'</span>) <span class="comment">// 插入元素</span></span><br><span class="line"><span class="selector-class">.text</span>(function(d)&#123;</span><br><span class="line">  <span class="selector-tag">return</span> <span class="selector-tag">d</span>;</span><br><span class="line">  <span class="comment">// d 指的是資料陣列中的每個元素(如果陣列內是物件，帶進來的就是物件)</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="如何繪製長條圖"><a href="#如何繪製長條圖" class="headerlink" title="如何繪製長條圖"></a>如何繪製長條圖</h2><ol>
<li>準備一個陣列，裡面是物件，每個物件都是等一下會呈現的長條。<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">var vote</span> =[</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"Grete"</span>,</span><br><span class="line">    <span class="string">"num"</span>: 80</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"Steffi"</span>,</span><br><span class="line">    <span class="string">"num"</span>: 100</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"Lala"</span>,</span><br><span class="line">    <span class="string">"num"</span>: 200</span><br><span class="line">  &#125;,</span><br><span class="line">];</span><br></pre></td></tr></table></figure></li>
<li>在 HTML 準備一個空的 <code>&lt;div&gt;</code>，className 取為 <code>.chart</code>。</li>
<li>插入資料。<figure class="highlight scilab"><table><tr><td class="code"><pre><span class="line">d3.<span class="keyword">select</span>(<span class="string">'.chart'</span>)</span><br><span class="line">  .selectAll(<span class="string">'div'</span>)</span><br><span class="line">  .data(vote)</span><br><span class="line">  .enter()</span><br><span class="line">  .append(<span class="string">'div'</span>)</span><br><span class="line">  .html(<span class="function"><span class="keyword">function</span><span class="params">(d)</span>&#123;</span></span><br><span class="line">    <span class="comment">// .html() 類似 .innerHTML，D3 允許 SVG 跟 HTML 標籤混用</span></span><br><span class="line">    <span class="keyword">return</span> d.name + <span class="string">'&lt;br&gt;'</span> + d.num</span><br><span class="line">  &#125;)</span><br><span class="line">  .style(<span class="string">"height"</span>, <span class="function"><span class="keyword">function</span><span class="params">(d)</span>&#123;</span></span><br><span class="line">    <span class="keyword">return</span> d.num + <span class="string">'px'</span>  <span class="comment">// 調整每個長條的高度</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="如何更新圖表"><a href="#如何更新圖表" class="headerlink" title="如何更新圖表"></a>如何更新圖表</h2><p>完成上一段的長條圖之後，如果之後有新數據要更新圖表，應該怎麼做呢？<br>以下的例子從原始資料創建圖表開始，示範如何用新資料蓋過舊資料。</p>
<ol>
<li>準備原始資料陣列與新資料陣列。<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 這是原始的資料</span></span><br><span class="line"><span class="keyword">var</span> vote =[</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"Grete"</span>,</span><br><span class="line">    <span class="string">"num"</span>: <span class="number">80</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"Steffi"</span>,</span><br><span class="line">    <span class="string">"num"</span>: <span class="number">100</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"Lala"</span>,</span><br><span class="line">    <span class="string">"num"</span>: <span class="number">200</span></span><br><span class="line">  &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 這是新的資料</span></span><br><span class="line"><span class="keyword">var</span> voteUpdate =[</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"Grete"</span>,</span><br><span class="line">    <span class="string">"num"</span>: <span class="number">120</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"Steffi"</span>,</span><br><span class="line">    <span class="string">"num"</span>: <span class="number">80</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"Lala"</span>,</span><br><span class="line">    <span class="string">"num"</span>: <span class="number">60</span></span><br><span class="line">  &#125;</span><br><span class="line">];</span><br></pre></td></tr></table></figure></li>
<li>使用上一段繪製長條圖的技巧，用原始資料把節點 (<code>node</code>) 都先創建出來。<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> node = d3</span><br><span class="line">  .<span class="keyword">select</span>(<span class="string">'.chart'</span>)</span><br><span class="line">  .selectAll(<span class="string">'div'</span>)</span><br><span class="line">  .data(vote)</span><br><span class="line">  .enter()</span><br><span class="line">  .<span class="built_in">append</span>(<span class="string">'div'</span>)</span><br></pre></td></tr></table></figure></li>
<li>把繪製圖像的程式碼都放到一個函式裡 (<code>update()</code>)，直接選擇 <code>node</code> 進行渲染。函式化的目的是讓每次替換節點裡塞入的資料時，可以透過呼叫函式就重新繪製圖像。<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  node</span><br><span class="line">  .html(<span class="function"><span class="keyword">function</span><span class="params">(d)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> d.name + <span class="string">'&lt;br&gt;'</span> + d.num</span><br><span class="line">  &#125;)</span><br><span class="line">  .style(<span class="string">"height"</span>, <span class="function"><span class="keyword">function</span><span class="params">(d)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> d.num + <span class="string">'px'</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">update();</span><br></pre></td></tr></table></figure></li>
<li>最後，變更 <code>node</code> 塞入的 data，然後呼叫更新函式。<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line"><span class="keyword">node</span>.<span class="title">data</span>(voteUpdate); // 帶入新資料</span><br><span class="line">update();  // 重新渲染</span><br></pre></td></tr></table></figure>
<h2 id="小補充"><a href="#小補充" class="headerlink" title="小補充"></a>小補充</h2><h3 id="加入-className-的方法"><a href="#加入-className-的方法" class="headerlink" title="加入 className 的方法"></a>加入 className 的方法</h3>用這個方法可以把自己寫的樣式動態加到 DOM 上面：<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.attr</span>(<span class="string">"class"</span>, <span class="string">".d3-tip"</span>) <span class="comment">// 加入自訂的 className</span></span><br></pre></td></tr></table></figure>
<h3 id="插入字串的方法"><a href="#插入字串的方法" class="headerlink" title="插入字串的方法"></a>插入字串的方法</h3>用這個方法就等同於用 <code>.innerHTML</code> 插入字串到 DOM 裡面：<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line">.html(<span class="function"><span class="keyword">function</span><span class="params">(d)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"字串"</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2>本篇筆記是我在<a href="https://www.youtube.com/watch?v=0PQ8VOsyjzw" target="_blank" rel="external nofollow noopener noreferrer">觀看六角學院放在 Youtube 的教學</a>時寫下的，不過我也搜集了一些跟 D3.js 相關的文章，也放在這裡提供給大家參考。</li>
</ol>
<ul>
<li><a href="https://medium.com/@mybaseball52/%E5%A2%9E%E5%BC%B7-d3-js-%E7%9A%84%E8%A6%96%E8%A6%BA%E5%8C%96%E5%8A%9F%E8%83%BD-68eaa66eef98" target="_blank" rel="external nofollow noopener noreferrer">增強 D3.js 的視覺化功能</a></li>
<li><a href="https://ithelp.ithome.com.tw/users/20105602/ironman/1582?page=3" target="_blank" rel="external nofollow noopener noreferrer">讓你資料美美的(d3.js+vue.js) 系列</a></li>
<li><a href="https://www.oxxostudio.tw/articles/201509/svg-d3-18-enter-update-exit.html" target="_blank" rel="external nofollow noopener noreferrer">SVG D3.js - Enter、Update 和 Exit</a></li>
</ul>
]]></content>
      <categories>
        <category>D3.js</category>
      </categories>
      <tags>
        <tag>w3HexSchool</tag>
        <tag>D3.js</tag>
        <tag>DataDrivenDocuments</tag>
        <tag>資料視覺化</tag>
        <tag>長條圖</tag>
        <tag>SVG</tag>
      </tags>
  </entry>
  <entry>
    <title>[UX] 講座筆記：工程師必須了解的 UX 設計</title>
    <url>/UI-UX/20200210/3766866311/</url>
    <content><![CDATA[<p>這篇筆記來自於 2020.2.6 六角學院的線上研討會，講者為獸群之心 / Soking，講者在這一節講座中分享了設計使用者體驗時需要掌握的基本原則，並且以豐富的實務經驗來回答許多學員的發問。</p>
<a id="more"></a>

<h2 id="UX-的起源"><a href="#UX-的起源" class="headerlink" title="UX 的起源"></a>UX 的起源</h2><blockquote>
<p>使用者經驗或用戶體驗（User Experience，UX），一詞由美國學者唐·諾曼所提出⋯⋯「使用者經驗」包含使用者與公司的產品與服務互動中的所有面向。—— 維基百科</p>
</blockquote>
<p>UX 其實相當程度地根基於認知心理學。美國有名的認知心理學者 Don Norman 可說是 UX 祖師爺，他被邀請進入 Apple，協助 Apple 重視人類如何使用電腦、重視美學。</p>
<p>在以前的時代是由技術主導設計，現在則是設計師研究如何更 user friendly，電腦於是普及化。而當網路蓬勃發展後，UX 開始大量被需要。</p>
<p>Don Norman 創立的公司 Nielsen Norman Group 有提供 UX 培訓，公司官網跟 YT 有一些 UX 文章與教學。但是這些 UX 教學都還是偏理論，所以容易看了很多但不知道怎麼開始，這也是在台灣學 UX 容易遇到的問題。</p>
<p>不過使用者體驗應該是所有團隊成員的責任，只要把用戶需求放在心裡，而不是只有商業面、技術面的話，其實就是在做 UX。</p>
<h2 id="產品可用性原則"><a href="#產品可用性原則" class="headerlink" title="產品可用性原則"></a>產品可用性原則</h2><p>產品可用性有三個指標：<br>有效性 (must have)：沒有搞定產品就完蛋。例如：電商不能購物、地圖不能定位。<br>效率 (good to have)：沒做到會很麻煩。<br>滿意度：沒做到會有人不開心，不一定所有人都能滿足，需要參考自己產品定位目標。</p>
<p>有效性跟效率之間的選擇，應該看客戶需要的是什麼而提供，並不是追求兩個都要有。</p>
<p>想了解網頁 UX 更細節的優化建議可以參考 Google 研究員寫的 <a href="https://services.google.com/fh/files/events/pdf_retail_ux_playbook.pdf?fbclid=IwAR2ATmQ-bsUuTfo5kyNqt1n0EulwDucB0m060Am4cHvHNtSYk5oC5Wn6mDI" target="_blank" rel="external nofollow noopener noreferrer">UX Playbook</a>（<a href="https://medium.com/@yachenyu/google-uxplaybook-ux%E8%A8%AD%E8%A8%88%E5%BB%BA%E8%AD%B0%E6%8C%87%E5%8D%97-%E9%9B%BB%E5%95%86-%E9%9B%B6%E5%94%AE%E9%87%8D%E9%BB%9E%E7%BF%BB%E8%AD%AF-3ae3585b6769" target="_blank" rel="external nofollow noopener noreferrer">中文版</a>），裡面有列出一些共通的原則，做到的話體驗會比較好。</p>
<h2 id="設計思考"><a href="#設計思考" class="headerlink" title="設計思考"></a>設計思考</h2><p>歡迎錯誤，也歡迎不同背景的人貢獻想法。<br>UX 沒有一步到位，必須先做出一個東西，測試使用者的反應，再趕快改善。</p>
<h2 id="Site-Map"><a href="#Site-Map" class="headerlink" title="Site Map"></a>Site Map</h2><p>規範出頁面層級、標明各頁面的編號，頁面中有共用元件、有要求權限的話也會標明。</p>
<h2 id="用戶旅程地圖"><a href="#用戶旅程地圖" class="headerlink" title="用戶旅程地圖"></a>用戶旅程地圖</h2><p>可以做得簡單也可以做得複雜，可以把前中後台、用戶場景、商業邏輯都用<strong>視覺化</strong>的方式呈現。<br>視覺化是 UX 設計師很重要的工作，把抽象的事情變具體，也能幫助討論不要發散。</p>
<h2 id="Wireframe"><a href="#Wireframe" class="headerlink" title="Wireframe"></a>Wireframe</h2><p>工程師可以在 Wireframe 上確認規格跟使用流程。</p>
<h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q &amp; A"></a>Q &amp; A</h2><p>Q: 沒辦法從過去的 UX 案例來預估成效嗎？<br>A: 過去的成功無法代表未來的成功。<del>跟投資買股票一樣。</del></p>
<p>Q: 哪個階段會開始請工程師？<br>A: 在第一天就會跟工程師討論，畫出一個邊界，確認解決問題到什麼程度，這其實是商業模式層次的問題。<br>UX 會先定義用戶角色，接著做用戶研究、線上訪談，使用產品的場景、頻率、需求、流程，然後把蒐集到的資訊拿去跟客戶做討論。如果發現有些指標適合量化，就會先列出來，提供之後規格的參考。</p>
<p>Q: 請問每一個案子都會做用戶測試嗎？如果會的話用戶測試大約會找多少人測試呢？<br>A: 依照尼爾森原則，找 5 到 8 個人就能找出 85% 的問題。在做測試時應該追求快速有效的方法，找越多人測試就越曠日費時、成本越高。測試時，也會把時間限縮在 5 到 10 分鐘就做完，並會對測試者進行放聲思考法，引導他們講出對特定介面、元素的認知。</p>
<p>Q: 在判斷客戶的使用情況是否流暢，可否觀察用戶在按下某個按鈕後，過了多久時間才按下設計師所期待的用戶的按鈕，可以這樣來判斷嗎? （如果很快就按下的話, 可以代表這個設計是符合UX嗎？）<br>A: 我們會設定一個特定的任務，針對一定數量的用戶去測他們進行任務的秒數，可以用 GA 查看有些比較久才進行特定任務的人是先去幹嘛了。</p>
<p>Q: 請問，目前 UX 設計遇到的大環境威脅有哪些？例如：</p>
<ol>
<li>移動設備越做越小，導致能夠設計的空間變少</li>
<li>客戶會為了省錢，而直接要求你們做過的案例框架拿來套用，為了不願多花設計費</li>
<li>案例越做越多，模仿的競爭者越來越多</li>
<li>其他？</li>
</ol>
<p>面對這些，你們是怎麼克服的？</p>
<p>A:</p>
<ol>
<li>有限制是好的，因為畫面小反而塞不了太多東西，Web 畫面較大，可以塞的東西就多，業主常常會希望把畫面塞得滿滿的，導致畫面臃腫不堪，所以 Web 比 APP 還難設計。</li>
<li>每個業主的商業模式都不一樣，所以不太會拿其他人的來套用。</li>
<li>市面上越多流暢的產品，越能夠帶動業界品質提升，所以競爭多是好事。</li>
</ol>
<p>Q: 有沒有案子是在 iPad 上面做相關的測試？<br>A: 有，但當時客戶不想單獨測試 iPad，iPad 可以直著看也可以橫著看，所以 UI 有把尺寸設計好就沒問題。</p>
<p>Q: UI 報價高還是 UX？<br>A: 如果客戶只想做 UI，我們會問他是否有能力自己做出 Wireframe？能做到什麼程度？我們在跟客戶告知我們的專業能力後，通常客戶也願意讓我們同時做 UX 跟 UI。我們現在新客戶都不會接只做 UI 的案子。</p>
<h2 id="彩蛋：UI-設計師是否該學-HTML-CSS？"><a href="#彩蛋：UI-設計師是否該學-HTML-CSS？" class="headerlink" title="彩蛋：UI 設計師是否該學 HTML CSS？"></a>彩蛋：UI 設計師是否該學 HTML CSS？</h2><p>講者認為 UI 設計師應該要碰 HTML CSS，尤其現在案子要 RWD，如果畫面都只用繪圖軟體做，其實設計師會有盲點，會不知道實際畫面是怎麼變化的。</p>
]]></content>
      <categories>
        <category>UI/UX</category>
      </categories>
      <tags>
        <tag>UX</tag>
        <tag>userexperience</tag>
        <tag>使用者體驗</tag>
        <tag>w3HexSchool</tag>
      </tags>
  </entry>
  <entry>
    <title>[Vue] Vue CLI 3 使用筆記及如何將專案升級至 CLI 3</title>
    <url>/Vuejs/20200121/3810438936/</url>
    <content><![CDATA[<p>之前介紹過 Vue CLI 2 的基本用法了，這次來介紹 Vue CLI 3 囉！<br>CLI 3 最讚的地方就是有了視覺介面，在管理專案上更加直覺了，<br>這篇文章就要來介紹如何用 CLI 3 建置專案。</p>
<a id="more"></a>

<h2 id="Vue-CLI-2-跟-3-的差異"><a href="#Vue-CLI-2-跟-3-的差異" class="headerlink" title="Vue CLI 2 跟 3 的差異"></a>Vue CLI 2 跟 3 的差異</h2><ol>
<li>CLI 3 增加 GUI 介面，取代之前需要指令才能達成的事。</li>
<li>可以在 Webpack 新增編譯插件，例如 TypeScript。</li>
</ol>
<h2 id="創建-Vue-CLI-3-的專案"><a href="#創建-Vue-CLI-3-的專案" class="headerlink" title="創建 Vue CLI 3 的專案"></a>創建 Vue CLI 3 的專案</h2><p>可以使用終端指令來創建，也可以使用 GUI 來創建。</p>
<h3 id="終端指令創建法"><a href="#終端指令創建法" class="headerlink" title="終端指令創建法"></a>終端指令創建法</h3><figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line">vue <span class="keyword">create</span> 專案資料夾名稱</span><br></pre></td></tr></table></figure>

<p>接著選擇專案要內建的設定檔，可以先從手動選擇 (Manually select features) 開始。<br>需要選擇的項目有：</p>
<ul>
<li>Babel: 把 ES6 編譯成大部分瀏覽器都能運行的版本</li>
<li>CSS Pre-processors: SASS 之類的預處理器</li>
</ul>
<p>以上項目選好之後，還要決定這些設定檔要寫在獨立的檔案還是寫在 package.json，這邊可以按自己習慣來選擇，我個人是選擇 package.json。</p>
<p>最後，還有一個問題是問說：是否要把以上的設定儲存為設置偏好，下次創建專案時可以沿用。這邊也是看個人習慣來選擇。</p>
<h3 id="GUI-介面創建法"><a href="#GUI-介面創建法" class="headerlink" title="GUI 介面創建法"></a>GUI 介面創建法</h3><ol>
<li>在終端機輸入指令：<code>vue ui</code></li>
<li>接下來專案建立過程很直覺，按照提示一步步往下推進即可。</li>
<li>建立好後，可以在側欄看到 Plugins 跟 Dependencies，前者是 Vue Cli 運行環境中需要用到的功能，後者是前端開發需要用於專案的套件。</li>
<li>Configuration 是依據 Plugins 而生成的設定檔。</li>
<li>Tasks 就是 <code>package.json</code> <code>&quot;scripts&quot;</code> 中的項目，所以要運行特定的 mode 時可以在這邊直接按下 Run task 按鈕與 Open app 按鈕。</li>
</ol>
<h2 id="資料夾結構"><a href="#資料夾結構" class="headerlink" title="資料夾結構"></a>資料夾結構</h2><p>CLI 3 與 2 比較不同的地方在於，比較看不到那麼多設定檔，因為它其實不想讓我們去動那些設定。那些我們看不到的設定檔，其實都在 <code>node_modules</code> 裡面。</p>
<h3 id="node-modules-vue"><a href="#node-modules-vue" class="headerlink" title="node_modules/@vue"></a>node_modules/@vue</h3><p><code>node_modules</code> 的 <code>@vue</code> 資料夾中，有個 <code>webpack.config</code> 檔案，另外還有一個 <code>lib</code> 資料夾，裡面有 Webpack 其他的設定，這些都<strong>不需要去動</strong>。</p>
<p><code>public</code> 跟 <code>src</code> 是主要撰寫程式碼的地方，尤其 <code>src</code> 最為重要。</p>
<h3 id="src"><a href="#src" class="headerlink" title="src"></a>src</h3><p><code>src</code> 裡面的檔案（包括圖檔）都會被編譯，<code>main.js</code> 依然是進入點，<code>asset</code> 資料夾裡面則可以放需要編譯的 sass 檔跟 js 檔。</p>
<p>回顧 CLI 2，是把所有元件都放在 components 資料夾，而 CLI 3 則分成 <code>views</code> 資料夾及 <code>components</code> 資料夾。</p>
<p><code>components</code> 資料夾裡面放內部元件，<code>views</code> 資料夾則放外部元件（也就是用 router 切換的分頁）。</p>
<p>在 CLI 3 中，<strong>.vue 附檔名預設不能省略</strong>，引用檔案時要注意。</p>
<h3 id="public"><a href="#public" class="headerlink" title="public"></a>public</h3><p><code>public</code> 資料夾裡面檔案則不會被編譯，以前 <code>index.html</code> 是放在根目錄，現在則是放在這裡。但是 <code>index.html</code> 其實會被編譯，主要是壓縮並將 src 資料夾內的檔案放進去，在打包時會注入 css 及 js。</p>
<h3 id="如何打包：產生-dist-資料夾"><a href="#如何打包：產生-dist-資料夾" class="headerlink" title="如何打包：產生 dist 資料夾"></a>如何打包：產生 dist 資料夾</h3><p>在 <code>package.json</code> 的 <code>&quot;scripts&quot;</code> 項目中，有關於打包的設定。</p>
<p>輸入指令 <code>npm run build</code> 就能執行打包，然後根目錄就會出現一個 <code>dist</code> 資料夾，交付專案時只需要要交出 <code>dist</code> 資料夾。</p>
<h3 id="dist"><a href="#dist" class="headerlink" title="dist"></a>dist</h3><p>打開 <code>dist</code> 資料夾中的 <code>index.html</code>，拉到最下面就能看到注入的 js 檔，分別有 <code>vender.js</code> 及 <code>app.js</code>，前者是指從外部載入的資源（來自 <code>node_modules</code>），後者是我們自己撰寫的 JS。</p>
<p>由於 <code>dist</code> 中的 <code>index.html</code> 裡面注入的資源都是從根目錄開始讀起，所以<strong>要運行這個 index.html，需要把 dist 資料夾用獨立的 VS code 開起來，才能使用 web server。</strong></p>
<h2 id="環境變數設定"><a href="#環境變數設定" class="headerlink" title="環境變數設定"></a>環境變數設定</h2><p>環境變數用來區分開發中版本及正式發布版本的資料庫路徑。<br>環境變數設定檔名及變數撰寫方式可參考<a href="https://cli.vuejs.org/zh/guide/mode-and-env.html" target="_blank" rel="external nofollow noopener noreferrer">官網</a>。</p>
<ol>
<li>在根目錄新增一個專門放環境變數的檔案，例如叫做 <code>.env</code>。</li>
<li>變數撰寫方式要採用第二種（<code>VUE_APP_自己命名的變數名稱</code>），例如在測試環境下讀出同一個 API 網址的話，就寫成：<br><code>VUE_APP_API=http://localhost:3000/</code></li>
<li>到一個元件內，增加一個 hook，讀出剛剛的環境變數，例如：</li>
</ol>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">created() &#123;</span><br><span class="line">  console.<span class="built_in">log</span>(<span class="built_in">process</span>.env.VUE_APP_API);</span><br><span class="line">  <span class="comment">// 讀取環境變數要在開頭加上 process</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>使用 <code>npm run serve</code> 重整，即可讀取出環境變數。</li>
</ol>
<h3 id="如果環境變數設定檔不只一個要如何切換？"><a href="#如果環境變數設定檔不只一個要如何切換？" class="headerlink" title="如果環境變數設定檔不只一個要如何切換？"></a>如果環境變數設定檔不只一個要如何切換？</h3><ol>
<li>如果在 <code>.env</code> 以外還有別的環境變數檔，且檔案名稱是<strong>預設的名稱</strong>，例如 <strong>.env.development</strong>（serve 預設環境）或 <strong>.env.production</strong>（build 預設環境），在變數名稱相同的情況下，<strong>權重比 .env 高</strong>，所以會優先讀取它們的值。</li>
<li>也可以自訂檔案名稱，例如 <code>.env</code> 以外的另一個環境變數檔叫做 <code>.env.KK</code>，裡面的變數名稱跟 <code>.env</code> 的一樣但值不一樣。</li>
<li>到 <code>package.json</code> 的 <code>&quot;scripts&quot;</code> 項目下，該項目原本的值是 <code>&quot;vue-cli-service serve&quot;</code>，在後面多加 <code>--mode KK</code>，整串變成 <code>&quot;vue-cli-service serve --mode KK&quot;</code>。</li>
<li>使用 <code>npm run serve</code> 重整，就能切換成 <code>.env.KK</code> 設定的變數值了。</li>
</ol>
<h2 id="安裝-Vue-Router-跟-Vuex"><a href="#安裝-Vue-Router-跟-Vuex" class="headerlink" title="安裝 Vue Router 跟 Vuex"></a>安裝 Vue Router 跟 Vuex</h2><p>安裝 Vue Router 跟 Vuex 的方法很簡單，在 GUI 中選擇 Plugins 後，就可以在最上方點選「Add vue-router」及「Add vuex」。</p>
<h2 id="GUI-中關於-CLI-的設定"><a href="#GUI-中關於-CLI-的設定" class="headerlink" title="GUI 中關於 CLI 的設定"></a>GUI 中關於 CLI 的設定</h2><p>在 Configuration 中，Vue CLI 最常被更動的設定是第一個 Base URL，這個項目負責的是 <code>dist</code> 資料夾中所有檔案之間的路徑關係，預設的網頁路徑是從根目錄開始。在這邊可以把它改成專案資料夾名稱，例如 <code>/vuehw/</code>，然後把所有檔案都放進這個資料夾內。<br>交出去的資料夾結構：</p>
<ul>
<li>dist<ul>
<li>vuehw<ul>
<li>css</li>
<li>img</li>
<li>js</li>
<li>index.html</li>
<li>favicon.ico</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>至於 Router 的引入，在 CLI 3 有新的寫法，不須在檔案最前頭先 import 元件，可以在 routes 用<strong>箭頭函式</strong>導入：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attribute">path</span>: <span class="string">'/about'</span>,</span><br><span class="line">  name: <span class="string">'about'</span>,</span><br><span class="line">  component: () =&gt; import (<span class="string">'./views/About.vue'</span>)</span><br><span class="line">  // <span class="built_in">import</span>() 是一個方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="如何把-CLI-2-的專案搬到-CLI-3"><a href="#如何把-CLI-2-的專案搬到-CLI-3" class="headerlink" title="如何把 CLI 2 的專案搬到 CLI 3"></a>如何把 CLI 2 的專案搬到 CLI 3</h2><ol>
<li>先用 GUI 建立一個新專案。</li>
<li>選擇需要的工具：Babel / CSS Pre-processor / Router</li>
<li>打開舊專案的 <code>package.json</code>，安裝 CLI 2 所用到的套件：axios / bootstrap / jQuery / popper.js / vue-axios / vue-loading-overlay 等等。</li>
<li>安裝完以後，打開 <code>src/main.js</code>，把相依套件都載入。這邊可從舊專案的 <code>main.js</code> 複製 import 程式碼以及啟用程式碼。</li>
<li>打開舊專案的 <code>App.vue</code>，複製全部程式碼到新專案的 <code>App.vue</code>。</li>
<li>完成上一步以後會發現 console 跳錯，這是因為我們還沒加入環境變數，所以 AJAX 失敗。所以接下來要加入環境變數到新專案中。</li>
<li>在 <code>src</code> 新增檔案 <code>.env.development</code>，按照 CLI 3 的方式命名環境變數，再把對應的值從舊專案的 <code>dev.env.js</code> 貼過來。</li>
</ol>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">VUE_APP_APIPATH</span>=https://vue-course-api.hexschool.io</span><br><span class="line"><span class="attr">VUE_APP_CUSTOMPATH</span>=gretema</span><br></pre></td></tr></table></figure>

<ol start="8">
<li>加入環境變數後，要再把所有 AJAX 用到的 API 位址改成新的變數名稱。</li>
<li>載入其他元件，把舊專案 <code>components/Home.vue</code> 貼到新專案同名檔案裡。</li>
<li>接下來打開新專案 <code>router.js</code>，可以發現這邊引入元件的方式不同，是直接在 <code>routes.物件.component</code> 中用箭頭函式引入元件，而不是在檔案最上方 import。</li>
</ol>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line">routes: [</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">'/'</span>,</span><br><span class="line">    name: <span class="string">'home'</span>,</span><br><span class="line">    component: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'./views/Home.vue'</span>),</span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span> <span class="keyword">import</span>() 中放入元件路徑</span><br></pre></td></tr></table></figure>

<h2 id="Vue-CLI-快速原型開發"><a href="#Vue-CLI-快速原型開發" class="headerlink" title="Vue CLI 快速原型開發"></a>Vue CLI 快速原型開發</h2><p>使用 Webpack 針對單一 <code>.vue</code> 檔案進行管理，適用於較小型的專案<br>參照官網「<a href="https://cli.vuejs.org/zh/guide/prototyping.html" target="_blank" rel="external nofollow noopener noreferrer">快速原型開發</a>」。</p>
<ol>
<li>安裝全域的 cli service。</li>
<li>準備一個 <code>.html</code> 檔（裡面有 Vue 原始碼）以及一個 <code>all.css</code>。</li>
<li>新增一個 <code>index.vue</code>，在裡面新增 <code>&lt;template&gt;</code> 標籤，把 <code>.html</code> 中的 <code>&lt;div id=&quot;app&quot;&gt;</code> 整段貼進來，貼好後 <code>id=&quot;app&quot;</code> 就刪掉。</li>
<li>在 <code>index.vue</code> 新增 <code>&lt;script&gt;</code> 段落，把 <code>.html</code> 中 Vue 的原始碼貼進來，但在 <code>var app = new Vue({})</code> 前一行要加上 <code>export default {}</code>，原本 data 開始到最後的程式碼，要貼進這個物件裡。貼好之後，原本的寫法是根實例的寫法，現在必須用元件的寫法，所以 data 要改成 function return 的形式。</li>
<li>原本 <code>var app = new Vue({})</code> 可以刪掉了。</li>
<li>在終端機下指令：<code>vue serve index.vue</code>。</li>
<li>在 <code>&lt;script&gt;</code> 下方增加 <code>&lt;style&gt;</code>，並在裡面 import <code>all.css</code>。</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css"><span class="keyword">@import</span> url(<span class="string">'css/all.css'</span>);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="8">
<li>專案完成後打包：<code>vue build index.vue</code>。</li>
</ol>
]]></content>
      <categories>
        <category>Vuejs</category>
      </categories>
      <tags>
        <tag>VueCLI</tag>
      </tags>
  </entry>
  <entry>
    <title>[JS] 講座筆記：函數式程式設計</title>
    <url>/javascript/20200119/2279697082/</url>
    <content><![CDATA[<p>這篇筆記來自於 2020.1.9 六角學院的線上研討會，講者為蘇泰安老師，老師不只講解了如何善用函數來幫助程式碼更簡潔，也介紹了一些以函數為編寫基礎的語言（例如 Elixir），不過由於我對 Javascript 以外的語言並不了解，所以這篇筆記並不會著墨於其他語言。</p>
<a id="more"></a>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在 JavaScript 函式是一級公民，可以傳入另一個函式作為參數。<br>傳入其他函式作為參數的函式稱為 Callback function。<br>而接收其他函式當作自己的參數的則稱為高階函式。</p>
<h2 id="高階函式-High-order-function-：處理函式的函式"><a href="#高階函式-High-order-function-：處理函式的函式" class="headerlink" title="高階函式(High order function)：處理函式的函式"></a>高階函式(High order function)：處理函式的函式</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cook</span> (<span class="params">food1,food2, f</span>) </span>&#123;</span><br><span class="line">  f(food1);</span><br><span class="line">  f(food2);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;food1&#125;</span> in <span class="subst">$&#123;food2&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cook(<span class="string">'beef'</span>, <span class="string">'curry'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;<span class="built_in">console</span>.log(x)&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="高階函式三大台柱：map-、reduce-、filter"><a href="#高階函式三大台柱：map-、reduce-、filter" class="headerlink" title="高階函式三大台柱：map()、reduce()、filter()"></a>高階函式三大台柱：<code>map()</code>、<code>reduce()</code>、<code>filter()</code></h2><h3 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h3><p>對 A 陣列進行某種處理，回傳處理過後的新陣列 B。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">let result = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>].map(i =&gt; i * <span class="number">10</span>);</span><br><span class="line">console.log(result);</span><br><span class="line"><span class="comment">// [10,20,30,40,50]</span></span><br></pre></td></tr></table></figure>

<h3 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h3><p>從 A 陣列中篩選符合某條件的值，符合條件的值以新陣列 B 回傳。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">let result = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>].map(i =&gt; i % <span class="number">2</span> == <span class="number">0</span>);</span><br><span class="line">console.log(result);</span><br><span class="line"><span class="comment">// [2,4,6]</span></span><br></pre></td></tr></table></figure>

<h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce()"></a>reduce()</h3><p>有順序上的依賴，依序對陣列內的值進行處理（累加、相乘等等）。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// for 迴圈的累加寫法</span></span><br><span class="line">let ary = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</span><br><span class="line">let result = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (let i of ary)&#123;</span><br><span class="line">  result = result + i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// reduce() 的累加寫法</span></span><br><span class="line"><span class="keyword">let</span> result = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>].reduce(reducer, <span class="number">0</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">accu, i</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> accu + i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 起始值為 0</span></span><br><span class="line"><span class="comment">// accu 為一個暫存、累加的值，就如同上一段在 for 迴圈之前宣告的 result</span></span><br><span class="line"><span class="comment">// 第一次遞迴：accu 為 0，i 為 1，相加為 1</span></span><br><span class="line"><span class="comment">// 第二次遞迴：accu 為 1，i 為 2，相加為 3</span></span><br><span class="line"><span class="comment">// 以下類推</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 起始值的型別跟最後運算完的型別一致</span></span><br><span class="line"><span class="comment">// 常用的起始值：0, 1, [], '', &#123;&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="迴圈跟-map-、reduce-、filter-的差別："><a href="#迴圈跟-map-、reduce-、filter-的差別：" class="headerlink" title="迴圈跟 map()、reduce()、filter() 的差別："></a>迴圈跟 <code>map()</code>、<code>reduce()</code>、<code>filter()</code> 的差別：</h3><p>迴圈一定要依序對值進行處理，就像手搖店員對一個接一個的客人進行結帳；陣列方法不強調值的處理順序，只強調處理的手法。</p>
<h2 id="閉包-Closure"><a href="#閉包-Closure" class="headerlink" title="閉包 Closure"></a>閉包 Closure</h2><p>利用閉包（closure）的作法，讓函式有自己的私有變數，避免函式受到外在值的變動而被污染。當你看到一個函式內 return 了另一個函式，通常就是有用到閉包的概念。<br>參照：<a href="https://taian.su/2012-10-17-explaining-javascript-scope-and-closures-by-robert-nyman/" target="_blank" rel="external nofollow noopener noreferrer">Robert Nyman: 解釋 JavaScript 的 scope 及 closures</a>、<a href="https://pjchender.blogspot.com/2017/05/javascript-closure.html" target="_blank" rel="external nofollow noopener noreferrer">深入淺出瞭解 JavaScript 閉包（closure）</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以下情形會讓函式的結果受到外在變數的污染</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params">i</span>) </span>&#123; <span class="keyword">return</span> a + i&#125;</span><br><span class="line"><span class="built_in">console</span>.log(foo(<span class="number">100</span>));</span><br><span class="line">a = <span class="number">99</span>;</span><br><span class="line"><span class="built_in">console</span>.log(foo(<span class="number">100</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 兩次 console 結果不一樣</span></span><br><span class="line"><span class="comment">// 因為函式會吃到參數以外的變數值</span></span><br><span class="line"><span class="comment">// 而且改變變數值時，也會影響到函式結果</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fooDad</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + i;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> foo;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> foo = fooDad();</span><br><span class="line"><span class="built_in">console</span>.log(foo(<span class="number">100</span>));  <span class="comment">// 101</span></span><br><span class="line">a = <span class="number">99</span>;</span><br><span class="line"><span class="built_in">console</span>.log(foo(<span class="number">100</span>));  <span class="comment">// 101，不受污染</span></span><br></pre></td></tr></table></figure>

<h2 id="學員提問"><a href="#學員提問" class="headerlink" title="學員提問"></a>學員提問</h2><p>Q: 具名函式 VS 匿名函式的區別？<br>A: 具名函式可提升，匿名不能提升（會 <code>undefined</code>）。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>functionalprogramming</tag>
        <tag>function</tag>
        <tag>函式</tag>
      </tags>
  </entry>
  <entry>
    <title>[Vue] Vue Router 配置與運作</title>
    <url>/Vuejs/20191226/433566073/</url>
    <content><![CDATA[<p>在 SPA 的架構下，頁面切換不是由後端操控，而是由前端模擬路由器來替換畫面上的內容。<br>而我們可以透過 Vue Router 來達成這件事。</p>
<a id="more"></a>

<h2 id="Router-是由前端所模擬的路由器"><a href="#Router-是由前端所模擬的路由器" class="headerlink" title="Router 是由前端所模擬的路由器"></a>Router 是由前端所模擬的路由器</h2><p>一個使用 Vue Router 的專案會包含三個元素：</p>
<ul>
<li>進入點：main.js</li>
<li>Router 配置檔案（前端路由）：router/index.js</li>
<li>分頁內容：Vue Components (**.vue)</li>
</ul>
<h2 id="建置步驟"><a href="#建置步驟" class="headerlink" title="建置步驟"></a>建置步驟</h2><ol>
<li><p>下載 Vue Router：<code>npm install vue-router --save</code></p>
</li>
<li><p>在 <code>src</code> 資料夾裡新建 <code>router</code> 資料夾：在裡面新增一個 <code>index.js</code>，作為放置整個路由的配置檔</p>
</li>
<li><p><code>index.js</code> 一開始要寫入的是官方元件：</p>
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 官方元件</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">'vue-router'</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>載入自訂元件，也就是把 <code>components</code> 資料夾內的 <code>.vue</code> 檔寫入 <code>index.js</code>：</p>
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自訂的分頁元件</span></span><br><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">'src/components/HelloWorld'</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>啟用 router：<code>Vue.use(VueRouter);</code></p>
</li>
<li><p>將 <code>index.js</code> 匯出給進入點（<code>main.js</code>）使用：</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在 index.js 繼續寫</span></span><br><span class="line"><span class="selector-tag">export</span> <span class="selector-tag">default</span> <span class="selector-tag">new</span> <span class="selector-tag">VueRouter</span>(&#123;</span><br><span class="line">  <span class="comment">// 陣列內可放多組路徑及對應的元件</span></span><br><span class="line">  <span class="attribute">routes</span>:[</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attribute">name</span>: <span class="string">'首頁'</span>, <span class="comment">// 元件呈現的名稱</span></span><br><span class="line">      <span class="attribute">path</span>: <span class="string">'/index'</span>, <span class="comment">// 對應的虛擬路徑</span></span><br><span class="line">      <span class="attribute">component</span>: Home, <span class="comment">// 對應的元件</span></span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li><p>在 <code>main.js</code> 匯入 router：</p>
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">'./router'</span>;</span><br><span class="line"><span class="comment">// 再到 new Vue 下面加上 router 這個單字</span></span><br></pre></td></tr></table></figure></li>
<li><p>到 <code>App.vue</code>，在要<strong>呈現元件的地方</strong>用 <code>&lt;router-view&gt;&lt;/router-view&gt;</code> 替換</p>
</li>
<li><p>當網址 <code>/#</code> 後面接的是 <code>/index</code> 時，對應的元件就會呈現在畫面上</p>
</li>
</ol>
<h2 id="新增路由路徑及連結"><a href="#新增路由路徑及連結" class="headerlink" title="新增路由路徑及連結"></a>新增路由路徑及連結</h2><ol>
<li>新增新的路由：基本上就是在上一段第 6 點的 router 陣列裡面新增物件</li>
<li>在 index.html 用 CDN 載入 BS，或是用 GUI 下載 BS 套件</li>
<li>在 components 資料夾下新增 pages 資料夾，專門管理分頁元件</li>
<li>把 HelloWorld.vue 另存新檔為 page.vue，存在 pages 裡</li>
<li>整理 page.vue 裡的內容，只留下 <code>&lt;script&gt;</code> 區塊（<code>data</code> 可留空）及空的 <code>&lt;template&gt;</code>，把 BS 的卡片元件貼在 <code>&lt;template&gt;</code> 裡面</li>
<li>回到 router 的 index.js，在 <code>import Home</code> 下面新增：<br><code>import Page form ‘/components/pages/page’;</code></li>
<li>在 router 陣列裡新增相關資訊：<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  name: ‘分頁’,</span><br><span class="line">  path: ‘/page’,</span><br><span class="line">  component: Page</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>在 App.vue 插入 BS navbar，製作分頁導覽列，其中 a 連結的標籤改為 <code>&lt;router-link&gt;</code>，並把 <code>href</code> 屬性改為 <code>to=&quot;path值&quot;</code>，例如 <code>to=&quot;/page&quot;</code>；或是使用 <code>:to=&quot;{ name: &#39;分頁&#39;}&quot;</code> 也有同樣效果</li>
</ol>
<h2 id="巢狀路由"><a href="#巢狀路由" class="headerlink" title="巢狀路由"></a>巢狀路由</h2><p>剛剛在 page 分頁中的卡片，如果希望卡片不變但是裡面內容被抽換，要如何透過虛擬路由來達成呢？</p>
<ol>
<li>將 <code>page.vue</code> 另存成一個叫做 <code>child.vue</code> 的檔案，<code>page.vue</code> 本身要把 <code>.card</code> 內層都刪掉並改成 <code>&lt;router-view&gt;</code>（用來切換內容）</li>
<li><code>child.vue</code> 去掉 <code>.card</code> 外層，但要留一個沒加 <code>className</code> 的 <code>&lt;div&gt;</code> 外層，另存為 <code>child2</code>、<code>child3</code></li>
<li>child 系列的檔案要把卡片標題改一改</li>
<li>到 router 的 <code>index.js</code>，將 child 系列 <code>import</code> 進來，並在 <code>page</code> 所屬的物件中新增 <code>children</code> 特性，<code>children</code> 對應的值是一個<strong>陣列</strong>，陣列內的格式跟外層物件一樣<figure class="highlight less"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attribute">name</span>: <span class="string">'卡片 1'</span>, <span class="comment">// 元件呈現的名稱</span></span><br><span class="line">  <span class="attribute">path</span>: <span class="string">''</span>, <span class="comment">// 這裡空白代表 /page 顯示的內容就是這個子元件</span></span><br><span class="line">  <span class="attribute">component</span>: child, <span class="comment">// 對應的元件</span></span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attribute">name</span>: <span class="string">'卡片 2'</span>, <span class="comment">// 元件呈現的名稱</span></span><br><span class="line">  <span class="attribute">path</span>: <span class="string">'child2'</span>,</span><br><span class="line">  <span class="attribute">component</span>: child2, <span class="comment">// 對應的元件</span></span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attribute">name</span>: <span class="string">'卡片 3'</span>, <span class="comment">// 元件呈現的名稱</span></span><br><span class="line">  <span class="attribute">path</span>: <span class="string">'child3'</span>,</span><br><span class="line">  <span class="attribute">component</span>: child3, <span class="comment">// 對應的元件</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li>
<li>在 <code>page.vue</code> 使用 <code>&lt;router-link&gt;</code> 切換子分頁<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/page/"</span>&gt;</span>卡片 1<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/page/child2"</span>&gt;</span>卡片 2<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/page/child3"</span>&gt;</span>卡片 3<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="使用動態路由切換頁面-AJAX-結果"><a href="#使用動態路由切換頁面-AJAX-結果" class="headerlink" title="使用動態路由切換頁面 AJAX 結果"></a>使用動態路由切換頁面 AJAX 結果</h2>在同樣的版型下，用網址後面的 id 決定帶入的內容。<br>讓我們把上一段的卡片 3 改成動態路由試試看！</li>
<li>把上一段的 <code>path: &#39;child3&#39;</code> 改成 <code>path: &#39;child/:id&#39;</code>，<code>id</code> 是一個可自定義名稱的參數，這時 <code>:id</code> 就成為動態路由。</li>
<li>到卡片 3 的元件檔案（<code>child3.vue</code>），在 <code>export default</code> 的大括號內增加一個 <code>created()</code>，這個方法會在元件生成時執行。</li>
<li>存取 API 中固定的一筆資料（以 <a href="https://randomuser.me/" target="_blank" rel="external nofollow noopener noreferrer">randomuser</a> 為例）：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> id = <span class="keyword">this</span>.$route.params.id;</span><br><span class="line"><span class="comment">// route 已被掛載到 Vue 上，所以可以用 $ 呼叫</span></span><br><span class="line"><span class="comment">// params 是 router 的方法，可以讀取 router 裡的參數</span></span><br><span class="line"><span class="comment">// id 是我們自訂的參數</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// AJAX</span></span><br><span class="line"><span class="comment">// get() 中的網址參考 reandomuser 文件中的 Seeds 一節</span></span><br><span class="line"><span class="comment">// ?seed=$&#123;網址參數&#125;，且 API 網址整串要用反引號包住</span></span><br><span class="line"><span class="keyword">this</span>.$http.get(<span class="string">`https://randomuser.me/api/?seed=<span class="subst">$&#123;id&#125;</span>`</span>).then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(response);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li>在網址列隨意打幾個英文字，就能從 API 中抓取到特定資料。正式開發時，id 是由後端定義的，新增產品資料後會自動產生這個產品的 id ，前端要做的只是抓到這個 id ，並把資料顯示出來。</li>
</ol>
<h2 id="命名路由，同一個路徑載入兩個元件"><a href="#命名路由，同一個路徑載入兩個元件" class="headerlink" title="命名路由，同一個路徑載入兩個元件"></a>命名路由，同一個路徑載入兩個元件</h2><p>為卡片多做一個導覽列。</p>
<ol>
<li>在 <code>App.vue</code> 的 <code>.container</code> 上方新增一個 <code>&lt;router-view&gt;</code> 並且設定 <code>name</code> 屬性，例如 <code>name=&quot;menu&quot;</code>。</li>
<li><code>page.vue</code> 另存新檔為 <code>menu.vue</code>，<code>page.vue</code> 只留 <code>.card</code> 其餘的 <code>&lt;router-link&gt;</code> 刪掉，<code>menu.vue</code> 只留 <code>&lt;router-link&gt;</code> 其餘刪掉。</li>
<li>使用 BS nav 美化 menu，把 nav 程式碼貼進來，用 <code>&lt;router-link&gt;</code> 取代 nav 裡面的 <code>&lt;a&gt;</code>，記得補上 <code>.nav-link</code>。</li>
<li>到 router 資料夾的 <code>index.js</code> 中將 <code>menu.vue</code> <code>import</code> 進來，並到下方的路由設定改寫程式碼：<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原本使用 component 特性，改用 components 設定單一路由但多個元件</span></span><br><span class="line"><span class="symbol">components:</span> &#123;</span><br><span class="line"><span class="symbol">  default:</span> Page, <span class="comment">// 在 router-view 沒有設定 name 時預設顯示哪個元件</span></span><br><span class="line"><span class="symbol">  menu:</span> Menu <span class="comment">// 第一個 menu 是 router-view 的 name，第二個 Menu 是元件名</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<h2 id="Vue-Router-參數設定"><a href="#Vue-Router-參數設定" class="headerlink" title="Vue Router 參數設定"></a>Vue Router 參數設定</h2>請搭配 Vue Router 官方文件。<br>Vue Router 的 API 分為 Router 構造配置及 Router 實例，這篇只介紹常用的 Router 配置。</li>
</ol>
<h3 id="Router-構造配置"><a href="#Router-構造配置" class="headerlink" title="Router 構造配置"></a>Router 構造配置</h3><p>構造配置用於 <code>index.js</code> 這個檔案中，官方文件有介紹更多更詳細的方法跟屬性可用。</p>
<ul>
<li>routes 物件：官方文件有列出總共有哪些特性可以調整。</li>
<li>mode 字串：決定網址的 <code>#</code> 是否要保留，或是做其他的設定。如果使用 <code>history</code> 模式，可以去除網址中的 <code>#</code>，但是必須配合後端使用。所以基本上還是以預設模式為主即可。</li>
<li>base 字串：根路徑設置的地方。</li>
<li>linkActiveClass 字串：當某個路徑被啟用時會被加上特定的啟用 <code>class</code>，在這個特性裡可以設定路徑啟用的 className。</li>
<li>linkExactActiveClass 字串：跟上一個差不多。</li>
</ul>
<h2 id="自定義切換路由方法"><a href="#自定義切換路由方法" class="headerlink" title="自定義切換路由方法"></a>自定義切換路由方法</h2><p>有些行為必須在 AJAX 結束後才去切換畫面，此時 <code>router-link</code> 就不一定適用。</p>
<p>舉例來說，當我們在電商網站買完東西、結帳送出後，需要進行一些 AJAX 的行為，得到資料後使用一些方法，使網頁切換。</p>
<p>此時，我們應該運用元件 <code>methods</code> + Vue Router 的實例方法，來切換畫面。</p>
<p>在官方文件的 API / Router 實例方法中，有許多我們能運用的方法，其中較常用的有：</p>
<ul>
<li><code>router.push()</code>：括號裡放入<code>&#39;路徑&#39;</code>。</li>
<li><code>router.back()</code>：回到上一頁，括號裡不需放參數。</li>
<li><code>router.forward()</code>：前進下一頁，括號裡不需放參數。</li>
<li><code>router.go()</code>：括號裡放入數值，代表前進（正數）或後退（負數）的頁數。</li>
<li><code>router.replace()</code>：括號裡放入<code>&#39;路徑&#39;</code>，透過這個方法前往指定路徑，將不會記錄在瀏覽器。</li>
</ul>
<h3 id="應用方式"><a href="#應用方式" class="headerlink" title="應用方式"></a>應用方式</h3><ol>
<li>在元件寫一個 <code>&lt;a&gt;</code>，並綁定一個自訂的事件，透過這個事件來更新路徑。<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&lt;a <span class="attribute">href</span>=<span class="string">"#"</span> @click.<span class="attribute">prevent</span>=<span class="string">"updatePath"</span>&gt;切換到指定頁面&lt;/a&gt;</span><br></pre></td></tr></table></figure></li>
<li>在元件裡新增 <code>methods</code>，使用 <code>router.push()</code> 方法。<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">  updatePath() &#123;</span><br><span class="line">    <span class="keyword">this</span>.$router.<span class="keyword">push</span>(<span class="string">'/page/child2'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>Vuejs</category>
      </categories>
      <tags>
        <tag>VueRouter</tag>
      </tags>
  </entry>
  <entry>
    <title>[Vue] Vue CLI 2 建置與運作</title>
    <url>/Vuejs/20191225/1488994884/</url>
    <content><![CDATA[<p>雖然 Vue CLI 2 現在已經出到 3 了，但還是把自己學習使用 2 所做的筆記放上來，說不定依然能提供給各位做參考（？</p>
<a id="more"></a>

<h2 id="什麼是-Vue-CLI？"><a href="#什麼是-Vue-CLI？" class="headerlink" title="什麼是 Vue CLI？"></a>什麼是 Vue CLI？</h2><ul>
<li>基於 Webpack 所建置的開發工具</li>
<li>便於使用各種第三方工具（BS4, Vue Router…）</li>
<li>可運行 Sass, Bebel 等編譯工具</li>
<li>便於開發 SPA 的網頁工具</li>
<li>簡單設定就能搭建開發時常用的環境</li>
</ul>
<h2 id="下載"><a href="#下載" class="headerlink" title="下載"></a>下載</h2><ol>
<li><code>npm install -g vue-cli</code></li>
<li>輸入 <code>vue</code>：出現許多可使用的指令，例如輸入 <code>vue list</code> 能夠選擇下載的樣板，選擇 <code>webpack</code> 樣板即可</li>
<li>新增專案：輸入 <code>vue init 樣板名稱 專案名稱</code></li>
</ol>
<h2 id="Vue-CLI-指令"><a href="#Vue-CLI-指令" class="headerlink" title="Vue CLI 指令"></a>Vue CLI 指令</h2><p><code>npm install</code>：安裝所有套件<br><code>npm run dev</code>：運行開發的環境<br><code>npm run build</code>：運行正式版的環境，將所有網頁內容打包壓縮</p>
<p><code>npm run</code> 是運行 <code>package.json</code> 內的 <code>script</code>，運行時可以直接執行 <code>node_modules</code> 內的模組。</p>
<h2 id="Vue-CLI-產生的資料夾結構"><a href="#Vue-CLI-產生的資料夾結構" class="headerlink" title="Vue CLI 產生的資料夾結構"></a>Vue CLI 產生的資料夾結構</h2><ul>
<li><p><code>dist</code>：這資料夾下的檔案都要放在 server 下才能正常運作，主要是透過 <code>npm run bulid</code> 生成的。每次輸入 <code>npm run build</code> 的時候 <code>dist</code> 會自動重新生成，並加上不同的 hash 在資源上，避免有暫存而沒有取到新資源。</p>
</li>
<li><p>根目錄的 <code>index.html</code>：不需要動，Vue CLI 會自動把 JS 資源注入在 <code>#app</code> 下方註解的位置。</p>
</li>
<li><p><code>static</code>：放入不會被編譯的檔案。</p>
</li>
<li><p><code>src</code>：放入會被編譯的檔案，開發都在這邊，底下的 <code>main.js</code> 就是所有 <code>vue.js</code> 的進入點。在這之下的 <code>assets</code> 資料夾會針對特定尺寸的圖片，編譯成 base 64。</p>
</li>
<li><p><code>.postcssrc.js</code>：替 CSS 編譯加入前綴詞的設定檔</p>
</li>
<li><p><code>.babelrc</code>：替 ES6 編譯的設定檔</p>
</li>
</ul>
<p>在 vue-cli 中都是使用<strong>元件</strong>來互相引用。</p>
<p>例如在 <code>components</code> 資料夾內的 <code>.vue</code> 檔，一個檔案就是一個元件，<code>.vue</code> 中包含 <code>x-template</code>、<code>&lt;script&gt;</code>、<code>&lt;style&gt;</code>，之後就可以在其他檔案中載入這支元件檔案。</p>
<h2 id="Webpack-腳本結構"><a href="#Webpack-腳本結構" class="headerlink" title="Webpack 腳本結構"></a>Webpack 腳本結構</h2><h3 id="Webpack-如何運作"><a href="#Webpack-如何運作" class="headerlink" title="Webpack 如何運作"></a>Webpack 如何運作</h3><p><code>main.js</code> 為主要檔案（稱為 entry，進入點），會載入其他相依的檔案，例如 <code>.scss</code>、<code>.vue</code> 等等，這些相依的檔案會透過 loader 工具，把要載入 <code>main.js</code> 的內容轉譯為 <code>.js</code> 檔可以閱讀的格式。</p>
<p>接著 Webpack 會監控 <code>main.js</code> 及這些載入的內容，當它們一更動時就會進行編譯，並輸出（output）為 <code>.js</code>、<code>.css</code>、<code>.jpg</code> 等檔案。</p>
<h3 id="build-資料夾"><a href="#build-資料夾" class="headerlink" title="build 資料夾"></a>build 資料夾</h3><p>在 <code>build</code> 資料夾中有三個 <code>webpack</code> 開頭的檔案，分別為 <code>webpack.base</code>、<code>webpack.dev</code>、<code>webpack.prod</code>。</p>
<ul>
<li><code>webpack.base</code>：最重要的檔案，其他兩個檔案都會引用它。<ul>
<li>裡面有各項設定，包含進入點檔案（entry）、輸出路徑（output）、省略附檔名（resolve）及路徑縮寫（alias）、loader 規則（modules）。</li>
<li>loader 的規則在 <code>modules</code> 之下，但除了在這邊有關於檔案編譯的設定以外，在同資料夾的 <code>utils.js</code> 也有，例如關於 css、postcss、sass 的編譯。</li>
<li><code>modules</code> 中有關於編譯圖檔的設定，低於 10 kb 的圖檔會被壓縮成 base 64，如果高於 10 kb 則會輸出為圖檔並加上 hash 字串。</li>
</ul>
</li>
<li><code>webpack.dev</code> ：開發中的版本，用途是讓我們在開發中可以預覽畫面，不太需要修改。</li>
<li><code>webpack.prod</code>：負責的則是輸出的結果，不太需要修改。</li>
</ul>
<h3 id="config-資料夾"><a href="#config-資料夾" class="headerlink" title="config 資料夾"></a>config 資料夾</h3><p><code>webpack.base</code> output 的設定中，可以看到有關於 <code>config</code> 資料夾的檔案。</p>
<p><code>config</code> 資料夾有三個檔案：<code>index.js</code>、<code>dev.env.js</code>、<code>prod.env.js</code>。</p>
<p><code>index</code> 是用於設定整個編譯環境，可以設定 host 跟 port；其餘兩支檔案是用於撰寫環境變數，可以輸出到 <code>.vue</code> 中，輸出方法是在 <code>.vue</code> 檔裡這樣設定：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="actionscript">  name: <span class="string">'HelloWorld'</span>,</span></span><br><span class="line">  data () &#123;</span><br><span class="line"><span class="actionscript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line">     msg: process.env.NODE_ENV</span><br><span class="line"><span class="actionscript">     <span class="comment">// process.env 是 webpack 讀取資源的路徑</span></span></span><br><span class="line"><span class="actionscript">     <span class="comment">// 如果是在開發環境就會讀取 dev.env</span></span></span><br><span class="line"><span class="actionscript">     <span class="comment">// 正式環境就會讀取 prod.env</span></span></span><br><span class="line"><span class="actionscript">     <span class="comment">// 後面接的是環境變數</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>NODE_ENV</code> 是寫在 <code>dev.env</code> 及 <code>prod.env</code> 中的變數，值要記得用 <code>&#39;&quot;&quot;&#39;</code> 包住，否則會讀取失敗。</p>
<p>環境變數常用於 AJAX，因為 AJAX 使用的路徑在開發版跟正式版中往往是不同的，所以就可以用環境變數去區分。</p>
<h2 id="透過-Vue-CLI-載入外部套件"><a href="#透過-Vue-CLI-載入外部套件" class="headerlink" title="透過 Vue CLI 載入外部套件"></a>透過 Vue CLI 載入外部套件</h2><h3 id="Bootstrap"><a href="#Bootstrap" class="headerlink" title="Bootstrap"></a>Bootstrap</h3><p>下載 BS，順便把 node-sass 及 sass loader 等兩個套件一起下載：</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">npm install bootstrap <span class="keyword">node</span><span class="title">-sass</span> sass-loader --save</span><br></pre></td></tr></table></figure>

<p>下載完成後，Vue CLI 需要重新運行：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">npm <span class="keyword">run</span><span class="bash"> dev</span></span><br></pre></td></tr></table></figure>

<p>打開 <code>App.vue</code>，在 <code>&lt;style&gt;</code> 上加上 <code>lang=&quot;scss&quot;</code>，並且把原本的 <code>style</code> 內容改成 <code>sass</code> 的格式，測試 <code>sass</code> 是否能正確運行：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="variable">$color</span>: black;</span><br><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="variable">$color</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果測試成功，就可以把測試內容刪掉，並輸入以下程式碼把 BS 載進來：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@import</span> <span class="string">"~bootstrap/scss/bootstrap"</span>;</span><br></pre></td></tr></table></figure>

<h4 id="元件的-lt-style-gt-scoped-屬性"><a href="#元件的-lt-style-gt-scoped-屬性" class="headerlink" title="元件的 &lt;style&gt; scoped 屬性"></a>元件的 <code>&lt;style&gt;</code> <code>scoped</code> 屬性</h4><p>如果元件的 <code>&lt;style&gt;</code> 有加上 <code>scoped</code> 屬性，意思是這些樣式只適用於這個元件，其他元件不會吃到它的樣式。</p>
<h3 id="vue-axios"><a href="#vue-axios" class="headerlink" title="vue-axios"></a>vue-axios</h3><p>AJAX 的工具，使用非同步的 Promise 製作。</p>
<p>下載 axios 及 vue-axios：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">npm <span class="keyword">install</span> <span class="comment">--save axios vue-axios</span></span><br></pre></td></tr></table></figure>

<p>下載好以後重新運行：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">npm <span class="keyword">run</span><span class="bash"> dev</span></span><br></pre></td></tr></table></figure>

<p>axios 文件中有寫該如何使用，在進入點檔案中加入以下程式碼：</p>
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span> <span class="comment">// Vue CLI 已經載入好了</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span> <span class="comment">// 主要的 AJAX 套件</span></span><br><span class="line"><span class="keyword">import</span> VueAxios <span class="keyword">from</span> <span class="string">'vue-axios'</span> <span class="comment">// 將它轉為 Vue 的套件</span></span><br><span class="line"></span><br><span class="line">Vue.use(VueAxios, axios) <span class="comment">// 執行 axios</span></span><br></pre></td></tr></table></figure>

<p>測試 AJAX 是否能成功：在 <code>App.vue</code> 的 <code>export default</code> 中，加入 <code>created()</code>。</p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line">created() &#123;</span><br><span class="line">  <span class="keyword">this</span>.$http.get(<span class="string">'https://randomuser.me/api/'</span>).<span class="keyword">then</span>(<span class="function"><span class="params">(response)</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response.data);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>vue-axios AJAX 使用方式在<a href="https://www.npmjs.com/package/vue-axios" target="_blank" rel="external nofollow noopener noreferrer">官網</a>有寫。</p>
]]></content>
      <categories>
        <category>Vuejs</category>
      </categories>
      <tags>
        <tag>VueCLI</tag>
      </tags>
  </entry>
  <entry>
    <title>[Vue] Vue 常用 API</title>
    <url>/Vuejs/20191224/3312282522/</url>
    <content><![CDATA[<p>Vue 提供的 API 很多，本篇筆記整理了一些常用的 API 用法，應該算得上實用。</p>
<a id="more"></a>

<h2 id="Vue-extend-及-extends"><a href="#Vue-extend-及-extends" class="headerlink" title="Vue.extend() 及 extends"></a>Vue.extend() 及 extends</h2><p>當數個元件的內容很相近、只有少部分不同時，可以使用 <code>Vue.extend()</code> 建立重複的部分，並在元件中搭配使用 <code>extends</code> 特性來取用 <code>Vue.extend()</code> 的內容。</p>
<p>首先宣告一個 <code>Vue.extend()</code> 方法，參數為一個物件。</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="keyword">new</span><span class="type">Extend</span> = Vue.extend(&#123;</span><br><span class="line">  <span class="comment">// 把元件之間相同的內容寫在這裡</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>接著在元件裡面寫入各自不同的內容，並且要新增一個 <code>extends</code> 特性，對應的值為 <code>Vue.extend()</code> 的變數。</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> childOne = &#123;</span><br><span class="line">  props: [<span class="string">'item'</span>],</span><br><span class="line">  <span class="keyword">extends</span>: newExtend <span class="comment">// 以 newExtend 為基底，延伸使用</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> childTwo = &#123;</span><br><span class="line">  props: [<span class="string">'item'</span>],</span><br><span class="line">  template: <span class="string">'#row-component-two'</span>, <span class="comment">// 跟 childOne 元件使用的模板不同，故寫在這裡</span></span><br><span class="line">  <span class="keyword">extends</span>: newExtend</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>當元件使用 <code>extends</code> 來擴充內容時，若在元件中有新增不同的資料或函式，則 <code>Vue.extend()</code> 的內容與元件中的內容都會存在；若在元件中宣告與 <code>Vue.extend()</code> 相同名稱的資料或函式，則在 <code>Vue.extend()</code> 的內容會被覆寫掉。</p>
<p>參照：<a href="https://ithelp.ithome.com.tw/articles/10202027" target="_blank" rel="external nofollow noopener noreferrer">Vue 學習筆記-讓你 30 天掌握 Vue-Day 18 : Vue extend</a></p>
<h2 id="Filter-自訂畫面資料呈現格式"><a href="#Filter-自訂畫面資料呈現格式" class="headerlink" title="Filter 自訂畫面資料呈現格式"></a>Filter 自訂畫面資料呈現格式</h2><h3 id="局部：只限個別元件使用"><a href="#局部：只限個別元件使用" class="headerlink" title="局部：只限個別元件使用"></a>局部：只限個別元件使用</h3><p>在特定元件內想要套用特定資料格式時，使用局部的 <code>filters</code> 特性。</p>
<p>在雙花括號裡的資料後面，用一個 <code>|</code> 隔開，後面加上自訂的 <code>filters</code> 名稱。<code>filters</code> 可以重複使用，一個元素上也可以套用多個 <code>filters</code>。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">// 元件模板</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/x-template"</span> <span class="attr">id</span>=<span class="string">"row-component"</span>&gt;</span></span><br><span class="line"><span class="handlebars"><span class="xml">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">   <span class="tag">&lt;<span class="name">td</span>&gt;</span> </span><span class="template-variable">&#123;&#123; item.cash | currency&#125;&#125;</span><span class="xml"> <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">    <span class="tag">&lt;<span class="name">td</span>&gt;</span> </span><span class="template-variable">&#123;&#123; item.icash | currency&#125;&#125;</span><span class="xml"> <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>回到元件，在 <code>data</code> 同層加上 <code>filters</code> 特性，<code>filters</code> 的值為<strong>物件</strong>型別，裡面的特性就是剛剛在模板中自訂的 <code>filters</code> 名稱，且它會對應一個函式，該函式要回傳「資料轉化為特定格式後的值」。</p>
<p>以下以「將數字加上千分號」為例。</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 局部註冊的元件</span></span><br><span class="line"><span class="keyword">var</span> child = &#123;</span><br><span class="line">  props: [<span class="string">'item'</span>],</span><br><span class="line">  template: <span class="string">'#row-component'</span>,</span><br><span class="line">  data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      data: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  filters: &#123;</span><br><span class="line">    <span class="comment">// 參數 n 代表要加上特定格式的資料</span></span><br><span class="line">    currency: <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> n.toFixed(<span class="number">2</span>).replace(<span class="regexp">/\d(?=(\d&#123;3&#125;)+\.)/g</span>, <span class="string">'$&amp;,'</span>);</span><br><span class="line">      <span class="comment">// 算式是從 stackoverflow 抄來的</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一個資料上可以加上多個 <code>filters</code>，只需要重複進行以上步驟即可。</p>
<h3 id="全域：所有元件與根實例共用"><a href="#全域：所有元件與根實例共用" class="headerlink" title="全域：所有元件與根實例共用"></a>全域：所有元件與根實例共用</h3><p>如果所有元件及根實例都想要使用同樣的資料格式時，使用 <code>Vue.filter()</code>。同樣的 <code>filters</code> 如果在全域有設定了，元件內就不用再設定。</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 結構</span></span><br><span class="line">Vue.filter(<span class="string">'filters 名稱'</span>, 處理資料的函式);</span><br><span class="line"></span><br><span class="line"><span class="comment">// JS</span></span><br><span class="line">Vue.filter(<span class="string">'currency'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> n.toFixed(<span class="number">2</span>).replace(<span class="regexp">/\d(?=(\d&#123;3&#125;)+\.)/g</span>, <span class="string">'$&amp;,'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="set-動態寫入資料"><a href="#set-動態寫入資料" class="headerlink" title="$set() 動態寫入資料"></a>$set() 動態寫入資料</h2><blockquote>
<p>向響應式物件中添加一個特性，並確保該新特性同樣是響應式的，並觸發 View 更新。它必須用於向響應式物件上添加新特性，因為 Vue 無法檢測到普通的添加特性。—— Vue 官方文件</p>
</blockquote>
<p>有時候我們沒辦法預先定義好資料內容，尤其是需要從 AJAX 抓資料的時候。如果要<strong>事後補資料</strong>到元件的 <code>data</code> 內且被 Vue 的 setter、getter 監控的話，就要使用 <code>this.$set()</code> 語法。</p>
<p><code>$set()</code> 有三個參數，第一個是資料要存放的物件（例如 <code>this.data</code>），第二個是資料在存放物件中對應的特性，第三個是要寫入的資料內容。</p>
<p>注意，<code>this.$set()</code> 要寫在元件的 <code>methods</code> 裡面。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 元件</span></span><br><span class="line"><span class="keyword">var</span> child = &#123;</span><br><span class="line">  props: [<span class="string">'item'</span>],</span><br><span class="line">  template: <span class="string">'#row-component'</span>,</span><br><span class="line">  <span class="keyword">data</span>: function() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="keyword">data</span>: &#123;&#125; <span class="comment">// data 留空，用 $set() 動態寫入資料</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    addData: function() &#123;</span><br><span class="line">       <span class="keyword">this</span>.$<span class="keyword">set</span>(<span class="keyword">this</span>.<span class="keyword">data</span>, <span class="string">'item'</span>, &#123;</span><br><span class="line">         name: <span class="keyword">this</span>.item.name</span><br><span class="line">       &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="this-set-等同於-Vue-set-嗎？"><a href="#this-set-等同於-Vue-set-嗎？" class="headerlink" title="this.$set 等同於 Vue.set 嗎？"></a>this.$set 等同於 Vue.set 嗎？</h3><p><img src="https://i.imgur.com/cSwXNQX.png" alt></p>
<h2 id="mixins-混合其他的元件內容"><a href="#mixins-混合其他的元件內容" class="headerlink" title="mixins 混合其他的元件內容"></a>mixins 混合其他的元件內容</h2><p>先宣告一個變數，把多個元件會共用的程式碼以<strong>物件</strong>的形式存放在該變數裡。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 宣告 mixins 內容</span></span><br><span class="line"><span class="comment">// 第一個 mixins</span></span><br><span class="line"><span class="keyword">var</span> mixinFilter = &#123;</span><br><span class="line">  template: <span class="string">'#row-component'</span>,</span><br><span class="line">  filters: &#123;</span><br><span class="line">    dollarSign: <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">`$ <span class="subst">$&#123;n&#125;</span>`</span></span><br><span class="line">    &#125;,</span><br><span class="line">    currency: <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> n.toFixed(<span class="number">2</span>).replace(<span class="regexp">/./g</span>, <span class="function"><span class="keyword">function</span> (<span class="params">c, i, a</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i &amp;&amp; c !== <span class="string">"."</span> &amp;&amp; ((a.length - i) % <span class="number">3</span> === <span class="number">0</span>) ? <span class="string">','</span> + c : c;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二個 mixins</span></span><br><span class="line"><span class="keyword">var</span> mixinMounted = &#123;</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'這段是 Mixin 產生'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在需要使用共用程式碼的元件中，新增 <code>mixins</code> 特性，<code>mixins</code> 的值要以<strong>陣列</strong>的方式呈現，在該陣列中放入剛剛宣告的變數。</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 元件</span></span><br><span class="line"><span class="selector-tag">Vue</span><span class="selector-class">.component</span>(<span class="string">'row-component'</span>, &#123;</span><br><span class="line">  <span class="attribute">props</span>: [<span class="string">'item'</span>],</span><br><span class="line">  <span class="attribute">data</span>: function () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      <span class="attribute">data</span>: &#123;&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attribute">mixins</span>: [ mixinFilter, mixinMounted ],</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="mixins-和-extends-的差異"><a href="#mixins-和-extends-的差異" class="headerlink" title="mixins 和 extends 的差異"></a>mixins 和 extends 的差異</h3><p><code>mixins</code> 和 <code>extends</code> 兩者都有擴展的作用，只差在 <code>mixins</code> 是陣列，因此可以將不同元件內容分成多個物件後，在需要的元件內使用多個 <code>mixins</code>；而 <code>extends</code> 用於擴展<strong>單個元件</strong>。</p>
<p>當有相同模板要重複使用的時候透過 <code>extend</code> 去實現，而有零散功能需要套用到不同的模板上的時候，則透過 <code>mixin</code> 去達成。</p>
<h2 id="Directive-開發互動-UI"><a href="#Directive-開發互動-UI" class="headerlink" title="Directive 開發互動 UI"></a>Directive 開發互動 UI</h2><p>基本語法結構為：<code>Vue.directive(&#39;自訂名稱&#39;, {鉤子函式})</code>。然後在要使用 <code>directive</code> 的 HTML 元素上，加上 <code>v-自訂名稱</code>。</p>
<p><code>directive</code> 有自己的生命週期，且有 <code>el</code>、<code>binding</code>、<code>vnode</code> 和 <code>oldVnode</code> 等參數可以帶入鉤子函式。在特定生命週期要執行的任務，要寫在鉤子函式內。</p>
<p>至於總共有哪些鉤子函式，請參閱官方文件。</p>
<h3 id="鉤子函式的參數"><a href="#鉤子函式的參數" class="headerlink" title="鉤子函式的參數"></a>鉤子函式的參數</h3><ul>
<li><code>el</code>：代表選取的 DOM，跟使用 <code>querySelector</code> 效果一樣</li>
<li><code>binding</code>：一個物件，裡面包含了 <code>directive</code> 自帶的特性</li>
<li><code>vnode</code>：Vue 的虛擬節點</li>
</ul>
<p>參照：<a href="https://cn.vuejs.org/v2/guide/custom-directive.html" target="_blank" rel="external nofollow noopener noreferrer">官方文件-自定義指令</a></p>
<h3 id="範例：製作表單驗證器"><a href="#範例：製作表單驗證器" class="headerlink" title="範例：製作表單驗證器"></a>範例：製作表單驗證器</h3><p>假設我們已經有一個現成的 <code>&lt;input&gt;</code> 了，接著宣告一個 <code>directive</code>，先幫這個 <code>&lt;input&gt;</code> 加上 BS 表單樣式。</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line">Vue.directive(<span class="string">'validation'</span>, &#123;</span><br><span class="line">  bind: <span class="function"><span class="keyword">function</span> <span class="params">(el, binding, vnode)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 鉤子函式通常帶入的參數就這三個</span></span><br><span class="line">    el.className = <span class="string">'form-control'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在 <code>directive</code> 中加入 <code>update()</code> 鉤子，當表單有資料變動時就會觸發。上網查一下驗證 email 格式的正規式，並判斷使用者輸入的值是否符合格式。是的話就加上通過驗證的 <code>class</code>，不是的話就加上未通過的 <code>class</code>。</p>
<figure class="highlight taggerscript"><table><tr><td class="code"><pre><span class="line">Vue.directive('validation', &#123;</span><br><span class="line">  update: function (el, binding, vnode) &#123;</span><br><span class="line">    // 可以在這裡取得 input 的 value</span><br><span class="line">    var value = el.value;</span><br><span class="line"></span><br><span class="line">    // Email 格式驗證的正規式</span><br><span class="line">    var re = /^(([^&lt;&gt;()<span class="symbol">\[</span><span class="symbol">\]</span><span class="symbol">\.</span>,;:<span class="symbol">\s</span>@<span class="symbol">\"</span>]+(<span class="symbol">\.</span>[^&lt;&gt;()<span class="symbol">\[</span><span class="symbol">\]</span><span class="symbol">\.</span>,;:<span class="symbol">\s</span>@<span class="symbol">\"</span>]+)*)|(<span class="symbol">\"</span>.+<span class="symbol">\"</span>))@(([^&lt;&gt;()[<span class="symbol">\]</span><span class="symbol">\.</span>,;:<span class="symbol">\s</span>@<span class="symbol">\"</span>]+<span class="symbol">\.</span>)+[^&lt;&gt;()[<span class="symbol">\]</span><span class="symbol">\.</span>,;:<span class="symbol">\s</span>@<span class="symbol">\"</span>]&#123;2,&#125;)$/i;</span><br><span class="line"></span><br><span class="line">    if (!re.test(value)) &#123;</span><br><span class="line">      el.className = 'form-control is-invalid'</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      el.className = 'form-control is-valid'</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  bind: function (el, binding, vnode) &#123;</span><br><span class="line">    // 鉤子函式通常帶入的參數就這三個</span><br><span class="line">    el.className = 'form-control';</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>表單驗證，完成～</p>
<h3 id="用自訂指令傳入資料"><a href="#用自訂指令傳入資料" class="headerlink" title="用自訂指令傳入資料"></a>用自訂指令傳入資料</h3><p><code>v-directive</code> 可以傳入<strong>物件</strong>，冒號左邊是屬性，右邊是屬性對應的值。</p>
<p>上一段範例中，<code>.form-control</code> 是寫在 <code>directive</code> 中，但其實它可以用這個方式動態傳入 <code>className</code>。</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">v-validation</span>=<span class="string">"&#123; className: 'form-control' &#125;"</span></span><br></pre></td></tr></table></figure>

<p>接著鉤子函式的 <code>binding</code> 參數就會接收到透過 <code>v-validation</code> 傳入的值（存放在 <code>binding</code> 物件中的 <code>value</code> 特性裡）。</p>
<p>以這邊的例子來說，就是在 <code>binding.value</code> 中可以找到 <code>className: &#39;form-control&#39;</code>。然後我們再把它指定給 <code>el.className</code>，如此一來 DOM 就會被加上 <code>.form-control</code>。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">Vue.directive(<span class="string">'validation'</span>, &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">bind</span>: <span class="function"><span class="keyword">function</span><span class="params">(el, binding, vnode)</span></span> &#123;</span><br><span class="line">    el.className = binding.<span class="keyword">value</span>.className;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="不知道-v-model-對應的-data-特性時"><a href="#不知道-v-model-對應的-data-特性時" class="headerlink" title="不知道 v-model 對應的 data 特性時"></a>不知道 v-model 對應的 data 特性時</h3><p>首先，我們要做的是找出 DOM 所綁定的 <code>v-model</code> 對應哪個 <code>data</code> 特性。關於 Vue 的指令會放在 <code>vnode.data.directives</code> 裡面，而 <code>v-model</code> 的名稱則是放在 <code>vnode.data.directives[i].expression</code>。</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以下內容是寫在 bind() 裡</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在有關 Vue 的指令中尋找 v-model 指令</span></span><br><span class="line"><span class="keyword">var</span> currentModel = vnode.data.directives.find(<span class="function"><span class="keyword">function</span><span class="params">(item)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// find() 會回傳第一個符合條件的值</span></span><br><span class="line">  <span class="keyword">return</span> item.name === <span class="string">'model'</span>;</span><br><span class="line">&#125;).expression; <span class="comment">// 取得 v-model 對應的特性</span></span><br></pre></td></tr></table></figure>

<p>取得 <code>v-model</code> 對應的特性後，可以在 <code>vnode.context</code> 找到該特性的值。</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="keyword">value</span> = vnode.context[currentModel];</span><br><span class="line"><span class="comment">// 因為 v-model 的值不固定，所以用 [ ] 選取</span></span><br></pre></td></tr></table></figure>

<h2 id="使用外部載入套件"><a href="#使用外部載入套件" class="headerlink" title="使用外部載入套件"></a>使用外部載入套件</h2><p>BootstrapVue 是一個結合 Bootstrap 及 Vue.js 的套件（<a href="https://bootstrap-vue.js.org/" target="_blank" rel="external nofollow noopener noreferrer">官網</a>），可以用 CDN 的方式載入，也可以用 Webpack 載入。</p>
<p>如果使用 Vue Cli 就要使用 Webpack 載入方式：</p>
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CLI 版本請加入以下套用 BootstrapVue</span></span><br><span class="line"><span class="keyword">import</span> BootstrapVue <span class="keyword">from</span> <span class="string">'bootstrap-vue'</span>;</span><br><span class="line">Vue.use(BootstrapVue);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Vuejs</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>[Vue] Vue 元件 - 製作空污城市關注網頁</title>
    <url>/Vuejs/20191222/3102883103/</url>
    <content><![CDATA[<p>大家還記得元件系列第一篇筆記中，提到的 Demo 嗎？<br>本篇筆記要帶領大家回顧元件系列中所有的觀念，一步一步拆解這個 Demo 該如何製作！</p>
<a id="more"></a>

<p>首先先把成品放在最前面供參：</p>
<iframe src="https://codepen.io/gretema/embed/YzzjMxN?height=265&theme-id=default&default-tab=js,result" width="100%" height="300" frameborder="0" loading="lazy" allowfullscreen></iframe>

<h2 id="功能一：用-lt-select-gt-篩選特定縣市的測站"><a href="#功能一：用-lt-select-gt-篩選特定縣市的測站" class="headerlink" title="功能一：用 &lt;select&gt; 篩選特定縣市的測站"></a>功能一：用 <code>&lt;select&gt;</code> 篩選特定縣市的測站</h2><h3 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h3><ol>
<li><code>&lt;select&gt;</code> 用 <code>v-model</code> 綁定根實例的 <code>filter</code> 特性</li>
<li><code>&lt;option&gt;</code> 用 <code>v-for=&quot;county in location&quot;</code> + <code>:value=&quot;county&quot;</code> 渲染</li>
<li>元件模板：寫在 <code>.app</code> 外面，用 <code>&lt;script type=&quot;text/x-template&quot;&gt;</code> 製作</li>
<li>元件置入的地方：這次是用 Bootstrap 卡片元件來製作，所以元件模板置入的地方就在 <code>.card-columns</code> 裡面</li>
<li>元件：用 <code>v-for</code> 渲染所有城市，並且在這裡進行內外層資料傳遞 (外傳內 -&gt; 所有城市資料) (內傳外 -&gt; 關注的城市)</li>
</ol>
<h3 id="Vue-根實例"><a href="#Vue-根實例" class="headerlink" title="Vue 根實例"></a>Vue 根實例</h3><ol>
<li>AJAX 取得資料，篩選出所有縣市並存到 <code>data</code></li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">"#app"</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    data: [],</span><br><span class="line">    location: [], <span class="comment">// 從 AJAX 取回來的資料中篩選不重複的縣市</span></span><br><span class="line">    stared: [],</span><br><span class="line">    filter: <span class="string">""</span> <span class="comment">// select 選擇的城市會存在這裡</span></span><br><span class="line">  &#125;,</span><br><span class="line">  created: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.getData();</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    getData() &#123;</span><br><span class="line">      <span class="keyword">const</span> vm = <span class="keyword">this</span>;</span><br><span class="line">      <span class="keyword">const</span> api =</span><br><span class="line">        <span class="string">"https://cors-anywhere.herokuapp.com/http://opendata2.epa.gov.tw/AQI.json"</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 使用 jQuery ajax</span></span><br><span class="line">      $.<span class="keyword">get</span>(api).then(function(response) &#123;</span><br><span class="line">        vm.data = response;</span><br><span class="line">        <span class="comment">//console.log(response);</span></span><br><span class="line">        <span class="comment">// 取出所有測站的所在縣市</span></span><br><span class="line">        <span class="keyword">const</span> siteCounty = [];</span><br><span class="line">        vm.data.forEach(<span class="function"><span class="params">item</span> =&gt;</span> siteCounty.push(item.County));</span><br><span class="line">        <span class="comment">// 篩選不重複的城市</span></span><br><span class="line">        vm.location = siteCounty.filter(</span><br><span class="line">          (element, index, array) =&gt; array.indexOf(element) === index</span><br><span class="line">        );</span><br><span class="line">        <span class="comment">// 陣列中第一個符合條件的索引等於本身索引的元素才會被回傳</span></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><code>&lt;select&gt;</code> 選出縣市後，顯示符合條件的測站<br>在 <code>computed</code> 中，用 <code>if</code> 判斷 <code>&lt;select&gt;</code> 是否有選擇特定縣市，沒選的話就呈現所有測站資料。以及用 <code>filter()</code> 過濾根實例的 <code>data</code>，篩選出符合條件（縣市）的測站</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  filterData: function () &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.filter == <span class="string">''</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.<span class="keyword">data</span>;</span><br><span class="line">      <span class="comment">// 如果沒有選擇縣市，就顯示所有測站</span></span><br><span class="line">    &#125;</span><br><span class="line">    let filtered = <span class="keyword">this</span>.<span class="keyword">data</span>.filter((item) =&gt; &#123;</span><br><span class="line">      <span class="keyword">return</span> item.County == <span class="keyword">this</span>.filter;</span><br><span class="line">      <span class="comment">// 從所有測站中，找出所在縣市與 select 相同的測站</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> filtered; <span class="comment">// 回傳一個陣列</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Vue-元件"><a href="#Vue-元件" class="headerlink" title="Vue 元件"></a>Vue 元件</h3><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">Vue</span><span class="selector-class">.component</span>(<span class="string">'card-component'</span>, &#123;</span><br><span class="line">  <span class="attribute">props</span>: [<span class="string">'cardData'</span>], <span class="comment">// 接收根實例的 data 資料</span></span><br><span class="line">  <span class="attribute">template</span>: <span class="string">'#cardTemplate'</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="功能二：點擊星星設為關注城市，且設定-localStorage"><a href="#功能二：點擊星星設為關注城市，且設定-localStorage" class="headerlink" title="功能二：點擊星星設為關注城市，且設定 localStorage"></a>功能二：點擊星星設為關注城市，且設定 localStorage</h2><p>星星按鈕是位於元件中的元素，所以就要用到 <code>$emit</code> 把內層資料傳到外層。</p>
<h3 id="HTML-1"><a href="#HTML-1" class="headerlink" title="HTML"></a>HTML</h3><ol>
<li>元件模板：星星按鈕為用 <code>&lt;a&gt;</code> 包住的 fontawesome icon，在 <code>&lt;a&gt;</code> 加上 <code>click</code> 事件且綁定至元件的 <code>methods</code>（用 <code>emit</code> 傳遞資料）；在 <code>&lt;i&gt;</code> 上用 <code>v-bind</code> 綁定 <code>className</code> 切換（切換星星點擊後的樣式）。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;a href=<span class="string">"#"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"float-right"</span> @click.prevent=<span class="string">"clickStar"</span>&gt;</span><br><span class="line">  &lt;i :<span class="class"><span class="keyword">class</span></span>=<span class="string">"starStyle"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span></span><br><span class="line">&lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp">&lt;!--clickStar 是元件的 method, 用 $emit 傳到外層--&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>元件：加入 <code>:star=&quot;stared&quot;</code> 跟 <code>@change-stared=&quot;setStar&quot;</code>。前者是用於 localStorage 紀錄已關注的測站，後者是要配合 <code>emit</code> 從元件傳資料到根實例。</li>
<li>元件 2：在「關注城市」的欄位下，貼上同一個元件，只需要把 <code>v-for</code> 的來源陣列改成 <code>staredData</code> 就好。</li>
</ol>
<h3 id="Vue-元件-1"><a href="#Vue-元件-1" class="headerlink" title="Vue 元件"></a>Vue 元件</h3><ol>
<li>在 <code>props</code> 中加入 <code>star</code>，接收根實例的 localStorage 資料。</li>
<li>在 <code>methods</code> 中寫一個 function，把星星被點擊的測站送進根實例的 <code>methods</code>。</li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">methods</span>: &#123;</span><br><span class="line">  <span class="attribute">clickStar</span>: <span class="built_in">function</span>()&#123;</span><br><span class="line">    this.$<span class="built_in">emit</span>(<span class="string">'change-stared'</span>, this.cardData.SiteName);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>在 <code>computed</code> 中新增 <code>starStyle()</code>，點選的城市不存在關注中時，星星為實心；已存在時，空心。</li>
</ol>
<h3 id="Vue-根實例-1"><a href="#Vue-根實例-1" class="headerlink" title="Vue 根實例"></a>Vue 根實例</h3><ol>
<li>在 <code>data.stared</code> 中取出 localStorage 紀錄</li>
</ol>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">stared: <span class="module-access"><span class="module"><span class="identifier">JSON</span>.</span></span>parse(localStorage.get<span class="constructor">Item('<span class="params">staredSites</span>')</span>)<span class="operator"> || </span><span class="literal">[]</span>,</span><br><span class="line"><span class="comment">// staredSites 從 setStar 傳入，會再傳到元件去用</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在 <code>methods</code> 中新增 <code>setStar()</code>，接收 <code>$emit</code> 傳遞被點擊的城市名稱，並判斷是否存在 <code>stared</code> 陣列中</li>
<li>在 <code>computed</code> 中新增 <code>staredData()</code>，從 <code>data</code> 中找出已存在於 <code>this.stared</code> 的測站</li>
</ol>
<h2 id="功能三：依據汙染程度呈現不同顏色"><a href="#功能三：依據汙染程度呈現不同顏色" class="headerlink" title="功能三：依據汙染程度呈現不同顏色"></a>功能三：依據汙染程度呈現不同顏色</h2><p>在 CSS 中事先寫好不同汙染程度對應的 <code>class</code>，每個 <code>class</code> 都設定不同的背景顏色，等一下要把這些 <code>class</code> 套用到卡片上。</p>
<h3 id="HTML-2"><a href="#HTML-2" class="headerlink" title="HTML"></a>HTML</h3><ol>
<li>元件模板：在 <code>.card</code> 上用 <code>v-bind</code> 切換 <code>className</code>，<code>:class=&quot;airColor&quot;</code>。</li>
</ol>
<h3 id="Vue-元件-2"><a href="#Vue-元件-2" class="headerlink" title="Vue 元件"></a>Vue 元件</h3><p>在 <code>computed</code> 新增 <code>airColor()</code>，用 <code>switch</code> 判斷汙染等級的顏色。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">airColor: function()&#123;</span><br><span class="line">  let status = <span class="keyword">this</span>.cardData.Status;</span><br><span class="line">  switch (status) &#123;</span><br><span class="line">    case <span class="string">'普通'</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">'status-aqi2'</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    case <span class="string">'對敏感族群不健康'</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">'status-aqi3'</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    case <span class="string">'對所有族群不健康'</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">'status-aqi4'</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    case <span class="string">'非常不健康'</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">'status-aqi5'</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    case <span class="string">'危害'</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">'status-aqi6'</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Vuejs</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Vue元件</tag>
        <tag>AJAX</tag>
      </tags>
  </entry>
  <entry>
    <title>[Vue] Vue 元件 - 動態切換元件</title>
    <url>/Vuejs/20191222/2039005974/</url>
    <content><![CDATA[<p>使用 <code>is</code> 屬性可以在保留語意化的 HTML 標籤的同時，也達成與元件標籤一樣的效果，更有用的是，使用 <code>v-bind:is</code> 可以動態切換不同的元件。</p>
<a id="more"></a>

<h2 id="使用-is-顯示單一元件"><a href="#使用-is-顯示單一元件" class="headerlink" title="使用 is 顯示單一元件"></a>使用 is 顯示單一元件</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">// HTML</span><br><span class="line"><span class="comment">&lt;!--以下兩種寫法效果一樣--&gt;</span></span><br><span class="line">// 使用元件標籤</span><br><span class="line"><span class="tag">&lt;<span class="name">primary-component</span> <span class="attr">:data</span>=<span class="string">"item"</span>&gt;</span><span class="tag">&lt;/<span class="name">primary-component</span>&gt;</span></span><br><span class="line">// 使用 is 屬性</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">is</span>=<span class="string">"primary-component"</span> <span class="attr">:data</span>=<span class="string">"item"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="使用-is-動態切換元件"><a href="#使用-is-動態切換元件" class="headerlink" title="使用 is 動態切換元件"></a>使用 is 動態切換元件</h2><p>以套用 Bootstrap 的頁籤為例，點擊頁籤可以在兩個頁面之間切換（頁面由元件 <code>primary-component</code> 及 <code>danger-component</code> 製作）。</p>
<p>頁籤對應的頁面區塊，可以不需要使用「插入元件 + <code>v-if</code>」來切換頁面。</p>
<p>取而代之的是：使用一個 <code>&lt;div&gt;</code> + <code>v-bind:is</code> + 控制當前頁籤的變數（<code>current</code>）+ 頁面資料內容（<code>:data=&quot;item&quot;</code>）來達成動態切換的效果。</p>
<figure class="highlight dust"><table><tr><td class="code"><pre><span class="line"><span class="xml">// HTML</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"nav nav-pills"</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="comment">&lt;!-- 用 @click 切換 current 的值 --&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"nav-item"</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"nav-link"</span></span></span></span><br><span class="line"><span class="xml">       :class="</span><span class="template-variable">&#123;'active': current == 'primary-component'&#125;</span><span class="xml">"</span></span><br><span class="line"><span class="xml">       href="#" @click.prevent="current = 'primary-component'"&gt;</span></span><br><span class="line"><span class="xml">       藍綠色元件</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"nav-item"</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"nav-link"</span></span></span></span><br><span class="line"><span class="xml">       :class="</span><span class="template-variable">&#123;'active': current == 'danger-component'&#125;</span><span class="xml">"</span></span><br><span class="line"><span class="xml">       href="#" @click.prevent="current = 'danger-component'"&gt;</span></span><br><span class="line"><span class="xml">       紅色元件</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"mt-3"</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="comment">&lt;!-- 動態切換元件 --&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">:is</span>=<span class="string">"current"</span> <span class="attr">:data</span>=<span class="string">"item"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 省略元件及模板的程式碼</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Vue 根實例</span></span><br><span class="line"><span class="built_in">var</span> app = <span class="literal">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  <span class="built_in">data</span>: &#123;</span><br><span class="line">    item: &#123;</span><br><span class="line">      <span class="keyword">header</span>: <span class="string">'這裡是 header'</span>,</span><br><span class="line">      title: <span class="string">'這裡是 title'</span>,</span><br><span class="line">      text: <span class="string">'...'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    current: <span class="string">'primary-component'</span>  <span class="comment">// 當前頁籤</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Vuejs</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Vue元件</tag>
        <tag>is屬性</tag>
      </tags>
  </entry>
  <entry>
    <title>[Vue] Vue 元件 - 插槽篇</title>
    <url>/Vuejs/20191221/4254408561/</url>
    <content><![CDATA[<p>使用元件的目的是為了同樣結構的重複使用，但有時我們會需要對元件內容作調整，這時就可以使用插槽來做調整。</p>
<a id="more"></a>

<h2 id="單一插槽"><a href="#單一插槽" class="headerlink" title="單一插槽"></a>單一插槽</h2><p>當只有一個地方需要修改內容時，使用單一插槽即可。</p>
<p>在模板中用 <code>&lt;slot&gt;</code> 標籤預留一個空間，用來存放等一下在 HTML 中要新增的內容。</p>
<p>如果希望元件有預設的內容，寫在 <code>&lt;slot&gt;</code> 標籤中即可，如果 HTML 沒有新增的內容，則 <code>&lt;slot&gt;</code> 中的預設內容就會顯示，反之則會被新的內容取代。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 元件</span></span><br><span class="line">Vue.component(<span class="string">'single-slot-component'</span>, &#123;</span><br><span class="line">  template: <span class="string">'#singleSlotComponent'</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// x-template 模板</span></span><br><span class="line">&lt;script type=<span class="string">"text/x-template"</span> id=<span class="string">"singleSlotComponent"</span>&gt;</span><br><span class="line">  &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"alert alert-warning"</span>&gt;</span><br><span class="line">    &lt;h6&gt;我是一個元件&lt;<span class="regexp">/h6&gt;</span></span><br><span class="line"><span class="regexp">    &lt;slot&gt;</span></span><br><span class="line"><span class="regexp">        如果沒有內容，則會顯示此段落。</span></span><br><span class="line"><span class="regexp">    &lt;/</span>slot&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// HTML</span></span><br><span class="line"></span><br><span class="line">&lt;!--內容需要替換的元件--&gt;</span><br><span class="line">&lt;single-slot-component&gt;</span><br><span class="line">  &lt;p&gt;使用這段取代原本的 Slot。&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>single-slot-component&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--不需要替換內容的元件--&gt;</span><br><span class="line">&lt;single-slot-component&gt; <span class="xml"><span class="tag">&lt;/<span class="name">single-slot-component</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h2 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h2><p>如果有多處內容需要替換，就需要搭配使用 <code>&lt;slot&gt;</code> 及 <code>name</code> 屬性，來綁定模板及要更換內容的 HTML 元素。</p>
<p>在元件模板中定義好插槽位置與自訂的 <code>name</code> 後，在 HTML 中就可以使用 <code>&lt;template&gt;</code> 元素 + <code>v-slot</code> 指令 + 插槽的 <code>name</code>，來達成數個地方的內容替換了。</p>
<p>注意，<code>v-slot</code> 只能用於 <code>&lt;template&gt;</code> 元素。</p>
<p><code>&lt;template&gt;</code> 跟 <code>&lt;slot&gt;</code> 標籤在 HTML 中都不會被輸出，它們兩個的用途是互相配對，代表這個地方需要在 HTML 中替換成新的內容。<code>&lt;slot&gt;</code> 放置位置在元件模板中，<code>&lt;template&gt;</code> 放置位置在 HTML 中。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 元件的模板</span></span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"container"</span>&gt;</span><br><span class="line">  &lt;header&gt;</span><br><span class="line">    &lt;slot name=<span class="string">"header"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span></span><br><span class="line">  &lt;<span class="regexp">/header&gt;</span></span><br><span class="line"><span class="regexp">  &lt;main&gt;</span></span><br><span class="line"><span class="regexp">    &lt;slot&gt;&lt;/</span>slot&gt;</span><br><span class="line">  &lt;<span class="regexp">/main&gt;</span></span><br><span class="line"><span class="regexp">  &lt;footer&gt;</span></span><br><span class="line"><span class="regexp">    &lt;slot name="footer"&gt;&lt;/</span>slot&gt;</span><br><span class="line">  &lt;<span class="regexp">/footer&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HTML</span></span><br><span class="line">&lt;base-layout&gt;</span><br><span class="line">  &lt;template v-slot:header&gt;</span><br><span class="line">    &lt;h1&gt;Here might be a page title&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">  &lt;p&gt;A paragraph <span class="keyword">for</span> the main content.&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">  &lt;p&gt;And another one.&lt;/</span>p&gt;</span><br><span class="line"></span><br><span class="line">  &lt;template v-slot:footer&gt;</span><br><span class="line">    &lt;p&gt;Here<span class="string">'s some contact info&lt;/p&gt;</span></span><br><span class="line"><span class="string">  &lt;/template&gt;</span></span><br><span class="line"><span class="string">&lt;/base-layout&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Vuejs</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Vue元件</tag>
      </tags>
  </entry>
  <entry>
    <title>[Vue] Vue 元件 - emit 篇</title>
    <url>/Vuejs/20191220/2032442117/</url>
    <content><![CDATA[<p>如何從元件傳遞資料到根實例？本篇筆記告訴你～</p>
<a id="more"></a>

<h2 id="emit-向外層傳遞事件"><a href="#emit-向外層傳遞事件" class="headerlink" title="$emit 向外層傳遞事件"></a>$emit 向外層傳遞事件</h2><p><code>$emit</code> 除了可以傳遞事件外，也可以傳遞參數。</p>
<h3 id="emit-基本用法："><a href="#emit-基本用法：" class="headerlink" title="$emit() 基本用法："></a>$emit() 基本用法：</h3><p>在元件標籤上設定 <code>v-on:自訂事件名 = &quot;Vue 根實例的 method&quot;</code>，這表示元件內的事件發生後將會觸發 Vue 根實例的方法，內層元件就是透過這種方式傳送到外層。</p>
<figure class="highlight hsp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HTML</span></span><br><span class="line">&lt;<span class="keyword">button</span>-counter v-<span class="keyword">on</span>:increment=<span class="string">"incrementTotal"</span>&gt;&lt;/<span class="keyword">button</span>-counter&gt;</span><br></pre></td></tr></table></figure>

<p>元件的 <code>template</code> 中，要在 HTML 元素上綁定一個事件，以下面這個範例為例：發生 <code>click</code> 事件後要觸發 <code>incrementCounter</code> 函式，而這個函式是元件中的一個 <code>method</code>。在這個 <code>method</code> 裡面要用 <code>$emit</code> 觸發與 Vue 根實例綁定的事件，所以 <code>$emit()</code> 小括號內要寫入的是在元件標籤上設定的<strong>自訂事件名</strong>。</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 元件</span></span><br><span class="line">Vue.component(<span class="string">'buttonCounter'</span>, &#123;</span><br><span class="line">  template:`</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;button @click=<span class="string">"incrementCounter"</span>&gt;增加 &#123;&#123; counter &#125;&#125; 元&lt;/button&gt;</span><br><span class="line">      &lt;input type=<span class="string">"number"</span> v-model=<span class="string">"counter"</span>&gt;</span><br><span class="line">    &lt;/div&gt;`,</span><br><span class="line">  data: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      counter: <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    incrementCounter: <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.$emit(<span class="string">'increment'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>Vue 根實例中的 <code>incrementTotal</code> 方法，就是剛剛在元件上<strong>與自訂事件綁定的函式</strong>。</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Vue 根實例</span></span><br><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    cash: <span class="number">300</span></span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    incrementTotal: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 每按一下按鈕，cash 數字就加 1</span></span><br><span class="line">      <span class="keyword">this</span>.cash++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="使用-emit-與其參數："><a href="#使用-emit-與其參數：" class="headerlink" title="使用 $emit() 與其參數："></a>使用 $emit() 與其參數：</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 元件</span></span><br><span class="line">Vue.component(<span class="string">'buttonCouter'</span>, &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  methods: &#123;</span><br><span class="line">    incrementCounter: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.$emit(<span class="string">'increment'</span>, <span class="built_in">Number</span>(<span class="keyword">this</span>.counter));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Vue 根實例</span></span><br><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  methods: &#123;</span><br><span class="line">    incrementTotal: <span class="function"><span class="keyword">function</span>(<span class="params">newCount</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 用 newCount 參數接收元件傳來的 this.counter 值</span></span><br><span class="line">      <span class="keyword">this</span>.cash = <span class="keyword">this</span>.cash + newCount;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><ol>
<li><code>$emit()</code> 第一個參數是自訂事件名稱，當元件發生一個事件時，把這個事件傳到根實例的 <code>methods</code> 去進行運算。</li>
<li><code>$emit()</code> 第二個參數是元件的資料屬性，把專屬於這個元件的資料傳到根實例的 <code>methods</code> 去進行運算。</li>
<li>元件模板中所綁定的，都是該元件獨有的資料、<code>methods</code>。</li>
<li>HTML 中的元件標籤則是元件資料與根實例資料<strong>互相綁定</strong>的場所。</li>
</ol>
]]></content>
      <categories>
        <category>Vuejs</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>$emit()</tag>
      </tags>
  </entry>
  <entry>
    <title>[Vue] Vue 元件 - props 篇</title>
    <url>/Vuejs/20191220/3720178681/</url>
    <content><![CDATA[<p>上一篇我們提到，要從根實例傳資料到元件裡，需要使用 <code>props</code> 特性來傳遞，今天這篇筆記會談談 <code>props</code> 如何實際使用。</p>
<a id="more"></a>

<h2 id="在-HTML-放入元件"><a href="#在-HTML-放入元件" class="headerlink" title="在 HTML 放入元件"></a>在 HTML 放入元件</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>靜態傳遞<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">photo</span>&gt;</span><span class="tag">&lt;/<span class="name">photo</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>動態傳遞<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">photo</span>&gt;</span><span class="tag">&lt;/<span class="name">photo</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="定義元件模板"><a href="#定義元件模板" class="headerlink" title="定義元件模板"></a>定義元件模板</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/x-template"</span> <span class="attr">id</span>=<span class="string">"photo"</span>&gt;</span></span><br><span class="line"><span class="handlebars"><span class="xml">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span></span><br><span class="line"><span class="javascript">    &lt;img :scr=<span class="string">"imgUrl"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"img-fluid"</span> alt=<span class="string">""</span> /&gt;</span></span><br><span class="line"><span class="handlebars"><span class="xml">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>風景照<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="宣告-Vue-根實例"><a href="#宣告-Vue-根實例" class="headerlink" title="宣告 Vue 根實例"></a>宣告 Vue 根實例</h2><figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line"><span class="built_in">var</span> app = <span class="literal">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  <span class="built_in">data</span>: &#123;</span><br><span class="line">    url: <span class="string">'一個圖片網址'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="在-Vue-根實例上方宣告一個元件"><a href="#在-Vue-根實例上方宣告一個元件" class="headerlink" title="在 Vue 根實例上方宣告一個元件"></a>在 Vue 根實例上方宣告一個元件</h2><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">Vue</span><span class="selector-class">.component</span>(<span class="string">'自定義元件名稱'</span>,&#123;</span><br><span class="line">  <span class="attribute">template</span>: <span class="string">'# template 的 id 名稱'</span>,</span><br><span class="line">  <span class="attribute">props</span>: [<span class="string">'取得 data 資料的屬性名'</span>]</span><br><span class="line">  <span class="comment">// 之後要用這裡的資料屬性名稱在 HTML 上設定 v-bind，就能得到上層的資料</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 範例</span></span><br><span class="line"><span class="selector-tag">Vue</span><span class="selector-class">.component</span>(<span class="string">'photo'</span>,&#123;</span><br><span class="line">  <span class="attribute">props</span>: [<span class="string">'imgUrl'</span>],</span><br><span class="line">  <span class="attribute">template</span>: <span class="string">'#photo'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>接下來傳遞資料的方式可以選擇靜態傳遞或動態傳遞。</p>
<h2 id="靜態與動態傳入數值差異"><a href="#靜態與動態傳入數值差異" class="headerlink" title="靜態與動態傳入數值差異"></a>靜態與動態傳入數值差異</h2><p>加在 HTML 標籤上的屬性可以分為靜態跟動態兩種，沒有設定 <code>v-bind</code> 的屬性為靜態，有設定 <code>v-bind</code> 的屬性為動態。</p>
<p>靜態屬性的值一律會轉為字串型別，動態屬性的值則不一定是字串。</p>
<h3 id="靜態傳遞"><a href="#靜態傳遞" class="headerlink" title="靜態傳遞"></a>靜態傳遞</h3><p><code>&lt;photo img-url=&quot;圖片的網址&quot;&gt;&lt;/photo&gt;</code><br>原本在元件內的 <code>props</code> 值為 <code>imgUrl</code>，放到 HTML 中時要把駝峰改成 <code>-</code> 。<br><code>img-url</code>的值（圖片網址）會透過 <code>x-template</code> 中 <code>:src=&quot;imgUrl&quot;</code> 而跑到元件 <code>props</code> 裡。</p>
<h3 id="動態傳遞"><a href="#動態傳遞" class="headerlink" title="動態傳遞"></a>動態傳遞</h3><p><code>&lt;photo :img-url=&quot;url&quot;&gt;&lt;/photo&gt;</code><br>這裡的 <code>url</code> 作為與元件 <code>props</code> <code>imgUrl</code> 綁定的值，同時代表的是根實例 <code>data</code> 物件中的 <code>url</code> 特性，因此會把 <code>url</code> 中的圖片網址帶進 <code>props</code> 裡面。</p>
<h2 id="props-圖解"><a href="#props-圖解" class="headerlink" title="props 圖解"></a>props 圖解</h2><p><img src="https://i.imgur.com/w36W7L2.png" alt="這張圖屬於建良"></p>
<h2 id="props-使用注意事項"><a href="#props-使用注意事項" class="headerlink" title="props 使用注意事項"></a>props 使用注意事項</h2><h3 id="1-單向數據流"><a href="#1-單向數據流" class="headerlink" title="1. 單向數據流"></a>1. 單向數據流</h3><p>像上面這樣使用 <code>v-bind</code> 綁定 <code>props</code>，並傳入 Vue 實例的 <code>data</code> 資料，如果又在 DOM 運用 <code>props</code> 屬性建立 <code>v-model</code> 會形成一個問題，就是當使用者從畫面上修改資料時，會去動到根實例的 <code>data</code> ，但這樣是不合規範的，所以會跳錯。</p>
<p>解決辦法是在<strong>元件</strong>中新增 <code>data</code> 特性，對應一個 function，並在裡面 <code>return</code> 新的特性，當作<u>與畫面雙向綁定的標的</u>，這樣就不會跳錯了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// JS</span></span><br><span class="line">Vue.component(<span class="string">'photo'</span>, &#123;</span><br><span class="line">  props: [<span class="string">'imgUrl'</span>],</span><br><span class="line">  template: <span class="string">'#photo'</span>,</span><br><span class="line">  data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">       newUrl: <span class="keyword">this</span>.imgUrl</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// HTML</span></span><br><span class="line">&lt;script type=<span class="string">"text/x-template"</span> id=<span class="string">"photo"</span>&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;img :src=<span class="string">"imgUrl"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"img-fluid"</span> alt=<span class="string">""</span> /&gt;</span><br><span class="line">  &lt;input type=<span class="string">"text"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"form-control"</span> v-model=<span class="string">"newUrl"</span>&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure>
<p><code>newUrl</code> 的值有兩個角色，第一個是接收 <code>props</code> 傳入的資料，第二個是放在元件模板中設定 <code>v-model</code>，使用 <code>newUrl</code> 來與畫面做雙向綁定，就能把 <code>props</code> 資料與 Vue 實例的 <code>data</code> 做隔離。</p>
<h3 id="2-尚未宣告的變數"><a href="#2-尚未宣告的變數" class="headerlink" title="2. 尚未宣告的變數"></a>2. 尚未宣告的變數</h3><p>當我們在根實例 <code>data</code> 物件新增空的物件，並希望透過 AJAX 推資料進去這個空物件時，元件渲染會發生在 AJAX 資料推進來之前，就會造成抓不到資料而跳錯。</p>
<p>解決方法是使用 <code>v-if=&quot;AJAX 傳入的資料特性&quot;</code>，確保 AJAX 取得資料後，才渲染元件；在資料尚未取得前，元件都不會顯示。</p>
<p>範例：<br><code>&lt;card :user-data=&quot;user&quot; v-if=&quot;user.phone&quot;&gt;&lt;/card&gt;</code></p>
<p><code>v-if</code> 裡對應的值可以是 AJAX 資料中隨便一個資料特性，這邊的 <code>user</code> 指的是一開始就宣告的空物件名稱。</p>
<h3 id="3-物件透過參考的方式傳遞資料"><a href="#3-物件透過參考的方式傳遞資料" class="headerlink" title="3. 物件透過參考的方式傳遞資料"></a>3. 物件透過參考的方式傳遞資料</h3><p>在 JavaScript 中，當我們宣告一個變數並賦予它一個新的物件時，記憶體的某處也會建立起一個物件，然後把剛剛的變數指向新生成的物件。</p>
<p>接著，如果我們又宣告第二個變數，並將這個變數指向第一個變數的話，當我們更新第一個變數裡的特性值，第二個變數的內容也會隨之更新。</p>
<p>也就是說，兩個變數都是指向同一個實體。</p>
<p>所以，當我們在畫面上修改資料，會更改到 <code>props</code> 的值，甚至連 Vue 實例的 <code>data</code> 物件也會跟著被改變。</p>
<p>那為何單向數據流無法像這樣傳遞呢？因為單向數據流傳遞的是<strong>一般字串</strong>，所以<u>無法像物件這樣傳遞參考的特性</u>。如果沒有修改物件的特性，都還是維持單向數據流的概念。</p>
<h3 id="4-維持狀態與生命週期"><a href="#4-維持狀態與生命週期" class="headerlink" title="4. 維持狀態與生命週期"></a>4. 維持狀態與生命週期</h3><p>如果不希望元件每次都重新生成，或是元件內的內容是由 AJAX 而來，而你不希望每次重整，元件都接收到不一樣的內容的話，就可以使用 <code>&lt;keep-alive&gt;</code> 標籤包住元件，這樣就能維持元件的狀態了。</p>
<h2 id="props-值的型別"><a href="#props-值的型別" class="headerlink" title="props 值的型別"></a>props 值的型別</h2><p>預先定義 <code>props</code> 應該傳入哪種型別的資料，避免傳入錯誤的資料。</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原本是這樣寫</span></span><br><span class="line"><span class="selector-tag">Vue</span><span class="selector-class">.component</span>(<span class="string">'prop-type'</span>, &#123;</span><br><span class="line">  <span class="attribute">props</span>: [<span class="string">'cash'</span>],</span><br><span class="line">  <span class="attribute">template</span>: <span class="string">'#propType'</span>,</span><br><span class="line">  <span class="attribute">data</span>: function() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      <span class="attribute">newCash</span>: this.cash</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 預先定義 props 值型別</span></span><br><span class="line"><span class="selector-tag">Vue</span><span class="selector-class">.component</span>(<span class="string">'prop-type'</span>, &#123;</span><br><span class="line">   <span class="attribute">props</span>: &#123;</span><br><span class="line">     <span class="attribute">cash</span>: &#123;</span><br><span class="line">       <span class="attribute">type</span>: Number,</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;,</span><br><span class="line">  <span class="attribute">template</span>: <span class="string">'#propType'</span>,</span><br><span class="line">  <span class="attribute">data</span>: function() &#123;</span><br><span class="line">    <span class="selector-tag">return</span> &#123;</span><br><span class="line">      <span class="attribute">newCash</span>: this.cash</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>有時候 <code>props</code> 不會接收到來自外部的值，但如果我們希望它帶有預設值，可以這樣做：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">props</span>: &#123;</span><br><span class="line">  <span class="attribute">cash</span>: &#123;</span><br><span class="line">    type: Number,</span><br><span class="line">    default: 預設值</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Vuejs</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Vue元件</tag>
      </tags>
  </entry>
  <entry>
    <title>[Vue] Vue 元件 - 基礎篇</title>
    <url>/Vuejs/20191219/714316638/</url>
    <content><![CDATA[<p>Vue 元件是運用 Vue 很核心的部分，此系列將會拆成 4~5 篇文 po 上來。<br>本篇會從元件的基礎開始，順便帶一些有 <code>props</code> 觀念的例子（但 <code>props</code> 的細節會寫在下一篇），最後會附上一個 Demo 供大家參考。</p>
<a id="more"></a>

<h2 id="元件的概念"><a href="#元件的概念" class="headerlink" title="元件的概念"></a>元件的概念</h2><p>網頁上不同的區塊可以由不同的元件組成，如果有重複出現的區塊，更可以利用元件來做。</p>
<p>各個元件的資料都是<strong>獨立</strong>的，如果需要流通各自的資料，有兩種型態：<code>props</code> 特性可以即時地將<strong>外層資料傳進內層</strong>，而<strong>內層資料傳到外層</strong>則要使用 <code>emit</code> 事件（需要透過觸發事件，才能傳遞資料）。</p>
<p>SPA 也是透過元件製作的（由前端模擬的路由）。</p>
<h2 id="使用-x-template-建立元件"><a href="#使用-x-template-建立元件" class="headerlink" title="使用 x-template 建立元件"></a>使用 <code>x-template</code> 建立元件</h2><ol>
<li><p>在 Vue 實例上方宣告一個元件</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">Vue</span><span class="selector-class">.component</span>(<span class="string">'自定義元件名稱'</span>,&#123;</span><br><span class="line">  <span class="attribute">template</span>: <span class="string">'# template 的 id 名稱'</span>,</span><br><span class="line">  <span class="attribute">props</span>: [<span class="string">'取得 data 資料的屬性名'</span>]</span><br><span class="line">  <span class="comment">// 取得 data 資料的屬性名: 自訂一個屬性名，並綁定 v-for 的 item 參數</span></span><br><span class="line">  <span class="comment">// 若用 v-bind 綁定 props，就能將 data 資料傳進元件</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 範例</span></span><br><span class="line"><span class="selector-tag">Vue</span><span class="selector-class">.component</span>(<span class="string">'row-component'</span>,&#123;</span><br><span class="line">  <span class="attribute">template</span>: <span class="string">'#rowComponentTemplate'</span>,</span><br><span class="line">  <span class="attribute">props</span>: [<span class="string">'person'</span>]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>另外宣告一個 <code>&lt;script&gt;</code>，且 <code>type</code> 屬性為 <code>text/x-template</code> 並賦予 <code>id</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/x-template"</span> <span class="attr">id</span>=<span class="string">"rowComponentTemplate"</span>&gt;</span></span><br><span class="line"><span class="handlebars"><span class="xml">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">    <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><span class="template-variable">&#123;&#123; person.name &#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">    <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><span class="template-variable">&#123;&#123; person.cash &#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">    <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><span class="template-variable">&#123;&#123; person.icash &#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在要插入元件的地方，使用 Vue 的 <code>is</code> 屬性來掛載元件，<code>is</code> 用來動態切換模板</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line">&lt;tbody&gt;</span><br><span class="line">  &lt;tr is=<span class="string">"row-component"</span> v-<span class="keyword">for</span>=<span class="string">"(item, key) in data"</span> <span class="symbol">:person=<span class="string">"item"</span></span> <span class="symbol">:key=<span class="string">"key"</span>&gt;&lt;/tr&gt;</span></span><br><span class="line">&lt;<span class="regexp">/tbody&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>:person=&quot;item&quot;</code> 的 <code>person</code> 指的是元件 <code>props</code> 中的屬性名稱，<code>item</code> 則是 <code>v-for=&quot;(item, key) in data&quot;</code> 的 <code>item</code>，且它連接的是根實例的資料。<br><img src="https://i.imgur.com/3PdZRAt.jpg" alt></p>
</li>
</ol>
<h3 id="另外一種寫法：局部註冊"><a href="#另外一種寫法：局部註冊" class="headerlink" title="另外一種寫法：局部註冊"></a>另外一種寫法：局部註冊</h3><figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原本的寫法是註冊在所有 Vue 的應用程式下</span></span><br><span class="line">Vue.component(<span class="string">'row-component'</span>,&#123;</span><br><span class="line">  template: <span class="string">'#rowComponentTemplate'</span>,</span><br><span class="line">  props: [<span class="string">'person'</span>]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 改寫為只有目前這個應用程式可以用</span></span><br><span class="line"><span class="keyword">var</span> child = &#123;</span><br><span class="line">  template: <span class="string">'#rowComponentTemplate'</span>,</span><br><span class="line">  props: [<span class="string">'person'</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在目前這個 Vue 實例下新增一個 <code>components</code> 特性（跟 <code>data</code> 物件同層），將元件註冊在這個特性裡：</p>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">components:</span> &#123;</span><br><span class="line">  <span class="string">"row-component"</span>: child</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="元件內的-data"><a href="#元件內的-data" class="headerlink" title="元件內的 data"></a>元件內的 data</h2><p>因為每個元件的 data 都是獨立的，所以都會有各自的資料狀態，當有需要使用，都需要獨立管理。但是要注意，在元件內使用 <code>data</code> 特性的時候，必須使用 <code>function</code> 來<code>return</code> 一個物件資料到 <code>data</code> 特性裡。</p>
<h2 id="運用元件製作關注空污城市的網頁"><a href="#運用元件製作關注空污城市的網頁" class="headerlink" title="運用元件製作關注空污城市的網頁"></a>運用元件製作關注空污城市的網頁</h2><p>當元件系列文結束後，就可以做出這個網頁了。</p>
<iframe src="https://codepen.io/gretema/embed/YzzjMxN?height=265&theme-id=default&default-tab=js,result" width="100%" height="300" frameborder="0" loading="lazy" allowfullscreen></iframe>]]></content>
      <categories>
        <category>Vuejs</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Vue元件</tag>
      </tags>
  </entry>
  <entry>
    <title>[Vue] Vue 生命週期</title>
    <url>/Vuejs/20191219/1844116139/</url>
    <content><![CDATA[<p>在學 Vue 的初期不知道生命週期其實也沒什麼關係，不過隨著越學越進階，還是應該了解一下相關的知識比較好。</p>
<a id="more"></a>

<h2 id="Vue-的生命週期"><a href="#Vue-的生命週期" class="headerlink" title="Vue 的生命週期"></a>Vue 的生命週期</h2><p>Vue 實例擁有一個完整的生命週期，過程中會執行一連串的工作，從開始「創建」、「初始化數據」、「Template 編譯模板」、「DOM 元素掛載」、「資料的渲染與更新」和「卸載」等過程，我們統稱為 Vue 實例的生命週期。<br><img src="https://i.imgur.com/UuiWUiH.png" alt="官方生命週期示意圖"></p>
<h2 id="在-HTML-寫好元件模板"><a href="#在-HTML-寫好元件模板" class="headerlink" title="在 HTML 寫好元件模板"></a>在 HTML 寫好元件模板</h2><p>在 HTML 中用 <code>x-template</code> 先寫好一個模板，並且用 <code>id</code> 與 Vue 元件模板做綁定。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/x-template"</span> <span class="attr">id</span>=<span class="string">"childarea"</span>&gt;</span></span><br><span class="line"><span class="handlebars"><span class="xml">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">    <span class="tag">&lt;<span class="name">h4</span>&gt;</span> Hello! </span><span class="template-variable">&#123;&#123; text &#125;&#125;</span><span class="xml"> <span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="Vue-元件與-hook"><a href="#Vue-元件與-hook" class="headerlink" title="Vue: 元件與 hook"></a>Vue: 元件與 hook</h2><h3 id="hook-是什麼"><a href="#hook-是什麼" class="headerlink" title="hook 是什麼"></a>hook 是什麼</h3><p>當 Vue 生命週期到特定的點的時候，就會觸發相對應的鉤子 (hook)。</p>
<p>較重要的 hook 有下列這些：</p>
<ul>
<li><code>beforeCreate()</code>: Vue 開始運行，但還沒讀到資料</li>
<li><code>created()</code>: 建立數據觀測，要進行 AJAX 至少從這一個階段開始</li>
<li><code>beforeMount()</code>: 準備開始編譯 Vue 的元件模板</li>
<li><code>mounted()</code>: 模板建立完成，已掛載到 HTML DOM，要操作 DOM 元素要從這裡開始</li>
<li><code>updated()</code>: 如果有用 <code>v-model</code> 的話，在網頁上更改資料就會連動到 Vue Model，此時這種更新資料的行為就會觸發這個 hook</li>
<li><code>activated()</code>: 使用 <code>&lt;keepalive&gt;</code> 的元件在渲染時觸發，下次再渲染時就會直接跳到這個 hook</li>
<li><code>deactivated()</code>: 使用 <code>&lt;keepalive&gt;</code> 的元件在取消渲染時觸發，有這個 hook 就不會觸發銷毀系列的 hook</li>
<li><code>beforeDestroy()</code>: 取消渲染元件時觸發 (例如用 <code>v-if</code> 控制渲染與否)</li>
<li><code>destroyed()</code>: 元件銷毀完畢，之後如果要再次渲染元件，就會從 creation 階段開始</li>
</ul>
<h3 id="在元件內設定-hook"><a href="#在元件內設定-hook" class="headerlink" title="在元件內設定 hook"></a>在元件內設定 hook</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Child = &#123;</span><br><span class="line">  template: <span class="string">'#childarea'</span>,</span><br><span class="line">  data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      text: <span class="string">'Vue data 資料狀態'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  beforeCreate () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`beforeCreate! <span class="subst">$&#123;<span class="keyword">this</span>.text&#125;</span>`</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  ... <span class="comment">// 以下依序為各個 hook</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue = &#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="mounted-之後才會正確顯示-DOM-與資料"><a href="#mounted-之後才會正確顯示-DOM-與資料" class="headerlink" title="mounted() 之後才會正確顯示 DOM 與資料"></a>mounted() 之後才會正確顯示 DOM 與資料</h3><p>在一開始的 <code>x-template</code> 模板裡面，我們寫了一個 <code>&lt;h4&gt;</code>，它的內容要到 <code>mounted()</code> 階段後才會正確顯示「Hello! Vue data 資料狀態」，因為此時元件 DOM 與資料才會完整掛載在 Vue 實例上。</p>
<h3 id="保留元件的資料狀態"><a href="#保留元件的資料狀態" class="headerlink" title="保留元件的資料狀態"></a>保留元件的資料狀態</h3><p>前面有提到，在一般情況下，取消渲染（銷毀）元件後如果要再次渲染，生命週期會從 <code>beforeCreate()</code> 重新開始。但在有些情況下，我們希望能在下次渲染時保留之前的資料狀態，此時我們可以用 <code>&lt;keepalive&gt;</code> 標籤包住元件，來維持它的生命週期。</p>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><a href="https://medium.com/pierceshih/vue-js-%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98-day14-vue%E7%94%9F%E5%91%BD%E9%80%B1%E6%9C%9F-65bc934dfd47" target="_blank" rel="external nofollow noopener noreferrer">「Vue.js 學習筆記 Day14」- Vue生命週期</a><br><a href="https://cn.vuejs.org/v2/guide/instance.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE%E7%A4%BA" target="_blank" rel="external nofollow noopener noreferrer">官方文件：生命周期图示</a></p>
]]></content>
      <categories>
        <category>Vuejs</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Vue生命週期</tag>
      </tags>
  </entry>
  <entry>
    <title>[Vue] 用 Vue 寫一個 todo-list</title>
    <url>/Vuejs/20191218/266480435/</url>
    <content><![CDATA[<p>運用已學到的基礎與進階指令，試著寫出一個 todo-list 待辦事項清單吧！</p>
<a id="more"></a>

<p>先附上成品 Demo，以下會一步步說明該如何實作一個 todo-list。</p>
<iframe src="https://codepen.io/gretema/embed/rNNzKQj?height=265&theme-id=default&default-tab=html,result" width="100%" height="300" frameborder="0" loading="lazy" allowfullscreen></iframe>

<h2 id="基本架構：輸入欄及待辦事項列表"><a href="#基本架構：輸入欄及待辦事項列表" class="headerlink" title="基本架構：輸入欄及待辦事項列表"></a>基本架構：輸入欄及待辦事項列表</h2><h3 id="HTML-部分"><a href="#HTML-部分" class="headerlink" title="HTML 部分"></a>HTML 部分</h3><ul>
<li>任務輸入欄：<code>v-model=&quot;newTodo&quot;</code></li>
<li>輸入按鈕：<code>@click=&quot;addTodo&quot;</code></li>
<li>渲染每項任務的 <code>&lt;li&gt;</code>：<code>v-for=&quot;items in todos&quot;</code>，<code>todos</code> 是一個陣列，用來儲存所有待辦事項</li>
<li><code>&lt;li&gt;</code> 裡面的 checkbox：checkbox 要用 <code>v-bind</code> 綁定 <code>todos</code> 中每個物件的 <code>id</code> 特性，<code>:id=&quot;item.id&quot;</code></li>
<li><code>&lt;li&gt;</code> 裡面的 label：要指向跟 checkbox 同樣的 <code>id</code>，所以要寫成 <code>:for=&quot;item.id&quot;</code>，<code>&lt;label&gt;</code> 中間用雙花括號包住 <code>item.title</code></li>
<li>任務的完成狀態：在 checkbox 使用 <code>v-model=&quot;item.completed&quot;</code></li>
<li>加上按鍵功能：為了讓按下 Enter 也能產生跟點擊一樣的效果，在 input 上綁定按鍵事件，<code>@keyup.enter=&quot;addTodo&quot;</code> </li>
</ul>
<h3 id="Vue-的-data-部分"><a href="#Vue-的-data-部分" class="headerlink" title="Vue 的 data 部分"></a>Vue 的 data 部分</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">newTodo:<span class="string">''</span>, <span class="comment">// 一個字串，對應到任務輸入欄</span></span><br><span class="line">todos: [] <span class="comment">// 一個陣列，用來儲存所有待辦事項，對應到 &lt;li&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// todos 陣列</span></span><br><span class="line"><span class="comment">// 裡面放物件，一個物件就代表一個任務，該物件會有以下的特性</span></span><br><span class="line">&#123;</span><br><span class="line">  id: <span class="string">''</span>,</span><br><span class="line">  title: <span class="string">''</span>,</span><br><span class="line">  completed: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Vue-的-methods-部分-把新事項加到列表"><a href="#Vue-的-methods-部分-把新事項加到列表" class="headerlink" title="Vue 的 methods 部分 (把新事項加到列表)"></a>Vue 的 methods 部分 (把新事項加到列表)</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">  addTodo: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 抓取輸入的文字</span></span><br><span class="line">    <span class="keyword">var</span> value = <span class="keyword">this</span>.newTodo;</span><br><span class="line">    <span class="comment">// 賦予 id - 將當下的時間轉為數字</span></span><br><span class="line">    <span class="keyword">var</span> timestamp = <span class="built_in">Math</span>.floor(<span class="built_in">Date</span>.now());</span><br><span class="line">    <span class="comment">// 把資料以物件格式推進 todos 陣列</span></span><br><span class="line">    <span class="keyword">this</span>.todos.push(&#123; <span class="attr">id</span>: timestamp, <span class="attr">title</span>: value, <span class="attr">completed</span>: <span class="literal">false</span> &#125;);</span><br><span class="line">    <span class="keyword">this</span>.newTodo = <span class="string">''</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="輸入欄防呆"><a href="#輸入欄防呆" class="headerlink" title="輸入欄防呆"></a>輸入欄防呆</h2><p>依照上面的設定可以順利新增任務了，但是如果沒在 <code>&lt;input&gt;</code> 打入文字也會送得出去，所以需要增加一些防止空白的效果。</p>
<p>把 <code>addTodo()</code> 裡面的程式碼稍作修改：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">addTodo: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 加上 trim() 去除頭尾空白並防止沒鍵入文字</span></span><br><span class="line">  <span class="keyword">var</span> value = <span class="keyword">this</span>.newTodo.trim;</span><br><span class="line">  <span class="comment">// 如果輸入欄空白就不會往下執行</span></span><br><span class="line">  <span class="keyword">if</span>(!value)&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ... <span class="comment">// 後面一樣</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="刪除待辦事項"><a href="#刪除待辦事項" class="headerlink" title="刪除待辦事項"></a>刪除待辦事項</h2><p>刪除功能必須仰賴待辦事項在陣列中的索引值，才能辨認使用者要刪除的是哪一筆資料，所以要將索引值設參數傳入刪除按鈕綁定的事件中去處理。</p>
<ul>
<li>將原本 <code>&lt;li&gt;</code> 設定的 <code>v-for</code> 值改為 <code>(item, key) in todos</code>，<code>key</code> 代表待辦事項的索引值</li>
<li>在 <code>&lt;li&gt;</code> 中的刪除按鈕綁定事件：<code>@click=&quot;removeTodo(key)&quot;</code></li>
<li>到 <code>methods</code> 增加 <code>removeTodo()</code>：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">removeTodo: <span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.todos.splice(key,<span class="number">1</span>);</span><br><span class="line">  <span class="comment">// 括號中的 1 代表從該索引值起，刪除 1 筆資料</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="為已完成事項加上刪除線"><a href="#為已完成事項加上刪除線" class="headerlink" title="為已完成事項加上刪除線"></a>為已完成事項加上刪除線</h2><p>寫一個 CSS 樣式，內容是在文字上加上刪除線。<br>由於 chceckbox 上已經綁定了 <code>v-model=&quot;tem.completed&quot;</code> 可以雙向修改 data 資料中 <code>completed</code> 的值，所以接下來只要在 <code>&lt;label&gt;</code> 上切換 <code>class</code> 即可。<br>在 <code>&lt;label&gt;</code> 上設定：<code>:class=&quot;{ &#39;completed&#39;: item.completed }&quot;</code>。</p>
<h2 id="製作「全部」、「進行中」、「已完成」頁籤切換，及過濾相對應的待辦事項"><a href="#製作「全部」、「進行中」、「已完成」頁籤切換，及過濾相對應的待辦事項" class="headerlink" title="製作「全部」、「進行中」、「已完成」頁籤切換，及過濾相對應的待辦事項"></a>製作「全部」、「進行中」、「已完成」頁籤切換，及過濾相對應的待辦事項</h2><h3 id="頁籤切換"><a href="#頁籤切換" class="headerlink" title="頁籤切換"></a>頁籤切換</h3><p>在 <code>data</code> 新增一個特性，這個特性會去感應使用者點擊的是哪一個頁籤，這邊將該特性取名作 <code>visibility</code>，且它的值可以先預設成第一頁頁籤的名稱。<br>在 HTML 頁籤結構的 <code>&lt;a&gt;</code> 上使用切換 <code>class</code> 的指令：<code>:class=&quot;{&#39;active&#39;: visibility == &#39;頁籤名稱&#39;}&quot;</code>，各個頁籤 <code>&lt;a&gt;</code> 都要加這一行，名稱記得替換。頁籤名稱可以依據各頁代表的意義來取。<br>接著在頁籤 <code>&lt;a&gt;</code> 上綁定點擊事件：<code>@click=&quot;visibility = &#39;頁籤名稱&#39;&quot;</code>。</p>
<h3 id="頁籤過濾"><a href="#頁籤過濾" class="headerlink" title="頁籤過濾"></a>頁籤過濾</h3><p>切換頁籤的功能做好後，繼續做頁面內容的替換（過濾）。<br>剛剛我們呈現在畫面上的都是從 <code>todos</code> 陣列撈出來的資料 (原始資料)，但其實畫面上應該呈現的是過濾後的資料。<br>所以要在 <code>computed</code> 裡面新增方法，運用 <code>todos</code> 進行資料的過濾。</p>
<p>在 <code>methods</code> 同層新增一個 <code>compute</code> 物件，並宣告一個新方法（這邊取名為 <code>filteredTodos</code>），用來執行過濾功能。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">compute:&#123;</span><br><span class="line">  filteredTodos: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.visibility==<span class="string">'全部任務頁籤名'</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.todos;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.visibility==<span class="string">'進行中任務頁籤名'</span>) &#123;</span><br><span class="line">         anotherTodos = [];</span><br><span class="line">         <span class="keyword">this</span>.todos.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</span><br><span class="line">           <span class="keyword">if</span>(!item.completed) &#123;</span><br><span class="line">              anotherTodos.push(item);</span><br><span class="line">           &#125;</span><br><span class="line">         &#125;)</span><br><span class="line">        <span class="keyword">return</span> anotherTodos;</span><br><span class="line">    &#125;  <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.visibility==<span class="string">'已完成任務頁籤名'</span>) &#123;</span><br><span class="line">         anotherTodos = [];</span><br><span class="line">         <span class="keyword">this</span>.todos.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</span><br><span class="line">           <span class="keyword">if</span>(item.completed) &#123;</span><br><span class="line">              anotherTodos.push(item);</span><br><span class="line">           &#125;</span><br><span class="line">         &#125;)</span><br><span class="line">        <span class="keyword">return</span> anotherTodos;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>把 <code>&lt;li&gt;</code> 原本寫的 <code>v-for = &quot;(item, key) in todos&quot;</code> 的 <code>todos</code> 改為 <code>filteredTodos</code>，可以這樣寫是因為 <code>filteredTodos</code> 回傳的是一個陣列。（<code>in</code> 後面可以接陣列或物件）</p>
<h3 id="刪除功能的修正"><a href="#刪除功能的修正" class="headerlink" title="刪除功能的修正"></a>刪除功能的修正</h3><p>加入了頁籤換頁功能後，原本的刪除功能會失靈，這是因為不同頁籤就是內容不同的陣列，因此其他頁籤的待辦事項索引值會跟在原始陣列 <code>todos</code> 不同，透過修正 <code>removeTodo()</code> 的程式碼，去比對在不同頁籤中的待辦事項 <code>id</code> 是否相同，如果 <code>id</code> 相同，就回傳它在原始陣列 <code>todos</code> 的索引值，統一從 <code>todos</code> 裡刪除，這樣才不會刪錯。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">removeTodo: <span class="function"><span class="keyword">function</span>(<span class="params">todo</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> vm = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">var</span> newIndex = vm.todos.findIndex(<span class="function"><span class="keyword">function</span>(<span class="params">item, key</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 這裡的 item 指的是 todos 裡的元素</span></span><br><span class="line">    <span class="keyword">return</span> todo.id === item.id;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">this</span>.todos.splice(newIndex,<span class="number">1</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>原本 <code>removeTodo()</code> 是傳入 <code>key</code> 當參數，要改成 <code>todo</code>，<code>todo</code> 代表所點選的項目；刪除按鈕綁定的事件 <code>@click=&quot;removeTodo(key)&quot;</code>，要把參數 <code>key</code> 改成 <code>item</code>。</p>
<h4 id="用變數存取-this-的必要性"><a href="#用變數存取-this-的必要性" class="headerlink" title="用變數存取 this 的必要性"></a>用變數存取 this 的必要性</h4><p>若在 <code>forEach</code> 中的 callback 函式內使用 <code>this</code> 來存取 <code>data</code> 中的屬性，就會發生讀取不到的問題，為了保險起見還是會宣告個 <code>vm</code> 變數，以確保存取的屬性是 Vue 實例中的 <code>data</code> 內的屬性。</p>
<h2 id="雙擊修改待辦事項內容"><a href="#雙擊修改待辦事項內容" class="headerlink" title="雙擊修改待辦事項內容"></a>雙擊修改待辦事項內容</h2><h3 id="lt-li-gt-的雙擊事件"><a href="#lt-li-gt-的雙擊事件" class="headerlink" title="&lt;li&gt; 的雙擊事件"></a><code>&lt;li&gt;</code> 的雙擊事件</h3><p>在設定 <code>v-for</code> 的 <code>&lt;li&gt;</code> 上，再綁一個雙擊事件的監聽：<code>@dblclick=&quot;editTodo(item)&quot;</code></p>
<h4 id="data-預存要編輯的任務"><a href="#data-預存要編輯的任務" class="headerlink" title="data 預存要編輯的任務"></a><code>data</code> 預存要編輯的任務</h4><p>在 <code>data</code> 新增兩個特性，用來預存要編輯的物件及該物件的文字：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="string">cacheTodo:</span> &#123;&#125;,</span><br><span class="line"><span class="string">cacheTitle:</span> <span class="string">''</span></span><br></pre></td></tr></table></figure>

<h3 id="在-methods-增加-editTodo-方法"><a href="#在-methods-增加-editTodo-方法" class="headerlink" title="在 methods 增加 editTodo() 方法"></a>在 <code>methods</code> 增加 <code>editTodo()</code> 方法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">editTodo: <span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 將雙擊的項目傳入 data</span></span><br><span class="line">  <span class="keyword">this</span>.cacheTodo = item;</span><br><span class="line">  <span class="keyword">this</span>.cacheTitle = item.title;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="添加編輯任務的輸入欄"><a href="#添加編輯任務的輸入欄" class="headerlink" title="添加編輯任務的輸入欄"></a>添加編輯任務的輸入欄</h3><p>把一個 <code>&lt;input&gt;</code> 寫在待辦列表 <code>&lt;li&gt;</code> 裡面的最下方（刪除按鈕的下面）。<br>這個 <code>&lt;input&gt;</code> 就是拿來編輯待辦事項用的，<code>&lt;input&gt;</code> 跟待辦事項兩者<strong>不會同時顯示</strong>，所以要在 <code>&lt;li&gt;</code> 的下一層（包住所有表單元素的 <code>&lt;div&gt;</code>）設定判斷是否要渲染一個待辦事項出來。</p>
<ul>
<li>在 <code>&lt;li&gt;</code> 下判斷：<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">v-if="item.id !== cacheTodo.id"</span><br><span class="line"><span class="comment">&lt;!-- 這一行的意思是：只顯示沒有被雙擊的項目 --&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>在 <code>&lt;input&gt;</code> 上設定的判斷則相反：<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">v-if="item.id == cacheTodo.id"</span><br><span class="line"><span class="comment">&lt;!-- 項目被雙擊時被 input 取代 --&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>關於渲染的邏輯</strong><br><code>v-if</code> 條件為 <code>true</code> 時會把內容的 DOM 渲染出來，條件為 <code>false</code> 時會把 DOM 移掉。</p>
<ol>
<li>雙擊 <code>&lt;li&gt;</code> 時，產生 <code>cacheTodo.id</code>，讓 <code>item.id == cacheTodo.id</code> 為 <code>true</code>，所以 <code>&lt;input&gt;</code> 就會渲染出來 。</li>
<li>沒有雙點擊 <code>&lt;li&gt;</code> 時， 不會產生 <code>cacheTodo.id</code>，讓 <code>item.id !== cacheTodo.id</code> 為 <code>true</code>，所以待辦事項就會渲染出來。</li>
</ol>
<h3 id="lt-input-gt-欄位中顯示被雙擊的任務文字"><a href="#lt-input-gt-欄位中顯示被雙擊的任務文字" class="headerlink" title="&lt;input&gt; 欄位中顯示被雙擊的任務文字"></a><code>&lt;input&gt;</code> 欄位中顯示被雙擊的任務文字</h3><p>在 <code>&lt;input&gt;</code> 上設定：<code>v-model=&quot;cacheTitle&quot;</code>。</p>
<h3 id="按下-Esc-鍵時取消編輯"><a href="#按下-Esc-鍵時取消編輯" class="headerlink" title="按下 Esc 鍵時取消編輯"></a>按下 Esc 鍵時取消編輯</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- HTML input --&gt;</span></span><br><span class="line">@keyup.esc="cancelEdit()"</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// JS methods</span></span><br><span class="line">cancelEdit: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 切換到未雙擊時的狀態</span></span><br><span class="line">  <span class="keyword">this</span>.cacheTodo = &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="項目修改完成"><a href="#項目修改完成" class="headerlink" title="項目修改完成"></a>項目修改完成</h3><p>按下 Enter 鍵就用新文字替換掉舊的，在 <code>&lt;input&gt;</code> 上設定：<code>@keyup.enter=&quot;doneEdit(item)&quot;</code>。<br>到 <code>methods</code> 去新增方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">doneEdit: <span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 按下 Enter 的瞬間把編輯中文字變為編輯完成的項目</span></span><br><span class="line">  item.title = <span class="keyword">this</span>.cacheTitle;</span><br><span class="line">  <span class="comment">// 回復到未點擊狀態</span></span><br><span class="line">  <span class="keyword">this</span>.cacheTitle = <span class="string">''</span>;</span><br><span class="line">  <span class="keyword">this</span>.cacheTodo = &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>關於將暫存資料清空</strong><br>將 <code>doneEdit</code> 方法中的 <code>this.cacheTitle = &#39;&#39;;</code> 刪除也不會影響功能，是因為在 <code>editTodo</code> 方法中已經用 <code>this.cacheTitle = item.title;</code> 先把 <code>this.cacheTitle</code> 的內容用當下這筆事項的內容取代了，當編輯不同筆事項時，<code>this.cacheTitle</code> 中的值都會被使用者正在編輯的事項內容給取代。</p>
<p>如果沒有 <code>this.cacheTitle = &#39;&#39;</code> ; 編輯完成後 <code>cacheTitle</code> 的值就會固定成改變後的值，而不是原來預設在 <code>data</code> 裡的空值。雖然 <code>editTodo</code> 方法中已經寫好了替換編輯內容的效果，但假設有要再用 <code>cacheTitle</code> 做其他資料的處理，可能就會受影響，所以保險起見把它的值歸零。</p>
<h2 id="未完成任務數目與清除所有任務"><a href="#未完成任務數目與清除所有任務" class="headerlink" title="未完成任務數目與清除所有任務"></a>未完成任務數目與清除所有任務</h2><h3 id="未完成任務數目"><a href="#未完成任務數目" class="headerlink" title="未完成任務數目"></a>未完成任務數目</h3><ul>
<li>在 <code>computed</code> 新增方法，目的是計算 <code>todos.completed</code> 為 <code>false</code> 的數量</li>
<li>用 <code>filter()</code> 過濾 <code>todos</code></li>
<li>取得一個未完成任務組成的陣列</li>
<li>用 <code>compute</code> 方法 <code>return</code> 這個陣列的長度</li>
<li>在 HTML 中用雙花括號插入 <code>compute 方法名</code></li>
</ul>
<h3 id="清除所有任務"><a href="#清除所有任務" class="headerlink" title="清除所有任務"></a>清除所有任務</h3><ul>
<li>在「清除所有任務」<code>&lt;a&gt;</code> 上綁定事件監聽</li>
<li>在 <code>methods</code> 新增方法，把 <code>todos</code> 宣告為空陣列即可</li>
</ul>
]]></content>
      <categories>
        <category>Vuejs</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>todolist</tag>
      </tags>
  </entry>
  <entry>
    <title>[Vue] 進階指令與模板語法 (下)</title>
    <url>/Vuejs/20191218/2429605945/</url>
    <content><![CDATA[<p>本篇筆記要繼續分享 Vue 中一些指令的進階用法與使用細節，基本上是 Vue 基礎概述篇的延伸，不過也會提到一些新的東西。<br>我超不會寫前言，就不廢話了，直接開始吧！</p>
<a id="more"></a>

<h2 id="v-if-v-else-v-else-if"><a href="#v-if-v-else-v-else-if" class="headerlink" title="v-if / v-else / v-else-if"></a>v-if / v-else / v-else-if</h2><p>在一個 HTML 元素上使用 <code>v-if=&quot;data資料&quot;</code>，當資料的值為 <code>true</code> 時才會渲染這個 DOM；而在 <code>v-if</code> 相鄰的 HTML 元素上使用 <code>v-else</code>，就能把 <code>v-if</code> 判斷為 <code>false</code> 的資料渲染在這個 DOM 上。</p>
<p><code>v-else-if</code> 用於渲染條件<strong>多於兩個以上</strong>時，第一個條件用 <code>v-if=&quot;條件</code>“，第二跟第三個就可以用 <code>v-else-if=&quot;其他條件&quot;</code> 。</p>
<h3 id="v-if-跟-v-show-的差異"><a href="#v-if-跟-v-show-的差異" class="headerlink" title="v-if 跟 v-show 的差異"></a>v-if 跟 v-show 的差異</h3><p><code>v-show</code> 是控制 HTML 元素的 <code>display</code>，所以 <code>v-show</code> 為 <code>false</code> 的 HTML 元素其實還是有被渲染出來，只是 <code>display: none</code> 而已；<code>v-if</code> 是指渲染出符合條件的 HTML 元素，不符合的就不會渲染。</p>
<h3 id="模板-lt-template-gt"><a href="#模板-lt-template-gt" class="headerlink" title="模板 &lt;template&gt;"></a>模板 <code>&lt;template&gt;</code></h3><p><code>&lt;template&gt;</code> 的使用時機在於，想要使用 Vue 指令，但不希望 HTML 標籤輸出時。<br>在 <code>&lt;template&gt;</code> 裡的子元素不會被渲染出來，可以一次控制多個 DOM。如果在 <code>&lt;template&gt;</code> 使用 <code>v-if</code>，那麼條件為 <code>true</code> 時，就能渲染出 <code>&lt;template&gt;</code> 內的子元素。</p>
<h2 id="compued-與-watch"><a href="#compued-與-watch" class="headerlink" title="compued 與 watch"></a>compued 與 watch</h2><p><code>computed</code> 與 <code>watch</code> 都是專門放函式的 Vue 實例特性，兩者很像，因為都會隨著資料做變化，但兩者最大差異在於<strong>會不會變動 data 資料</strong>，<code>computed</code> 裡的 <code>function</code> 在資料變動時才會執行、渲染；而 <code>watch</code> 相反，是<strong>主動去監控及變動 data 資料</strong>，當資料變動時就執行特定 <code>function</code>。</p>
<p>所以可以整理成以下的比較：</p>
<ul>
<li><code>methods</code>：需要主動觸發，且可以多次重複觸發</li>
<li><code>computed</code>：當資料出現變化且需要改變畫面的 <code>function</code> 放這裡</li>
<li><code>watch</code>：監控特定資料變化的 <code>function</code> 就放這裡</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">watch: &#123;</span><br><span class="line">  監控的 data 特性: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.data特性 = <span class="literal">false</span>;</span><br><span class="line">    &#125;, <span class="number">3000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="表單細節操作"><a href="#表單細節操作" class="headerlink" title="表單細節操作"></a>表單細節操作</h2><h3 id="用-v-for-製作多個-lt-option-gt-："><a href="#用-v-for-製作多個-lt-option-gt-：" class="headerlink" title="用 v-for 製作多個 &lt;option&gt;："></a>用 v-for 製作多個 <code>&lt;option&gt;</code>：</h3><p><code>&lt;select&gt;</code> 下拉式選單標籤裡面包的是好幾個 <code>&lt;option&gt;</code>，也就是選項，可以透過 <code>v-for</code> 製作多個 <code>&lt;option&gt;</code> 。</p>
<ol>
<li>在 <code>data</code> 先寫好要放進 <code>&lt;option&gt;</code> 的資料（陣列格式）</li>
<li>寫一個 HTML <code>&lt;option&gt;</code>，並設定 <code>:value=&quot;item&quot;</code>，及 <code>v-for=&quot;item in 資料陣列&quot;</code></li>
<li>在 <code>&lt;option&gt;</code> 中插入選項文字：雙花括號包著 <code>item</code></li>
</ol>
<h3 id="lt-select-gt-多選："><a href="#lt-select-gt-多選：" class="headerlink" title="&lt;select&gt; 多選："></a><code>&lt;select&gt;</code> 多選：</h3><p>跟上面的程式碼大同小異，不過要在 <code>&lt;select&gt;</code> 多加一個 <code>multiple</code> 屬性。</p>
<h3 id="checkbox-與-data-的切換"><a href="#checkbox-與-data-的切換" class="headerlink" title="checkbox 與 data 的切換"></a>checkbox 與 data 的切換</h3><p>在 checkobx 使用 <code>true-value</code> 與 <code>false-value</code> 屬性，例如下面的程式碼，當勾選（<code>true</code>）時會使 <code>data.sex</code> 為男生，沒勾選（<code>false</code>）時會使 <code>data.sex</code> 為女生。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// data 裡其中一筆資料如下：</span></span><br><span class="line">sex: <span class="string">"男生"</span>,</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- HTML --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">id</span>=<span class="string">"sex"</span> <span class="attr">v-model</span>=<span class="string">"sex"</span> <span class="attr">true-value</span>=<span class="string">"男生"</span> <span class="attr">false-value</span>=<span class="string">"女生"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"sex"</span>&gt;</span>&#123;&#123; sex &#125;&#125;<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="表單欄位修飾符"><a href="#表單欄位修飾符" class="headerlink" title="表單欄位修飾符"></a>表單欄位修飾符</h3><ul>
<li><code>.lazy</code>：跟 <code>v-model</code> 搭配使用，原本 Vue 預設輸入的資料會與 <code>data</code> 同步，使用 <code>.lazy</code> 後就相當於使用 <code>change</code> 事件</li>
<li><code>.number</code>：將字串轉型為數字</li>
<li><code>.trim</code>：將字元間的空白去除</li>
</ul>
<h2 id="事件修飾符"><a href="#事件修飾符" class="headerlink" title="事件修飾符"></a>事件修飾符</h2><p>以下修飾符都是加在 <code>v-on: 事件</code> 後面的後綴：</p>
<ul>
<li>.stop — 中止冒泡，等於 <code>event.stopPropagation()</code>。</li>
<li>.prevent — 取消預設送出的行為，等於 <code>event.preventDefault()</code>。</li>
<li>.capture — 監聽事件時使用事件捕捉模式。</li>
<li>.self — 使用這個修飾符的作用是，當 event.target 是綁定監聽的元素時才觸發函式。</li>
<li>.once — 使用這個修飾符的作用是，讓事件只被觸發一次。</li>
</ul>
<h2 id="按鍵修飾符"><a href="#按鍵修飾符" class="headerlink" title="按鍵修飾符"></a>按鍵修飾符</h2><p>在鍵盤事件後加上特定 keyCode 或別名，當事件是從特定鍵觸發時，才執行函式。<br>又分成以下兩種修飾：</p>
<ul>
<li>按鍵碼別名修飾：因為 keyCode 很難記，所以 Vue 提供常用的按鍵別名可以拿來當修飾符，例如 <code>.enter</code>, <code>.tab</code>, <code>.delete</code>, <code>.esc</code>, <code>.space</code>, <code>.up</code>, <code>.down</code>, <code>.left</code>, <code>.right</code></li>
<li>系統修飾鍵：在事件後面加系統修飾鍵當後綴，使用時就必須搭配游標或別名修飾按鍵，才會觸發事件，例如 <code>.ctrl</code>, <code>.alt</code>, <code>.shift</code>, <code>.meta</code><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Alt + C --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> @<span class="attr">keyup.alt.67</span>=<span class="string">"clear"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Ctrl + Click --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> @<span class="attr">click.ctrl</span>=<span class="string">"doSomething"</span>&gt;</span>Do something<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="滑鼠修飾符"><a href="#滑鼠修飾符" class="headerlink" title="滑鼠修飾符"></a>滑鼠修飾符</h2><ul>
<li>.left：當點擊滑鼠左鍵時觸發。</li>
<li>.right：當點擊滑鼠右鍵時觸發。</li>
<li>.middle：當點擊滑鼠中鍵時觸發。</li>
</ul>
<hr>
<p>參考資料：<a href="https://cn.vuejs.org/v2/guide/events.html" target="_blank" rel="external nofollow noopener noreferrer">Vue.js 官方文件的許多部份</a></p>
<p>順便補上跟本篇有關的<a href="https://gretema.github.io/Vuejs/20191218/150943901/">基礎概述</a>。</p>
]]></content>
      <categories>
        <category>Vuejs</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>[Vue] 進階指令與模板語法 (上)</title>
    <url>/Vuejs/20191218/2311842168/</url>
    <content><![CDATA[<p>了解了 Vue 的基本指令以後，接著繼續來了解指令及模板的進階用法吧！</p>
<a id="more"></a>

<h2 id="v-once-—-單次綁定"><a href="#v-once-—-單次綁定" class="headerlink" title="v-once — 單次綁定"></a>v-once — 單次綁定</h2><p><code>v-text</code> 跟 <code>v-once</code> 同時寫在一個 HTML 元素上，如此一來這個元素的內容在第一次寫入完成後，之後就不會再被變動。</p>
<h2 id="雙花括號輸出資料加總"><a href="#雙花括號輸出資料加總" class="headerlink" title="雙花括號輸出資料加總"></a>雙花括號輸出資料加總</h2><p>如果 <code>data</code> 中有多個特性的值為數字，可以用雙花括號在 HTML 輸出這些特性作為變數組成的算式，並在畫面上渲染出計算結果；或者也可以將數個字串型別的特性直接在雙花括號中串接，一樣可以渲染出字串連接的結果。</p>
<h2 id="動態操控-disabled-屬性"><a href="#動態操控-disabled-屬性" class="headerlink" title="動態操控 disabled 屬性"></a>動態操控 disabled 屬性</h2><p>用 <code>v-bind</code> 綁定 <code>disabled</code> 屬性與 <code>data</code> 特性，當切換對應的 <code>data</code> 值（值為布林）時，就能隨之切換 HTML 的可用狀態。</p>
<h2 id="動態切換-className-的多種寫法"><a href="#動態切換-className-的多種寫法" class="headerlink" title="動態切換 className 的多種寫法"></a>動態切換 className 的多種寫法</h2><ul>
<li><p>用物件帶值：在 <a href="https://gretema.github.io/Vuejs/20191218/150943901/">Vue 基礎概述 (下)</a> 講過，也就是在要切換 <code>className</code> 的 HTML 元素上使用 <code>v-bind</code> 並且值用<strong>物件形式</strong>帶入，像下面這樣：<br><code>:class=&quot;{&#39;要加入的 className&#39;: 判斷式}&quot;</code></p>
</li>
<li><p>用陣列帶值：在 data 創一個<strong>空陣列</strong>，在要套用 <code>className</code> 的元素上設定 <code>:class=&quot;data 陣列名&quot;</code>，觸發樣式切換的元素（例如 checkbox）加上 <code>v-model=&quot;data 陣列名&quot;</code> 及 <code>value=&quot;要切換的 className&quot;</code>，這樣如果要啟用 <code>className</code> 就能透過觸發元素將 <code>value</code> 傳進 <code>data</code> 裡的陣列，而如果要拿掉 <code>className</code> 一樣也是透過觸發元素刪掉該陣列中的 <code>value</code>。</p>
</li>
</ul>
<iframe src="https://codepen.io/gretema/embed/PoqVbLz?height=265&theme-id=dark&default-tab=html,result" width="100%" height="300" frameborder="0" loading="lazy" allowfullscreen></iframe>

<h2 id="插入行內樣式-style"><a href="#插入行內樣式-style" class="headerlink" title="插入行內樣式 (style)"></a>插入行內樣式 (style)</h2><ul>
<li>用物件帶值：要注意 style 樣式屬性的名稱跟 CSS 不太一樣，style 的樣式屬性採用駝峰式命名法。也可以用<strong>參數</strong>的方式從 data 傳物件到 style 屬性，這樣做的話可以在物件內放入數個特性（樣式）</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 基本款 --&gt;</span></span><br><span class="line">:style="&#123;'樣式屬性': '樣式的值'&#125;"</span><br><span class="line"><span class="comment">&lt;!-- 傳參數版 --&gt;</span></span><br><span class="line">:style="styleObject"</span><br></pre></td></tr></table></figure>

<ul>
<li>用陣列帶值：陣列元素必須以<strong>物件方式</strong>寫入；或用<strong>參數</strong>，可以在陣列內放入數個物件參數。</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 基本款 --&gt;</span></span><br><span class="line">[&#123;'樣式屬性1': '樣式的值1'&#125;, &#123;'樣式屬性2': '樣式的值2'&#125;]</span><br><span class="line"><span class="comment">&lt;!-- 傳參數版 --&gt;</span></span><br><span class="line">[styleObject1, styleObject2]</span><br></pre></td></tr></table></figure>

<h2 id="v-for-使用細節"><a href="#v-for-使用細節" class="headerlink" title="v-for 使用細節"></a>v-for 使用細節</h2><p>可以用於疊代 data 中的陣列及物件。</p>
<h3 id="v-for-與-key-屬性"><a href="#v-for-與-key-屬性" class="headerlink" title="v-for 與 key 屬性"></a>v-for 與 key 屬性</h3><p>引述自官網：「使用 v-for 渲染的元素列表時，默認使用『就地更新』的策略。如果數據項的順序被改變，Vue 將<strong>不會移動 DOM 元素</strong>來匹配數據項的順序，而是就地更新每個元素，並且確保它們在每個索引位置正確渲染。」</p>
<p>也就是說，預設狀況下，資料的<strong>索引值是固定的</strong>，當畫面上資料順序變換時，是將內容進行替換，而不是替換 DOM 元素位置。</p>
<p>如果希望 DOM 元素位置替換呢？在每筆資料上綁定 key 屬性，該屬性必須對應一個唯一值。<br>參照：<a href="https://cn.vuejs.org/v2/guide/list.html" target="_blank" rel="external nofollow noopener noreferrer">官方文件（列表渲染）</a>、<a href="https://juejin.im/post/5cb06250f265da03b204207e" target="_blank" rel="external nofollow noopener noreferrer">如何理解vue的key属性</a></p>
<h3 id="v-for-跟-filter-連用"><a href="#v-for-跟-filter-連用" class="headerlink" title="v-for 跟 filter() 連用"></a>v-for 跟 filter() 連用</h3><p>來寫一個可以過濾資料的小範例吧！</p>
<ol>
<li>結構：</li>
</ol>
<ul>
<li><strong>data 資料</strong> - <code>arrayData</code> 為一個包含多個物件資料的陣列</li>
<li><strong>負責輸入的 HTML 元素</strong>（例如 input text） - 設定 <code>v-model=&quot;filterText&quot;</code>（等一下過濾 <code>arrayData</code> 的條件）</li>
<li><strong>負責輸出的 HTML 元素</strong> - 設定 <code>v-for=&quot;(item,key) in filterArray&quot;</code>（<code>filterArray</code> 初始狀態為空陣列）</li>
</ul>
<ol start="2">
<li>在 <code>methods</code> 新增方法：</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">filterData: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> vm = <span class="keyword">this</span>;</span><br><span class="line">  <span class="comment">// 用 for loop 時裡面的 this 不是指向 Vue，所以要在外面先定義好 this</span></span><br><span class="line">  vm.filterArray = vm.arrayData.filter(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> item.name.match(vm.filterText);</span><br><span class="line">  <span class="comment">// 回傳與輸入文字相符的 name 值</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>⚠️ <code>match()</code> 方法：<br>用於在字串中檢索指定的值，此方法類似 <code>indexOf()</code>，不過它回傳的是指定的值而不是索引值。</p>
<ol start="3">
<li>實際運行</li>
</ol>
<iframe src="https://codepen.io/gretema/embed/OJJdgor?height=265&theme-id=default&default-tab=js,result" width="100%" height="300" frameborder="0" loading="lazy" allowfullscreen></iframe>

<h3 id="v-for-無法運行的狀況"><a href="#v-for-無法運行的狀況" class="headerlink" title="v-for 無法運行的狀況"></a>v-for 無法運行的狀況</h3><p>在 <code>methods</code> 方法中用陣列特性及索引去修改 <code>data</code> 資料是無效的，因為 Vue 無法探測普通的新增屬性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 無效的修改方式</span></span><br><span class="line"><span class="keyword">this</span>.arrayData.length = <span class="number">0</span>; <span class="comment">// arrayData 的陣列元素依然存在陣列中</span></span><br><span class="line"><span class="keyword">this</span>.arrayData[<span class="number">0</span>] = &#123;</span><br><span class="line">  name: <span class="string">'阿強'</span>,</span><br><span class="line">  age: <span class="number">99</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正確修改的方式是用 <code>Vue.set()</code> 新增 <code>data</code> 裡沒有的資料，用這個方式才能讓資料保持響應式，帶動 View 正常更新。</p>
<p><code>Vue.set()</code> 第一個參數是<strong>陣列名</strong>，第二個參數是陣列元素<strong>索引值</strong>，第三個是<strong>要新增的內容</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.set(<span class="keyword">this</span>.arrayData, <span class="number">0</span>, &#123;</span><br><span class="line">  name: <span class="string">'阿強'</span>,</span><br><span class="line">  age: <span class="number">99</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="v-for-用於純數字"><a href="#v-for-用於純數字" class="headerlink" title="v-for 用於純數字"></a>v-for 用於純數字</h3><p>在 HTML 元素上使用 <code>v-for=&quot;item in 10&quot;</code>，並在標籤內用雙花括號包住 <code>item</code> 就能渲染出 1 到 10 的數字。</p>
<h3 id="v-for-用於-lt-template-gt"><a href="#v-for-用於-lt-template-gt" class="headerlink" title="v-for 用於 &lt;template&gt;"></a>v-for 用於 <code>&lt;template&gt;</code></h3><p>在 <code>&lt;template&gt;</code> 使用 <code>v-for</code>，可以讓內部的子元素以<strong>群組</strong>的方式一起疊代。</p>
<p>⚠️ HTML <code>&lt;template&gt;</code> 模板結構：</p>
<p>模板結構中的內容在頁面載入時不受渲染，但可以在運行時使用 JavaScript 實例化。</p>
<p>你可以把 <code>&lt;template&gt;</code> 想成文件裡面，被儲存以待<strong>稍後使用</strong>的內容片段。在頁面載入時，解析器雖然會處理 <code>&lt;template&gt;</code> 元件的內容，但元素本身並<strong>不會被渲染</strong>。</p>
<p><code>&lt;template&gt;</code> 內的內容可以用 JavaScript 抓取節點、複製到要插入的 DOM 之下，類似這樣：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- HTML --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 在 template 上面有一些表格元素 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">"itemRow"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// JS</span></span><br><span class="line"><span class="keyword">var</span> template = <span class="built_in">document</span>.querySelector(<span class="string">'#itemRow'</span>);</span><br><span class="line"><span class="keyword">var</span> td = t.content.querySelectorAll(<span class="string">"td"</span>);</span><br><span class="line">td[<span class="number">0</span>].textContent = <span class="string">"123"</span>;</span><br><span class="line">td[<span class="number">1</span>].textContent = <span class="string">"abc"</span>;</span><br><span class="line"><span class="keyword">var</span> clone = <span class="built_in">document</span>.importNode(template.content, <span class="literal">true</span>);</span><br><span class="line">要插入的DOM.appendChild(clone);</span><br></pre></td></tr></table></figure>

<p>⚠️ 關於 <code>importNode()</code><br><code>importNode()</code> 是 <code>document</code> 物件的方法，功用是把一個節點從另一個文件（document）複製到該文件以便運用。第二個參數（布林值）必填，如果為 <code>true</code>，會複製 <code>importNode()</code> 的所有子節點。</p>
<p>參考資料：<a href="https://www.zhangxinxu.com/wordpress/2014/07/hello-html5-template-tag/" target="_blank" rel="external nofollow noopener noreferrer">HTML5 <code>&lt;template&gt;</code> 标签元素简介</a>、<a href="https://developer.mozilla.org/zh-TW/docs/Web/HTML/Element/template" target="_blank" rel="external nofollow noopener noreferrer">&lt;template — HTML&gt; | MDN</a></p>
<h3 id="v-for-與-v-if-連用"><a href="#v-for-與-v-if-連用" class="headerlink" title="v-for 與 v-if 連用"></a>v-for 與 v-if 連用</h3><p>當 <code>v-for</code> 與 <code>v-if</code> 同時綁在一個元素上時，<code>v-for</code> 先執行，接著才執行 <code>v-if</code>。兩者連用可以從迴圈中過濾出符合條件的結果。不過這樣做會導致畫面上雖然只渲染部分資料，但卻必須巡訪過全部資料才能輸出。</p>
<p>因此 Vue 官方建議在 <code>computed</code> 新增方法，使用 <code>filter()</code> 進行條件過濾，此時 <code>v-for</code> 對應的值要改為 <code>item in 方法名</code>，比較能提升效能。</p>
<p>另外一個提升效能的方法是把 <code>v-if</code> 放在 <code>v-for</code> 的<strong>父層元素</strong>，如此一來我們不會再對列表中的每個項目檢查條件，取而代之的是，我們只檢查它一次，且不會在條件不成立的時候運算 <code>v-for</code>。</p>
<p>參照：<a href="https://cn.vuejs.org/v2/style-guide/#%E9%81%BF%E5%85%8D-v-if-%E5%92%8C-v-for-%E7%94%A8%E5%9C%A8%E4%B8%80%E8%B5%B7-%E5%BF%85%E8%A6%81" target="_blank" rel="external nofollow noopener noreferrer">避免 v-if 和 v-for 用在一起（官方文件）</a></p>
<hr>
<p>下篇要講的是 <code>v-if</code>、<code>compued</code> 與 <code>watch</code>、表單細節操作、<code>v-on</code> 細節。</p>
]]></content>
      <categories>
        <category>Vuejs</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>[Vue] Vue.js 基礎概述 (下)</title>
    <url>/Vuejs/20191218/150943901/</url>
    <content><![CDATA[<p>上一篇有提到一部份的基礎指令，今天要繼續介紹上一篇沒講完的部分。</p>
<a id="more"></a>

<h2 id="v-on-—-事件監聽"><a href="#v-on-—-事件監聽" class="headerlink" title="v-on — 事件監聽"></a>v-on — 事件監聽</h2><p>在要監聽的 HTML 元素上加上 <code>v-on: 事件 = &quot;方法名稱()&quot;</code>，在 <code>data</code> 物件同層新增 <code>methods</code> 物件，裡面寫入一個特性，其值為函式（=方法），這個特性的名稱就是要填入 <code>v-on</code> 屬性中的「方法名稱」。 <code>v-on:</code> 的縮寫是 <code>@</code> 。</p>
<p>範例：</p>
<iframe src="https://codepen.io/gretema/embed/ExxOYxY?height=265&theme-id=default&default-tab=html,result" width="100%" height="300" frameborder="0" loading="lazy" allowfullscreen></iframe>

<p>之前學 <code>this</code> 的時候曾學到，<code>this</code> 指向的是它所在的函式隸屬的物件，因此可能會有人疑惑為何 <code>reverseText()</code> 中是寫成 <code>this.newText</code> 跟 <code>this.text</code>，畢竟 <code>reverseText</code> 所在的物件是 <code>methods</code>，那 this 不就是指向 <code>methods</code> 嗎？</p>
<p>在這裡可以把 <code>data</code> 想成 JavaScript 裡的全域變數（會變成 window 物件的其中一個特性），先宣告好就可給 <code>method</code> 物件裡面的方法去使用。</p>
<h2 id="預先定義資料結構"><a href="#預先定義資料結構" class="headerlink" title="預先定義資料結構"></a>預先定義資料結構</h2><p>由於畫面跟資料可以雙向地變動，因此預先把程式碼的架構給定義出來是很重要的。</p>
<h2 id="修飾符"><a href="#修飾符" class="headerlink" title="修飾符"></a>修飾符</h2><p>一種加在指令後面的後綴，例如在 <code>v-on</code> 後面加上 <code>.prevent</code> 修飾符就代表了 <code>event.preventDefault()</code>，使用修飾符可以讓我們少寫幾行程式碼。跟事件搭配的後綴在官方文件的<a href="https://cn.vuejs.org/v2/guide/events.html#%E4%BA%8B%E4%BB%B6%E4%BF%AE%E9%A5%B0%E7%AC%A6" target="_blank" rel="external nofollow noopener noreferrer">事件處理章節</a>有列出來。</p>
<h2 id="動態切換-class"><a href="#動態切換-class" class="headerlink" title="動態切換 class"></a>動態切換 class</h2><p>在要動態切換 <code>class</code> 的 HTML 元素上用 <code>v-bind</code> 來設定參數，結構像這樣：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span> <span class="attr">:class</span>=<span class="string">"&#123; '要加入的 className': 判斷式&#125;"</span> &gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 在大括號內允許傳入多個要切換的 className --&gt;</span></span><br></pre></td></tr></table></figure>

<p>以切換 <code>className</code> 來說，通常判斷式的內容會寫入一個 <code>data</code> 物件中的特性，而該特性的值為<strong>布林值</strong>。</p>
<p>以「按下按鈕就讓一個正方形 box 旋轉」為例：</p>
<iframe src="https://codepen.io/gretema/embed/wvvQwKm?height=265&theme-id=default&default-tab=html,result" width="100%" height="300" frameborder="0" loading="lazy" allowfullscreen></iframe>

<p>在這個範例中，按下按鈕觸發的事件，會將 <code>data</code> 物件中 <code>isTransform</code> 特性的值顛倒，再配合 <code>.box</code> 增加 <code>className</code> 的條件，就達到 toggle <code>.rotate</code> 的效果。</p>
<h2 id="computed-—-計算屬性"><a href="#computed-—-計算屬性" class="headerlink" title="computed — 計算屬性"></a>computed — 計算屬性</h2><p><code>computed</code> 物件跟 <code>data</code> 物件同層，它裡面放的只會是有取特性名稱的方法，這些方法用來 <code>return</code> 一個值且儲存在方法對應的特性裡（類似變數的性質）。</p>
<p>範例：</p>
<iframe src="https://codepen.io/gretema/embed/MWWzgbd?height=265&theme-id=default&default-tab=html,result" width="100%" height="300" frameborder="0" loading="lazy" allowfullscreen></iframe>

<p><code>computed</code> 物件的 <code>reverseText()</code> 中，已經定義了回傳的值是以 <code>this.text</code> 的值為計算基礎（這裡的 <code>this</code> 依然是指全域），一旦 <code>data</code> 物件裡的 <code>text</code> 值變更，<code>reverseText()</code> 回傳的值也會隨之變動。</p>
<p>以執行結果來說，<code>computed</code> 跟 <code>methods</code> 裡面的方法，輸出的結果確實是一樣的，但是兩者<strong>執行函式的方式不同</strong>。<br><code>computed</code> 裡的方法<strong>不是</strong>依靠觸發來執行的，只要它所依附的計算基礎沒有變動，就不會再次執行，只會固定輸出之前計算的結果；而 <code>methods</code> 則是<strong>依靠觸發</strong>，每次觸發都會再次執行函式。</p>
<h2 id="表單輸入綁定"><a href="#表單輸入綁定" class="headerlink" title="表單輸入綁定"></a>表單輸入綁定</h2><p>將使用者在表單上輸入的內容記錄到 Model 裡，主要就是用 <code>v-model</code> 進行資料綁定。</p>
<ul>
<li>單一個 checkbox：設定 <code>v-model</code> 指向對應的特性，這樣點選時就能切換布林值。</li>
<li>多選：checkbox 所有選項都要設定 <code>value</code> 屬性及 <code>v-model</code>，且 <code>v-model</code> 都要指向 <code>data</code> 裡同一個<strong>陣列</strong>，這樣勾選選項時，每個選項的 <code>value</code> 就會寫進陣列裡。</li>
<li>單選：radio 也是所有選項都要設定 <code>value</code> 屬性及 <code>v-model</code>，且 <code>v-model</code> 都要指向 <code>data</code> 裡同一個<strong>特性</strong>，這樣就只會寫入一個值。</li>
<li><code>&lt;select&gt;</code> 下拉選單：<code>&lt;select&gt;</code> 用 <code>v-model</code> 指向對應的<strong>特性</strong>，<code>&lt;select&gt;</code> 裡面是 <code>&lt;option&gt;</code> 選項。第一個 <code>&lt;option&gt;</code> 可以把 <code>value</code> 屬性的值空著，文字就寫些「請選擇」之類的初始選項，如果不想被使用者誤觸的話，可以再加上 <code>disabled</code> 屬性。其他選項都要填入 <code>value</code> 值，才能正確寫入對應特性中，不過 <code>value</code> 值不一定要跟選項文字相同。</li>
</ul>
<h2 id="元件-components-基礎"><a href="#元件-components-基礎" class="headerlink" title="元件 (components) 基礎"></a>元件 (components) 基礎</h2><p>元件可以複用，它在 HTML 中以標籤的形式表現，而標籤名是自定義的元件名稱。</p>
<p>之前的指令都是寫在 Vue 實例裡，元件則是寫在 Vue 實例外面，而且順序要擺在 Vue 實例之前。因為解譯器是依序執行的，它會先讀到 HTML 的元件標籤，所以必須讓解譯器在 JS 檔案中馬上讀到關於元件的程式碼。</p>
<p>範例：</p>
<iframe src="https://codepen.io/gretema/embed/eYYQOMm?height=265&theme-id=default&default-tab=html,result" width="100%" height="300" frameborder="0" loading="lazy" allowfullscreen></iframe>

<p>元件的資料會寫在 <code>Vue.components()</code> 的小括號裡面，小括號內有兩個參數，第一個參數是<strong>自訂元件的名稱</strong>（跟在 HTML 的標籤名相同），第二個參數是<strong>一個物件</strong>，該物件內要寫入一個 <code>data</code> 特性跟一個 <code>template</code> 特性。</p>
<p><code>data</code> 特性對應的是一個函式，該函式必須 <code>return</code> 一個物件，該物件裡面放的就是專屬於這個元件的資料。</p>
<p><code>data</code> 寫好後，開始寫 <code>template</code> 特性。<code>template</code> 特性負責的是這個元件的 HTML 結構，所以對應的值是用<strong>反引號</strong>包起來的「含有 HTML 標籤的字串」，在這裏面可以運用 <code>data</code> 的內容。</p>
<p>雖然我們在 HTML 中寫的元件是用元件名稱當標籤，但是用 chrome 開發人員工具看 HTML 結構時會發現，原本的元件標籤呈現出來的程式碼會是 template 組出來的內容。</p>
<hr>
<p>以上就是 Vue 的基礎指令，這些指令都還有一些使用細節可以延伸來介紹，之後會再整理相關筆記。</p>
]]></content>
      <categories>
        <category>Vuejs</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>[Vue] Vue.js 基礎概述 (上)</title>
    <url>/Vuejs/20191217/300157404/</url>
    <content><![CDATA[<h2 id="Vue-js-簡介"><a href="#Vue-js-簡介" class="headerlink" title="Vue.js 簡介"></a>Vue.js 簡介</h2><blockquote><p>Vue.js 是一款流行的 JavaScript 前端框架，旨在更好地組織與簡化 Web 開發。Vue 所關注的核心是 MVC 模式中的視圖層（View），同時，它也能方便地取得資料更新，並通過組件內部特定的方法實現視圖（View）與模型（Model）的互動。</p>
<footer><strong>——維基百科</strong></footer></blockquote>

<a id="more"></a>

<p>總結一下維基百科對 Vue 的介紹，Vue 作為一款 JavaScript 的框架，有兩個特點：</p>
<ol>
<li>直觀語法：借鏡於 MVVM 模式，畫面與資料雙向綁定，所見即所得。</li>
<li>多樣化延伸工具：可用來開發 SPA（單頁應用程式） 及傳統多頁應用程式。</li>
</ol>
<h2 id="從建立應用程式開始"><a href="#從建立應用程式開始" class="headerlink" title="從建立應用程式開始"></a>從建立應用程式開始</h2><ul>
<li><p>宣告一個 Vue 實例：使用 <code>new</code> 關鍵字來宣告。一個網頁上可以放不只一個 Vue 實例，但不能在一個 Vue 實例中包另一個 Vue 實例（不可巢狀）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> app2 = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>綁定 DOM：一個 Vue 實例生成後必須綁定一個 HTML 元素，所以要綁定的 HTML 元素應該要設有 <code>id</code>。Vue 綁定 DOM 的方法是在剛剛宣告的 Vue 實例中放入 <code>el: &#39;元素 id&#39;</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HTML</span></span><br><span class="line">&lt;div id=<span class="string">"app"</span>&gt; ... &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ JS</span></span><br><span class="line"><span class="regexp">var app = new Vue(&#123;</span></span><br><span class="line"><span class="regexp">  el: '#app', /</span><span class="regexp">/ HTML id</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>把資料呈現在畫面上：在 Vue 實例中繼續放入資料，資料內容是以物件形式寫入。而要把資料內容呈現在畫面上，則要在綁定的 HTML 元素中，放入兩對大括號（雙花括號），雙花括號中間包著資料的特性名稱。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HTML</span></span><br><span class="line">&lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">  &lt;p&gt; &#123;&#123; text &#125;&#125; &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br><span class="line"><span class="comment">// JS</span></span><br><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    text: <span class="string">'這裡是一段文字'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>關於綁定：除了用 <code>id</code> 綁定以外，也可以在 HTML 元素設定 <code>class</code> 來綁定（<code>el</code> 的值也要由 <code>#</code> 改成 <code>.</code>）。但是如果同時有數個同樣 <code>class</code> 名稱的元素，Vue 只能帶資料到同 <code>class</code> 名稱的第一個元素上。所以大部份都還是用 <code>id</code> 綁定。</p>
</li>
</ul>
<h2 id="基本指令"><a href="#基本指令" class="headerlink" title="基本指令"></a>基本指令</h2><h3 id="v-model-—-從網頁上更動-JS-資料"><a href="#v-model-—-從網頁上更動-JS-資料" class="headerlink" title="v-model — 從網頁上更動 JS 資料"></a>v-model — 從網頁上更動 JS 資料</h3><p>上一段提到 Model 能夠從網頁上直接更改的方式，就是在輸入資料的 HTML 元素上，加上 <code>v-model</code> 這個屬性。</p>
<h3 id="v-text-—-雙花括號以外的資料綁定法"><a href="#v-text-—-雙花括號以外的資料綁定法" class="headerlink" title="v-text — 雙花括號以外的資料綁定法"></a>v-text — 雙花括號以外的資料綁定法</h3><p><code>v-text</code> 相當於 <code>.textContent</code>，上面都是用雙花括號包住資料的特性名稱來將 Model 渲染到網頁上，除了這個方法以外，也可以在要塞入 Model 的 HTML 元素上，加上 <code>v-text</code> 屬性來連接 Model 內容。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-text</span>=<span class="string">"message"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="v-html-—-傳入-HTML-標籤"><a href="#v-html-—-傳入-HTML-標籤" class="headerlink" title="v-html — 傳入 HTML 標籤"></a>v-html — 傳入 HTML 標籤</h3><p><code>v-html</code> 相當於 <code>.innerHTML</code>，如果想渲染到網頁上的 Model 含有 HTML 標籤，就要在要插入資料的元素上使用 <code>v-html</code> 屬性並與 Model 綁定，畫面上才會正確解讀 HTML 格式。同樣的內容用雙花括號跟 <code>v-text</code> 顯示出來的會是一串字串，而沒辦法正確渲染出 HTML 格式。</p>
<iframe src="https://codepen.io/gretema/embed/vYYywrG?height=265&theme-id=default&default-tab=html,result" width="100%" height="300" frameborder="0" loading="lazy" allowfullscreen></iframe>

<h3 id="v-bind-—-以參數更新-HTML-屬性"><a href="#v-bind-—-以參數更新-HTML-屬性" class="headerlink" title="v-bind — 以參數更新 HTML 屬性"></a>v-bind — 以參數更新 HTML 屬性</h3><p>雙花括號中填入資料特性名稱的方法，並不適用於 HTML <strong>屬性</strong>，因此我們應該把 <code>v-bind:</code> 加在 HTML 屬性前面，且在屬性對應的值中放置<strong>參數</strong>（資料特性名稱），並在 Model 中定義要傳入的值。<code>v-bind</code> 的縮寫是去掉 <code>v-bind</code>、只留下一個冒號 <code>:</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HTML</span></span><br><span class="line">&lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">  &lt;img v-bind:src=<span class="string">"imgSrc"</span> v-bind:<span class="class"><span class="keyword">class</span></span>=<span class="string">"className"</span> alt=<span class="string">""</span>&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ JS</span></span><br><span class="line"><span class="regexp">var app = new Vue(&#123;</span></span><br><span class="line"><span class="regexp">  el: '#app',</span></span><br><span class="line"><span class="regexp">  data: &#123;</span></span><br><span class="line"><span class="regexp">    imgSrc: '圖片位址',</span></span><br><span class="line"><span class="regexp">    className: 'img-fluid'</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br></pre></td></tr></table></figure>

<h4 id="v-model-vs-v-bind"><a href="#v-model-vs-v-bind" class="headerlink" title="v-model vs v-bind"></a>v-model vs v-bind</h4><p><code>v-bind</code> 是將<strong>狀態</strong>綁定到 HTML 元素上，而 <code>v-model</code> 是<strong>接收資料</strong>，所以基本上 <code>v-model</code> 只會用在 <code>&lt;input&gt;</code>、<code>&lt;textarea&gt;</code>、<code>&lt;select&gt;</code> 這些<strong>傳入資訊</strong>的元素。</p>
<h3 id="v-for-—-呈現資料列表"><a href="#v-for-—-呈現資料列表" class="headerlink" title="v-for — 呈現資料列表"></a>v-for — 呈現資料列表</h3><p>原生 JavaScript 疊代的方式依照型別的不同可以分成 <code>for</code> 迴圈、<code>forEach()</code>、<code>for…in</code>，而使用 Vue 的話全部都可以用 <code>v-for</code> 來疊代。</p>
<p>例如，在 JavaScript 中需要透過迴圈並用串字串方式來新增多個同樣內容的 <code>&lt;li&gt;</code>，在 Vue 只要把 <code>v-for</code> 放在一個 <code>&lt;li&gt;</code> 上就有同樣的結果。</p>
<p>下面的程式碼中， <code>item</code> 是一個參數（你也可以為它取別的名字）並用來指涉需要被疊代的陣列元素，<code>list</code> 指的是自定義的陣列名稱（陣列元素為數個物件）， <code>in</code> 也可以寫成 <code>of</code>，因為這樣更接近原生 JavaScript 疊代器的語法。</p>
<p>在 <code>&lt;li&gt;</code> 上使用 <code>v-for</code> 並綁定要呈現的 <code>data</code> 資料，接著在 <code>&lt;li&gt; &lt;/li&gt;</code> 之間寫入要呈現的資料，雙花括號包起來的是 <code>item.資料特性</code>。</p>
<p><code>v-for</code> 還支援第二個參數 — — 索引值（index），帶入索引值參數的方法是在原本 <code>item</code> 的位置改寫成 <code>(item, index)</code> 即可。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HTML</span></span><br><span class="line">&lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">  &lt;ul&gt;</span><br><span class="line">    &lt;li v-<span class="keyword">for</span>=<span class="string">"item in list"</span>&gt;</span><br><span class="line">      &#123;&#123; item.name &#125;&#125; 今年 &#123;&#123;item.age&#125;&#125; 歲</span><br><span class="line">    &lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/u</span>l&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ JS</span></span><br><span class="line"><span class="regexp">var app = new Vue(&#123;</span></span><br><span class="line"><span class="regexp">  el: '#app',</span></span><br><span class="line"><span class="regexp">  data: &#123;</span></span><br><span class="line"><span class="regexp">    list: [</span></span><br><span class="line"><span class="regexp">      &#123;</span></span><br><span class="line"><span class="regexp">        name: '小明',</span></span><br><span class="line"><span class="regexp">        age: 16</span></span><br><span class="line"><span class="regexp">      &#125;,</span></span><br><span class="line"><span class="regexp">      &#123;</span></span><br><span class="line"><span class="regexp">        name: '媽媽',</span></span><br><span class="line"><span class="regexp">        age: 38</span></span><br><span class="line"><span class="regexp">      &#125;,</span></span><br><span class="line"><span class="regexp">      &#123;</span></span><br><span class="line"><span class="regexp">        name: '漂亮阿姨',</span></span><br><span class="line"><span class="regexp">        age: 24</span></span><br><span class="line"><span class="regexp">      &#125;</span></span><br><span class="line"><span class="regexp">    ]</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br></pre></td></tr></table></figure>

<h3 id="v-if-—-擷取部分資訊"><a href="#v-if-—-擷取部分資訊" class="headerlink" title="v-if — 擷取部分資訊"></a>v-if — 擷取部分資訊</h3><p>相當於判斷式的功能。跟 <code>v-for</code> 搭配使用時，可以依所設的條件渲染出部分的資料，也就是說只有資料符合條件時，該資料才會渲染出來，如果不符合條件，就不顯示。</p>
<p>使用方法是在已經用了 <code>v-for</code> 的 HTML 元素上多加上 <code>v-if=&quot;條件&quot;</code> ，條件一般是以陣列元素的參數去設計的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HTML</span></span><br><span class="line">&lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">  &lt;ul&gt;</span><br><span class="line">    &lt;li v-<span class="keyword">for</span>=<span class="string">"item in list"</span> v-<span class="keyword">if</span>=<span class="string">"item.age &gt; 20"</span>&gt;</span><br><span class="line">      &#123;&#123; item.name &#125;&#125; 今年 &#123;&#123;item.age&#125;&#125; 歲</span><br><span class="line">    &lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/u</span>l&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<p>礙於篇幅，還有一些基礎指令沒寫出來，挪到下一篇再介紹 😃</p>
]]></content>
      <categories>
        <category>Vuejs</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>[Hexo] 使用 NexT 主題如何在文章中內嵌 Codepen</title>
    <url>/hexo/20191217/2656253328/</url>
    <content><![CDATA[<p>估狗估不到什麼東西，還好自己有摸索成功，乾脆來發一篇！</p>
<a id="more"></a>
<p>在搬運 Medium 文章過來的過程中遇到一個問題，就是我之前在 Medium 寫文的時候超常 embed Codepen 的，畢竟有些效果真的有 Demo 輔助說明會比較好。<br>但在 hexo NexT 的環境下要怎麼嵌入 Codepen 哩？</p>
<h2 id="第一次踩雷"><a href="#第一次踩雷" class="headerlink" title="第一次踩雷"></a>第一次踩雷</h2><p>我首先找到這篇文章： <a href="https://www.jianshu.com/p/79e808bbf0a8" target="_blank" rel="external nofollow noopener noreferrer">Hexo NexT：在文章中嵌入 CodePen或 jsFiddle</a>，但是我下載完套件後，按照文中的方式在文章裡插入模板，卻跑出一堆錯誤訊息，整篇文章的內容都無法渲染。</p>
<p>所以我只好捨棄這個方法，跑去翻翻 NexT 官方文件：<a href="https://hexo.io/zh-tw/docs/tag-plugins" target="_blank" rel="external nofollow noopener noreferrer">標籤外掛（Tag Plugins）</a>。<br>看到官方有提供插入 iframe 的語法，我就想說 Codepen 也有提供 iframe 程式碼，說不定行得通。</p>
<h2 id="Next-與-Codepen-iframe-語法"><a href="#Next-與-Codepen-iframe-語法" class="headerlink" title="Next 與 Codepen iframe 語法"></a>Next 與 Codepen iframe 語法</h2><p>Next 官方提供的語法：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% iframe url [width] [height] %&#125;</span><br></pre></td></tr></table></figure>

<p>Codepen 提供的 iframe 程式碼：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">height</span>=<span class="string">"265"</span> <span class="attr">style</span>=<span class="string">"width: 100%;"</span> <span class="attr">scrolling</span>=<span class="string">"no"</span> <span class="attr">title</span>=<span class="string">"bs flex order"</span> <span class="attr">src</span>=<span class="string">"https://codepen.io/gretema/embed/eYOjPJx?height=265&amp;theme-id=default&amp;default-tab=html,result"</span> <span class="attr">frameborder</span>=<span class="string">"no"</span> <span class="attr">allowtransparency</span>=<span class="string">"true"</span> <span class="attr">allowfullscreen</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">  See the Pen <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">'https://codepen.io/gretema/pen/eYOjPJx'</span>&gt;</span>bs flex order<span class="tag">&lt;/<span class="name">a</span>&gt;</span> by 馬維君</span><br><span class="line">  (<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">'https://codepen.io/gretema'</span>&gt;</span>@gretema<span class="tag">&lt;/<span class="name">a</span>&gt;</span>) on <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">'https://codepen.io'</span>&gt;</span>CodePen<span class="tag">&lt;/<span class="name">a</span>&gt;</span>.</span><br><span class="line"><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="第二次踩雷"><a href="#第二次踩雷" class="headerlink" title="第二次踩雷"></a>第二次踩雷</h2><p>我把 Next 語法中的 <code>url</code> 代換成 Codepen 連結網址 (<code>https://codepen.io/gretema/pen/eYOjPJx</code>)，<code>[width]</code> 代換成 <code>[100%]</code>，<code>[height]</code> 代換成 <code>[265]</code>。<br>寬度跟高度的數值都是從 Codepen 提供的程式碼中取出來的。<br>呈現出來是這樣：</p>
<iframe src="https://codepen.io/gretema/pen/eYOjPJx" width="[100%]" height="[265]" frameborder="0" loading="lazy" allowfullscreen></iframe>
<p>嗯…… Codepen 畫面是出來了，但尺寸很有問題。</p>
<h2 id="終於成功啦"><a href="#終於成功啦" class="headerlink" title="終於成功啦"></a>終於成功啦</h2><p>最後，我嘗試把 Codepen 提供的程式碼中，<code>&lt;iframe&gt;</code> 的 <code>src</code> 值取出來，放到 Next iframe 語法的 <code>url</code> 位置，而 <code>[width]</code> 跟 <code>[height]</code> 都去掉。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% iframe https://codepen.io/gretema/embed/eYOjPJx?height=265&amp;theme-id=default&amp;default-tab=html,result %&#125;</span><br></pre></td></tr></table></figure>

<p>嵌入成功！</p>
<iframe src="https://codepen.io/gretema/embed/eYOjPJx?height=265&theme-id=default&default-tab=html,result" width="100%" height="300" frameborder="0" loading="lazy" allowfullscreen></iframe>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>next</tag>
        <tag>codepen</tag>
      </tags>
  </entry>
  <entry>
    <title>[CSS] CSS3 flex 屬性</title>
    <url>/htmlcss/20191217/214491870/</url>
    <content><![CDATA[<p>我是在學習 Bootstrap 4 時才真正接觸到這個 CSS3 的屬性，在此之前都是用 float 屬性在排版。但是用 float 的缺點就是清除浮動很麻煩，如果能夠掌握 flex 屬性的話就能解決這個問題，而且真的能夠更加「彈性」地排版。</p>
<p>以下．就讓我們來了解 flex 屬性吧！</p>
<a id="more"></a>

<h2 id="軸線觀念"><a href="#軸線觀念" class="headerlink" title="軸線觀念"></a>軸線觀念</h2><p>以前學到的 float 只能水平排列，現在學到的 flex 能夠同時做到水平跟垂直排列，也因此衍生出不同對齊方式，所以使用了 flex 的元素也就有了「軸線」這個東西。</p>
<p>在<strong>預設</strong>的情況下，水平方向的軸線稱為<strong>主軸線</strong>，垂直方向的軸線稱為<strong>交錯軸</strong>，兩種軸線都有<strong>起點</strong>跟<strong>終點</strong>，物件會從主軸線起點（左到右）開始排列。<br><img src="https://upload.cc/i1/2019/12/17/ir0BpN.png" alt></p>
<p>必須注意的是，當物件排列的方向改變時（上到下），主軸線跟交錯軸的方向就會交換，垂直的軸線變成主軸線、水平的軸線變成交錯軸。<br><img src="https://upload.cc/i1/2019/12/17/puywS6.png" alt="."></p>
<h2 id="一覽-flex-相關屬性"><a href="#一覽-flex-相關屬性" class="headerlink" title="一覽 flex 相關屬性"></a>一覽 flex 相關屬性</h2><p>可以用<strong>外層屬性</strong>或<strong>內層屬性</strong>來分類，也可以用<strong>是否為對齊方法</strong>來分類。<br>粗體為特別重要的屬性。</p>
<h3 id="外層屬性"><a href="#外層屬性" class="headerlink" title="外層屬性"></a>外層屬性</h3><ul>
<li>display - 必備屬性，宣告 flex 排版</li>
<li>flex-flow<ul>
<li><strong>flex-direction</strong> - 決定 flex 軸線</li>
<li>flex-wrap - 決定換行的屬性</li>
</ul>
</li>
<li><strong>justify-content</strong> - 主軸線的對齊</li>
<li><strong>align-items</strong> - 交錯軸的對齊</li>
</ul>
<h3 id="內層屬性"><a href="#內層屬性" class="headerlink" title="內層屬性"></a>內層屬性</h3><ul>
<li>flex<ul>
<li>flex-grow - 伸展比</li>
<li>flex-shrink - 收縮比</li>
<li>flex-basis - 絕對值</li>
</ul>
</li>
<li>order - 排序</li>
<li><strong>align-self</strong> - 單一物件的交錯軸對齊</li>
</ul>
<h3 id="對齊方法"><a href="#對齊方法" class="headerlink" title="對齊方法"></a>對齊方法</h3><h4 id="flex-direction-屬性"><a href="#flex-direction-屬性" class="headerlink" title="flex-direction 屬性"></a><code>flex-direction</code> 屬性</h4><p>決定主軸線方向，共有四個值。</p>
<ul>
<li>row：預設值，物件將沿著主軸線由左到右排列</li>
<li>row-reverse：反轉主軸線，物件將沿著主軸線由右到左排列</li>
<li>column：將主軸線由水平改為垂直，物件將由上至下排列</li>
<li>column-reverse：將主軸線由水平改為垂直，物件將由下至上排列</li>
</ul>
<h4 id="justify-content-屬性"><a href="#justify-content-屬性" class="headerlink" title="justify-content 屬性"></a><code>justify-content</code> 屬性</h4><p>依據主軸線決定內層物件之間的間隔方式。共有五個值。</p>
<ul>
<li>flex-start：所有內層物件對齊主軸線起點</li>
<li>flex-end：所有內層物件對齊主軸線終點</li>
<li>center：所有內層物件置中在主軸線上</li>
<li>space-between：內層物件頭尾在主軸線起訖點，其餘物件等距對齊</li>
<li>space-around：所有內層物件之間等距對齊</li>
</ul>
<p><img src="https://upload.cc/i1/2019/12/17/S2noQc.png" alt></p>
<h4 id="align-items-屬性"><a href="#align-items-屬性" class="headerlink" title="align-items 屬性"></a>align-items 屬性</h4><p>依據交錯軸決定內層物件的垂直對齊方式。共有五個值。</p>
<ul>
<li>flex-start：所有內層物件對齊交錯軸起點</li>
<li>flex-end：所有內層物件對齊交錯軸終點</li>
<li>center：所有內層物件在交錯軸上置中</li>
<li>baseline：跟文字行高有關，用文字的基準線作排列（很少用）</li>
<li>stretch：所有內層物件拉高，由交錯軸起點拉到終點</li>
</ul>
<p><img src="https://upload.cc/i1/2019/12/17/7n3Gbm.png" alt></p>
<h4 id="align-self-屬性"><a href="#align-self-屬性" class="headerlink" title="align-self 屬性"></a>align-self 屬性</h4><p>個別的內層元件本身的垂直對齊方式，此屬性的值跟 <code>align-items</code> 一模一樣。</p>
<h3 id="對齊以外的其他屬性"><a href="#對齊以外的其他屬性" class="headerlink" title="對齊以外的其他屬性"></a>對齊以外的其他屬性</h3><h4 id="flex-wrap-屬性（外層）"><a href="#flex-wrap-屬性（外層）" class="headerlink" title="flex-wrap 屬性（外層）"></a>flex-wrap 屬性（外層）</h4><p>決定物件超出範圍時要不要換行。</p>
<p class="codepen" data-height="265" data-theme-id="default" data-default-tab="html,result" data-user="gretema" data-slug-hash="yLBqRaQ" style="height: 265px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;" data-pen-title="bs flex flex-wrap">
  <span>See the Pen <a href="https://codepen.io/gretema/pen/yLBqRaQ" target="_blank" rel="external nofollow noopener noreferrer">
  bs flex flex-wrap</a> by 馬維君 (<a href="https://codepen.io/gretema" target="_blank" rel="external nofollow noopener noreferrer">@gretema</a>)
  on <a href="https://codepen.io" target="_blank" rel="external nofollow noopener noreferrer">CodePen</a>.</span>
</p>
<script async src="https://static.codepen.io/assets/embed/ei.js"></script>

<p>範例中，原本 <code>.col-*</code> 會被 <code>.row</code> 包裹，但因為 Bootstrap 已經幫 <code>.row</code> 內建 <code>flex-wrap</code> 換行了，所以改用 <code>.d-flex</code> 包裹 <code>.col-*</code>。</p>
<h4 id="align-content（外層）"><a href="#align-content（外層）" class="headerlink" title="align-content（外層）"></a>align-content（外層）</h4><p>只有在換行（<code>flex-wrap</code>）的情況下可使用，用在有高度的外層容器上，會使內層物件在父元素內垂直對齊。</p>
<p class="codepen" data-height="265" data-theme-id="default" data-default-tab="html,result" data-user="gretema" data-slug-hash="mdbjzqw" style="height: 265px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;" data-pen-title="bs flex align-content">
  <span>See the Pen <a href="https://codepen.io/gretema/pen/mdbjzqw" target="_blank" rel="external nofollow noopener noreferrer">
  bs flex align-content</a> by 馬維君 (<a href="https://codepen.io/gretema" target="_blank" rel="external nofollow noopener noreferrer">@gretema</a>)
  on <a href="https://codepen.io" target="_blank" rel="external nofollow noopener noreferrer">CodePen</a>.</span>
</p>
<script async src="https://static.codepen.io/assets/embed/ei.js"></script>

<h4 id="order-屬性（內層）"><a href="#order-屬性（內層）" class="headerlink" title="order 屬性（內層）"></a>order 屬性（內層）</h4><p>用來更改區塊排列的順序，將 <code>order-*</code> 寫在 class 裡，<code>*</code> 代表我們希望區塊排列的順序。</p>
<p class="codepen" data-height="265" data-theme-id="default" data-default-tab="html,result" data-user="gretema" data-slug-hash="eYOjPJx" style="height: 265px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;" data-pen-title="bs flex order">
  <span>See the Pen <a href="https://codepen.io/gretema/pen/eYOjPJx" target="_blank" rel="external nofollow noopener noreferrer">
  bs flex order</a> by 馬維君 (<a href="https://codepen.io/gretema" target="_blank" rel="external nofollow noopener noreferrer">@gretema</a>)
  on <a href="https://codepen.io" target="_blank" rel="external nofollow noopener noreferrer">CodePen</a>.</span>
</p>
<script async src="https://static.codepen.io/assets/embed/ei.js"></script>

<hr>
<p>參考資料：<a href="https://wcc723.github.io/css/2017/07/21/css-flex/" target="_blank" rel="external nofollow noopener noreferrer">圖解：CSS Flex 屬性一點也不難</a></p>
<hr>
<p>看完這篇，保證你可以加入六角戰隊去<a href="https://hexschool.github.io/flexbox-pirate/index.html#/" target="_blank" rel="external nofollow noopener noreferrer">打海盜</a>！</p>
]]></content>
      <categories>
        <category>HTML&amp;CSS</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
        <tag>flexbox</tag>
      </tags>
  </entry>
  <entry>
    <title>[SASS] SASS 基礎概念 2</title>
    <url>/SASS/20191217/3307620580/</url>
    <content><![CDATA[<p>延續上一篇的主題，本篇將整理稍微進階一些、但更接近實作的相關應用，包含如何使用 SASS 來提升響應式設計的開發效率。</p>
<a id="more"></a>

<h2 id="化簡知識庫：-mixin-設定常用語法，-include-召喚出來"><a href="#化簡知識庫：-mixin-設定常用語法，-include-召喚出來" class="headerlink" title="化簡知識庫：@mixin 設定常用語法，@include 召喚出來"></a>化簡知識庫：<code>@mixin</code> 設定常用語法，<code>@include</code> 召喚出來</h2><p>這個語法可以省去一直回想原理跟技巧的時間。</p>
<h3 id="基本用法：複製"><a href="#基本用法：複製" class="headerlink" title="基本用法：複製"></a>基本用法：複製</h3><ol>
<li>寫在檔案起始處，<code>@mixin</code> 後面取一個<strong>變數名</strong>接中括號，裡面寫該變數所欲達成的效果。</li>
<li>後面需要呼叫該效果時，先寫選擇器加中刮弧，裡面先寫 <code>@include</code>，後面加變數名稱。</li>
<li><code>@mixin</code> 裡面寫的常用語法，會用「&amp;」來表示所在的選擇器。例如：<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">&amp;<span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">  <span class="attribute">clear</span>: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="補充用法：參數"><a href="#補充用法：參數" class="headerlink" title="補充用法：參數"></a>補充用法：參數</h3><p><code>@mixin</code> 也可以設參數，而且可以是複數的參數。</p>
<p>例如，先在開頭設定如下：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@mixin</span> circle (<span class="variable">$size</span>, <span class="variable">$bgcolor</span>) &#123;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="variable">$size</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="variable">$size</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="variable">$size</span> / <span class="number">3</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="variable">$bgcolor</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之後要在某選擇器使用時，就可以簡單用一行字召喚出來了。</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">  <span class="keyword">@include</span> circle (<span class="number">30px</span>, <span class="number">#fff</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="用途舉例"><a href="#用途舉例" class="headerlink" title="用途舉例"></a>用途舉例</h3><ul>
<li>圖片取代文字</li>
<li>兼容各瀏覽器的 inline-block 的寫法</li>
<li>各 CSS3 語法瀏覽器支援解決方案</li>
<li>清除浮動</li>
<li>用 CSS 畫各方向的三角型</li>
</ul>
<blockquote>
<p>溫馨提示：平常可以多累積自己的 mixin 資料庫，設一個 mixin 資料夾把學過的一些 CSS 技巧記錄成 .sass 檔存放進去。有些面試官光看應徵者的 mixin 庫就能了解這個人處理過多少專案了。</p>
</blockquote>
<h2 id="將-mixin-用於開發-RWD"><a href="#將-mixin-用於開發-RWD" class="headerlink" title="將 @mixin 用於開發 RWD"></a>將 <code>@mixin</code> 用於開發 RWD</h2><p>先用 <code>@mixin</code> 設定好斷點，各斷點可以取名為該裝置的名字，例如 <code>pad</code>、<code>iPhone5</code> 等。<br>接著在 media query 裡面只要加一個東西，那就是 <code>@content</code>。</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@mixin</span> iphone5&#123;</span><br><span class="line">  <span class="keyword">@media</span> (max-width: <span class="number">320px</span>) &#123;</span><br><span class="line">    <span class="keyword">@content</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之後就先寫 PC 版的樣式，但在需要 RWD 的項目裡面，可以用 <code>@include</code> 呼叫斷點，然後直接寫 RWD 的樣式在裡面。</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.header</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>:<span class="number">100px</span>;</span><br><span class="line">  <span class="keyword">@include</span> iphone5&#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">30</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>溫馨提示：應該常備一個 <code>grid.scss</code> 專放用 <code>@mixin</code> 設定好的 media query 斷點，在開發時就可以打開來複製到手上的新專案。</p>
</blockquote>
<hr>
<p>掌握了這兩篇介紹的 SASS 基礎，就相當夠用了。當然，之後如果有機會再吸收一些 SASS 技巧也會繼續分享的。</p>
]]></content>
      <categories>
        <category>SASS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>SASS</tag>
      </tags>
  </entry>
  <entry>
    <title>[SASS] SASS 基礎概念 1</title>
    <url>/SASS/20191217/1546590558/</url>
    <content><![CDATA[<p>什麼是 SASS？ <del>不是 SARS 哦</del><br>來聊聊它的基本觀念。</p>
<a id="more"></a>

<h2 id="什麼是-SASS？"><a href="#什麼是-SASS？" class="headerlink" title="什麼是 SASS？"></a>什麼是 SASS？</h2><p>SASS 是一種針對 CSS 的腳本程式語言，藉由提供程式語言的特性，例如變數、巢狀結構、混合、函式與擴充（繼承）等等，可以預先對 CSS 進行結構化的工作，最後再編譯可使用於網頁上的 CSS 語法。需要搭配 SASS 解譯器 (如 prepros) 進行撰寫。</p>
<p>SASS 包括兩套語法。最開始的語法叫做「縮排語法」，使用縮排來區分程式碼塊，並且用換行將不同規則分隔開，附檔名為 .sass。而較新的語法叫做「SCSS」，使用和 CSS 一樣的塊語法，即使用大括號將不同的規則分開，使用分號將具體的樣式分開。</p>
<p>以下以 SCSS 語法為主，整理 SASS 的應用方法。</p>
<h2 id="寫法：減少重工，不必重複寫同樣的選取器。"><a href="#寫法：減少重工，不必重複寫同樣的選取器。" class="headerlink" title="寫法：減少重工，不必重複寫同樣的選取器。"></a>寫法：減少重工，不必重複寫同樣的選取器。</h2><p>子元素的樣式直接寫在父元素裡即可。</p>
<h2 id="變數：便於管理，快速管理出同樣設定的樣式"><a href="#變數：便於管理，快速管理出同樣設定的樣式" class="headerlink" title="變數：便於管理，快速管理出同樣設定的樣式"></a>變數：便於管理，快速管理出同樣設定的樣式</h2><p>在最前面設一個變數名，例如 <code>linkcolor</code> ，名稱前加一個 <code>$</code> 字號，並寫上該變數代表的值。例：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="variable">$linkcolor</span>: <span class="number">#000</span>;</span><br></pre></td></tr></table></figure>

<p>所有要做相同管理的屬性後面，都接上變數名。例：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.header</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="variable">$linkcolor</span></span><br><span class="line">&#125;</span><br><span class="line">.content a &#123;</span><br><span class="line">  color: <span class="variable">$linkcolor</span></span><br><span class="line">&#125;</span><br><span class="line">.footer a &#123;</span><br><span class="line">  color: <span class="variable">$linkcolor</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以後若要全部替代成別的值，就在 <code>$linkcolor</code> (變數名) 後面作值的修改即可。</p>
<blockquote>
<p>那麼，哪些項目適合用變數做全域設定？</p>
</blockquote>
<p>字型大小這種常常需要統一規格的項目就很適合。例：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="attribute">font</span>-m: <span class="number">16px</span>;</span><br><span class="line"><span class="attribute">font</span>-l: font-m * <span class="number">1.2</span> // 支援加減乘除</span><br><span class="line">font-s: font-m * <span class="number">0.8</span></span><br></pre></td></tr></table></figure>


<h2 id="拆檔：-import-讓每支-scss-檔各司其職"><a href="#拆檔：-import-讓每支-scss-檔各司其職" class="headerlink" title="拆檔：@import 讓每支 .scss 檔各司其職"></a>拆檔：<code>@import</code> 讓每支 .scss 檔各司其職</h2><ol>
<li>一支 .scss 檔案只單獨處理一件事，例如 reset 寫在一個 .scss 檔，檔名命名為 <code>_reset.scss</code>；首頁樣式寫在另一個檔，檔名命名為 <code>_index.scss</code>。前面加<u>底線</u>很重要，代表那是<strong>合併用</strong>的 sass 檔，理論上並不會編譯出對應的 .css 檔。</li>
<li>在名為 all 的 .scss 檔裡做統整，用 <code>@import</code>「依序」匯入個別的 .scss 檔。網頁中只會引入 <code>all.scss</code> 編譯出來的 <code>all.css</code>。</li>
</ol>
]]></content>
      <categories>
        <category>SASS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>SASS</tag>
      </tags>
  </entry>
  <entry>
    <title>[RWD] 響應式網頁 - 實作常見問題與錯誤</title>
    <url>/rwd/20191217/296575981/</url>
    <content><![CDATA[<p>乳蹄，本篇筆記非常簡潔扼要地列出 3 點 RWD 要注意的問題。</p>
<a id="more"></a>

<h2 id="確認-media-query-斷點"><a href="#確認-media-query-斷點" class="headerlink" title="確認 media query 斷點"></a>確認 media query 斷點</h2><p>先抓熱門的螢幕解析度，例如平板 (768px) 及 iPhone 5 橫式 (569px)，在這兩個解析度之間會有一個斷層，可能在寬度 6xx px 時版面會變得比較難看，此時就為這一段斷層加條件：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">@media(max-width: 767px) and (min-width: 569px)&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="media-query-到底要寫在一起還是分開寫"><a href="#media-query-到底要寫在一起還是分開寫" class="headerlink" title="media query 到底要寫在一起還是分開寫"></a>media query 到底要寫在一起還是分開寫</h2><p>同一個 <code>&lt;div&gt;</code> 就寫在一起，包含該 <code>&lt;div&gt;</code> 的子元素。</p>
<h2 id="不要習慣性寫死高度"><a href="#不要習慣性寫死高度" class="headerlink" title="不要習慣性寫死高度"></a>不要習慣性寫死高度</h2><p>在 PC 版上是可以寫固定高度的，因為版面不會隨螢幕大小而變化。但是要記得在 media query 中多加一行 <code>height: auto</code>，讓內容自適應延伸。</p>
]]></content>
      <categories>
        <category>RWD</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>響應式網頁設計</tag>
      </tags>
  </entry>
  <entry>
    <title>[RWD] 響應式網頁 - 固定式選單及 off-canvas 選單</title>
    <url>/rwd/20191216/822299504/</url>
    <content><![CDATA[<p>本篇文章接續上一篇，繼續記錄 RWD 的常用選單語法結構，包含固定式選單及側邊展開（off-canvas）選單等兩種。</p>
<a id="more"></a>

<h2 id="固定式選單"><a href="#固定式選單" class="headerlink" title="固定式選單"></a>固定式選單</h2><p>讓使用者在滑動頁面時，表頭永遠在螢幕上方。<br>使用 <code>position: fixed</code>，但要注意頁面內容會被表頭遮住，所以內容區塊要用 <code>padding-top</code> 空出表頭的高度，才不會被遮住部分內容。</p>
<h3 id="注意事項："><a href="#注意事項：" class="headerlink" title="注意事項："></a>注意事項：</h3><ul>
<li><code>position: fixed</code> 在安卓部分舊型手機上不適用，若能用 JS 做兼容是較好的做法。</li>
<li>要考慮到表頭是否會佔螢幕太多版面，會的話就不要用 <code>fixed</code>。</li>
</ul>
<h3 id="語法："><a href="#語法：" class="headerlink" title="語法："></a>語法：</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">@media(max-width: 767px)&#123;</span><br><span class="line">  <span class="selector-class">.header</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>: fixed;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">background</span>: black; &#125;</span><br><span class="line">  <span class="selector-class">.content</span>&#123;</span><br><span class="line">    <span class="attribute">padding-top</span>: <span class="number">81px</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="off-canvas-選單設計"><a href="#off-canvas-選單設計" class="headerlink" title="off canvas 選單設計"></a>off canvas 選單設計</h2><p>適合用於選項超多的選單，PC 版（放較少選項）跟手機版（放較多選項）可以各一套選單設計。</p>
<h3 id="說明："><a href="#說明：" class="headerlink" title="說明："></a>說明：</h3><p>請搭配 <a href="https://codepen.io/gretema/pen/zeyxqO" target="_blank" rel="external nofollow noopener noreferrer">範例程式碼</a> 一同閱讀。</p>
<ul>
<li>結構：<code>.container</code> 底下有 <code>.aside</code>（會滑出來的選單）跟 <code>.main</code>（底下有 <code>.header</code>）</li>
<li>預期效果：點了表頭中的 a 連結按鈕（<code>.mobile-link</code>）就會讓 <code>body</code> 動態加入 <code>.open</code>，之後 <code>.aside</code> 選單從左側滑出來，點 <code>.aside</code> 中的 a 連結按鈕（<code>.mobile-close</code>）又滑回去。</li>
</ul>
<h3 id="語法：-1"><a href="#語法：-1" class="headerlink" title="語法："></a>語法：</h3><h4 id="CSS："><a href="#CSS：" class="headerlink" title="CSS："></a>CSS：</h4><ol>
<li><code>.aside</code> 設定絕對定位<br>用 <code>transform</code> ( 或 <code>margin</code> ) 設定 X 軸位移的距離 (=寬度)<br>註：<code>transform</code> 在網頁上的效能比 <code>padding</code>、<code>margin</code> 都好<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.aside</span>&#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">270px</span>;</span><br><span class="line">  height: 100%;;</span><br><span class="line">  <span class="selector-tag">overflow</span>: <span class="selector-tag">hidden</span>;</span><br><span class="line">  <span class="selector-tag">transform</span>: <span class="selector-tag">translateX</span>(<span class="selector-tag">-270px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>核心程式碼<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.open</span> <span class="selector-class">.main</span>&#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translateX</span>(<span class="number">270px</span>);</span><br><span class="line">  // 點了 .header 會讓 .menu 往右推 270 px 以容納滑出來的選單</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.open</span> <span class="selector-class">.aside</span>&#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translateX</span>(<span class="number">0px</span>);</span><br><span class="line">  // 點了 .header 會讓選單滑入視窗中</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>選單滑入的動畫效果 — <code>transition</code>，可以有<strong>影格效果</strong><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.main</span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="selector-tag">transition</span>: 0<span class="selector-class">.3s</span> <span class="selector-tag">ease</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="jQ："><a href="#jQ：" class="headerlink" title="jQ："></a>jQ：</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">'.mobile-link'</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  $(<span class="string">'body'</span>).addClass(<span class="string">'open'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">$(<span class="string">'.mobile-close'</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  $(<span class="string">'body'</span>).removeClass(<span class="string">'open'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<hr>
<p>好啦，響應式的選單設計就先介紹四種，雖然選單不是響應式設計的全部，但應該算是蠻核心的部分了，其他眉眉角角就等我之後有時間精力再來補寫囉（癱）。</p>
]]></content>
      <categories>
        <category>RWD</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>響應式網頁設計</tag>
        <tag>HTML</tag>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title>[RWD] 響應式網頁 - 多欄多列選單及漢堡選單</title>
    <url>/rwd/20191216/3809709620/</url>
    <content><![CDATA[<p>本篇文章將記錄 RWD 的常用選單語法結構，包含多行多列選單及漢堡選單等兩種。</p>
<a id="more"></a>

<h2 id="多欄多列選單排版法：以-3-2-為例"><a href="#多欄多列選單排版法：以-3-2-為例" class="headerlink" title="多欄多列選單排版法：以 3*2 為例"></a>多欄多列選單排版法：以 3*2 為例</h2><h3 id="語法："><a href="#語法：" class="headerlink" title="語法："></a>語法：</h3><h4 id="HTML："><a href="#HTML：" class="headerlink" title="HTML："></a>HTML：</h4><p><code>&lt;ul&gt;&lt;li&gt;</code> 結構，<code>&lt;li&gt;</code> 需要 6 個</p>
<h4 id="CSS："><a href="#CSS：" class="headerlink" title="CSS："></a>CSS：</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">float: right;  // PC版排版</span><br><span class="line"><span class="keyword">@media</span> ( <span class="attribute">max-width:</span> <span class="number">767px</span>)&#123;</span><br><span class="line">  float: none;  // 自然排列，這是 RWD 的精髓</span><br><span class="line">  <span class="selector-tag">width</span>: 33<span class="selector-class">.33333</span> % ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="漢堡選單排版法"><a href="#漢堡選單排版法" class="headerlink" title="漢堡選單排版法"></a>漢堡選單排版法</h2><p>請搭配 <a href="https://codepen.io/gretema/pen/bzQveq" target="_blank" rel="external nofollow noopener noreferrer">範例程式碼</a> 一同觀看。</p>
<h3 id="漢堡選單是怎麼出現的"><a href="#漢堡選單是怎麼出現的" class="headerlink" title="漢堡選單是怎麼出現的"></a>漢堡選單是怎麼出現的</h3><p>在寫 PC 版時，就預先寫好了漢堡選單的按鈕（<code>&lt;a&gt;.showmenu</code>），只是用 <code>display: none</code> 先隱藏起來；漢堡選單裡的選項跟 PC 版其實是同一套，只是把 <code>float</code> 拿掉而已。</p>
<h3 id="PC-版選單怎麼變成漢堡選單的"><a href="#PC-版選單怎麼變成漢堡選單的" class="headerlink" title="PC 版選單怎麼變成漢堡選單的"></a>PC 版選單怎麼變成漢堡選單的</h3><h4 id="CSS：-1"><a href="#CSS：-1" class="headerlink" title="CSS："></a>CSS：</h4><blockquote>
<p>以下都是寫在 <code>@media (max-width: 767px)</code> 的大括號裡，在相對應的裝置才會觸發，1~3 都是 <code>.menu</code> 的樣式。</p>
</blockquote>
<ol>
<li>隱藏選單<strong>（關鍵語法）</strong>（之後會用 jQ 動態加入 <code>class</code>，就會展開）<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="attribute">max-height</span>: <span class="number">0px</span>;</span><br><span class="line"><span class="attribute">overflow</span>: hidden;</span><br></pre></td></tr></table></figure></li>
<li>絕對定位疊在網頁上<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="attribute">position</span>: absolute;</span><br><span class="line"><span class="attribute">z-index</span>: <span class="number">100</span>; <span class="comment">// 權重</span></span><br><span class="line"><span class="attribute">top</span>: <span class="number">81px</span>; <span class="comment">// 因為 header 80 px + border 1 px，若漢堡選單要從 header 下方展開就要這樣設</span></span><br><span class="line"><span class="attribute">left</span>: <span class="number">0</span>; <span class="comment">// 在絕對定位之下要做出滿版效果，左右都要0</span></span><br><span class="line"><span class="attribute">right</span>: <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li>
<li>選單展開的漸變效果<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">transition</span>: <span class="selector-tag">max-height</span> 2<span class="selector-class">.3s</span>;</span><br></pre></td></tr></table></figure></li>
<li>取消隱藏漢堡選單的按鈕<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.showmenu</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">float</span>: right;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">1</span> em;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>配合 jQ 指令的 CSS 語法：點擊後，動態在 <code>body</code> 加上 <code>class</code><figure class="highlight mel"><table><tr><td class="code"><pre><span class="line">.<span class="keyword">menu</span>-show .<span class="keyword">menu</span>&#123;</span><br><span class="line">  <span class="keyword">max</span>-height: <span class="number">500</span>px; <span class="comment">// 選單的高度，原本是設成 0 px</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="jQ："><a href="#jQ：" class="headerlink" title="jQ："></a>jQ：</h4>點擊漢堡按鈕（<code>.showmenu</code>） 後，取消預設連結功能，動態在 <code>body</code> 加上 <code>class</code>（<code>.menu-show</code>）。<figure class="highlight arcade"><table><tr><td class="code"><pre><span class="line">$(<span class="string">'.showmenu'</span>).on(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">  e.preventDefault();</span><br><span class="line">  $(<span class="string">'body'</span>).toggleClass(<span class="string">'menu-show'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<code>body</code> 加上 <code>.menu-show</code> 之後，<code>body</code> 中的 <code>.menu</code> 才會被觸發，否則按了也不會展開。</li>
</ol>
<h3 id="menu-show-為何是加在-body-上"><a href="#menu-show-為何是加在-body-上" class="headerlink" title=".menu-show 為何是加在 body 上"></a>.menu-show 為何是加在 body 上</h3><p>如果 jQ 是在 <code>.menu</code> 上動態加上 <code>class</code> 會怎麼樣呢？</p>
<p>其實要在哪裡動態加上 <code>class</code>，需要看網頁的樣式怎麼設計。像是有些設計可能不只影響 <code>.menu</code>，還會加上其他的效果，那就必須要加在 <code>body</code> 上。<br>若只有增加彈出選單的效果，那 <code>.menu-show</code> 其實不一定要在 <code>body</code> 上， 加在 <code>.header</code> 、加在 <code>.menu</code> 都可以。</p>
]]></content>
      <categories>
        <category>RWD</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>響應式網頁設計</tag>
        <tag>HTML</tag>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title>[RWD] 響應式網頁 - 常用選單樣式與注意事項</title>
    <url>/rwd/20191216/3160700070/</url>
    <content><![CDATA[<p>在學習響應式網頁設計（Responsive Web Design）的路上，想記錄一些學習過程跟基礎語法，本篇筆記將從 RWD 常用選單的樣式及實作時的注意事項開始這個系列的旅程。</p>
<a id="more"></a>

<h2 id="常用樣式"><a href="#常用樣式" class="headerlink" title="常用樣式"></a>常用樣式</h2><ul>
<li>一行式橫幅選單：每格選單的字數不能太多，文字總寬不能超過載具的寬度，例如一個字大約是 16px，在 iPhone 5 (320px) 上就不能超過 20 字。除了單行排列，也有 3*2 之類多欄多列的排版方式。但不要超過兩行，因為排到三行就占太多版面了。</li>
<li>漢堡選單：點開時覆蓋部分網頁內容，可以用下拉式，也可用從左 / 右方滑出的方式。</li>
</ul>
<h2 id="實作注意事項"><a href="#實作注意事項" class="headerlink" title="實作注意事項"></a>實作注意事項</h2><ul>
<li>要避免選單點開後把原本網頁內容往下擠的狀況，因為這樣瀏覽器在渲染網頁的時候效能會降低。</li>
<li>抓 320px 為最小值：這是 iPhone 5 、SE 的寬度，大約可以放 20 個字元（一格選項不超過4個字），不過考慮到留白的問題，12~16 個字元就差不多了。</li>
<li>不放奇數選單：3 個選項的選單還可以剛好用 33% 去處理，5 個選項的選單排起來會很尷尬地空一格出來，所以要與客戶溝通。</li>
</ul>
]]></content>
      <categories>
        <category>RWD</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>響應式網頁設計</tag>
      </tags>
  </entry>
  <entry>
    <title>[CSS] 浮動 (float) 與清除浮動 (clear)</title>
    <url>/htmlcss/20191216/714228330/</url>
    <content><![CDATA[<p>由於老師耳提面命，<code>float</code> 及 <code>clear</code> 是網頁排版的基石之一，所以決定來彙整一下相關的資料，剛好某種程度上也可以承接上一篇的主題。</p>
<a id="more"></a>

<h2 id="float-屬性的使用時機"><a href="#float-屬性的使用時機" class="headerlink" title="float 屬性的使用時機"></a>float 屬性的使用時機</h2><p>使用諸如 <code>&lt;div&gt;</code> 之類的區塊元素排版時，預設的排列方式都是由左至右、由上至下。但如果我們今天想要做的是多欄式排版，或是讓多個區塊元素並排時，就需要使用 <code>float</code> 屬性。</p>
<h2 id="float-屬性的值"><a href="#float-屬性的值" class="headerlink" title="float 屬性的值"></a>float 屬性的值</h2><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="attribute">float</span>: 浮動方向 ;</span><br></pre></td></tr></table></figure>
<p>浮動方向可以用的值有 <code>left</code>、<code>right</code>、<code>none</code>（預設值，也就是不浮動）以及 <code>inherit</code>（繼承自父層的屬性），最後這個 <code>inherit</code> 盡量不要使用，避免 IE 不支援的情況發生。</p>
<h2 id="clear-屬性的使用時機"><a href="#clear-屬性的使用時機" class="headerlink" title="clear 屬性的使用時機"></a>clear 屬性的使用時機</h2><p>如果想控制浮動元素的排版，就一定要懂 <code>clear</code> 屬性的操作方式。</p>
<p>有時候，浮動元素在前，而後面的元素沒有使用浮動時，後面的元素就會往上跑、疊在前一個元素的下方；有時候，父層內的元素使用浮動，會讓父層包不住子元素。</p>
<p>遇到這種情形時，就要使用 clear 屬性來處理跑版問題。</p>
<p><img src="https://upload.cc/i1/2019/12/17/YZure6.jpeg" alt="父層包不住子元素"></p>
<h2 id="clear-屬性的使用方法"><a href="#clear-屬性的使用方法" class="headerlink" title="clear 屬性的使用方法"></a>clear 屬性的使用方法</h2><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="attribute">clear</span>: 清除方向 ;</span><br></pre></td></tr></table></figure>
<p><code>clear</code> 屬性可以用的值有 <code>left</code>、<code>right</code>、<code>both</code>、<code>none</code> 以及 <code>inherit</code>（IE不支援）， 其中以 <code>both</code> 最常用。</p>
<p><code>clear</code> 屬性可以有 3 種使用方法：</p>
<ol>
<li>在浮動元素的後面多加一個 <code>&lt;div&gt;</code>（命名為 <code>.clearfix</code>），並在 <code>.clearfix</code> 使用 <code>clear: both</code> 語法。</li>
<li>在要清除浮動內容的父層多加一個 <code>.clearfix</code> 並使用偽元素。★<br><img src="https://upload.cc/i1/2019/12/17/cZz5wI.jpeg" alt="after 僞元素：透過 content 在元素的後面生成了内容爲一個點的區塊元素"></li>
<li>在浮動元素後面的區塊元素加上 <code>clear: both</code>。</li>
</ol>
<blockquote>
<p>使用 <code>clear</code> 屬性須注意，在 <code>&lt;ul&gt;&lt;li&gt;</code> 結構中，必須在 <code>&lt;ul&gt;</code> 父元素清除子元素，沒辦法在 <code>&lt;li&gt;</code> 後面插入 <code>.clearfix</code>。</p>
</blockquote>
]]></content>
      <categories>
        <category>HTML&amp;CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>float</tag>
        <tag>clear</tag>
      </tags>
  </entry>
  <entry>
    <title>[CSS] 沒有清除浮動，還是沒搞清楚元素特性？</title>
    <url>/htmlcss/20191216/3595727743/</url>
    <content><![CDATA[<p>昨天在六角學院社團看到有人發問排版問題，因為是我第一次試著替別人 debug 因此特別想記錄下來，順便當作我使用部落格紀錄前端學習之路的濫觴。</p>
<a id="more"></a>

<hr>
<p>這位同學的問題是這樣的：</p>
<blockquote>
<p>「 請問大家，相似的浮動為什麼第一張圖 submit 會跑掉，在 textarea 結束加 clearfix 才正常（第二張圖），第三張就不會？」</p>
</blockquote>
<p><img src="https://upload.cc/i1/2019/12/17/LlC0gj.jpeg" alt="圖 1"><br><img src="https://upload.cc/i1/2019/12/17/WDRnSZ.jpeg" alt="圖 2"><br><img src="https://upload.cc/i1/2019/12/17/vwK2S3.jpeg" alt="圖 3"></p>
<p>我這樣回答：</p>
<blockquote>
<p>「因為第一張 textarea 沒有下 <code>display:block</code>，所以按鈕就跟它並排了；而第三張的 input text 都有下 <code>display:block</code>，所以按鈕就不會並排。」</p>
</blockquote>
<p><code>&lt;input&gt;</code> 跟 <code>&lt;img&gt;</code>，<code>display</code> 預設都是 <code>inline-block</code>，也就是說如果不指定為 <code>block</code>，排完它的寬度後，如果還有空間，底下非 <code>block</code> 的元素或浮動元素就會跑上來。<code>inline</code> 跟 <code>inline-block</code> 的差別在於，前者不能指定寬高，而後者可以。</p>
<p>第一個圖會跑版的原因是因為 <code>&lt;textarea&gt;</code> 沒有下 <code>display:block</code>，所以 <code>float</code> 的按鈕便與他並排了。<br>並排之後整個 <code>&lt;form&gt;</code> 加上左邊的 <code>&lt;h6&gt;</code> 的寬度後，整體超過了 <code>.faqform</code>，所以才會掉下來。</p>
<p>第二個圖裡，<code>&lt;textarea&gt;</code> 下面多加了一塊 <code>&lt;div&gt;</code>，這個 <code>&lt;div&gt;</code> 的屬性是 <code>block</code> ，所以不是因為加了 <code>clearfix</code>，如果把那個 <code>class</code> 去掉，只留下 <code>&lt;div&gt;</code>，也會有同樣效果。如此，接下來的按鈕便不會前面的原素並排，整個 <code>&lt;form&gt;</code> 加上左邊 <code>&lt;h6&gt;</code> 的寬度後也還在 <code>.faqform</code> 的極限內，版型就正常了。</p>
<p>第三個圖版型正常的原因，也是因為前面的元素加了 <code>block</code>，而且整個 <code>.form</code> 加上左邊 <code>&lt;h4&gt;</code> 的寬度後還在 <code>.faqform</code> 的極限內。</p>
<p>此外，盒模型的概念也是很重要，子元素要注意寬度加起來是否會超過包住它的父層， 不然一旦內容寬度超過就一定會跑版了。</p>
]]></content>
      <categories>
        <category>HTML&amp;CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>float</tag>
        <tag>display</tag>
      </tags>
  </entry>
  <entry>
    <title>被推坑的 Hexo Blog</title>
    <url>/hexo/20191216/2697934891/</url>
    <content><![CDATA[<p>這陣子專案告了一個段落，有感於自己 Git 操作很不熟，在 Ray 的建議之下開始使用 Hexo 自架部落格，據說對熟悉指令有奇效（？）。<br>結果手忙腳亂地把基本環境一步一步架起來後，Ray 才說他只是不甘心只有自己踩雷、要讓更多人一起踩進來，<del>總之就是報復社會就對惹</del>。<br>總之，以後這邊應該就是放純技術文章、學習筆記，而 Medium 則是放一些軟性文章，例如讀書心得、碎碎唸之類的。</p>
<p>接下來就是要 <del>愚公移山</del> 把 Medium 的技術文移過來了。</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
  </entry>
</search>
